(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/echarts-gl/lib/util/EChartsSurface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Surface texture in the 3D scene.
 * Provide management and rendering of zrender shapes and groups
 *
 * @module echarts-gl/util/EChartsSurface
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector2.js [app-client] (ecmascript)");
;
;
;
var events = [
    'mousedown',
    'mouseup',
    'mousemove',
    'mouseover',
    'mouseout',
    'click',
    'dblclick',
    'contextmenu'
];
function makeHandlerName(eventName) {
    return '_on' + eventName;
}
/**
 * @constructor
 * @alias echarts-gl/util/EChartsSurface
 * @param {module:echarts~ECharts} chart
 */ var EChartsSurface = function(chart) {
    var self = this;
    this._texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        anisotropic: 32,
        flipY: false,
        surface: this,
        dispose: function(renderer) {
            self.dispose();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.dispose.call(this, renderer);
        }
    });
    events.forEach(function(eventName) {
        this[makeHandlerName(eventName)] = function(eveObj) {
            if (!eveObj.triangle) {
                return;
            }
            this._meshes.forEach(function(mesh) {
                this.dispatchEvent(eventName, mesh, eveObj.triangle, eveObj.point);
            }, this);
        };
    }, this);
    this._meshes = [];
    if (chart) {
        this.setECharts(chart);
    } // Texture updated callback;
    this.onupdate = null;
};
EChartsSurface.prototype = {
    constructor: EChartsSurface,
    getTexture: function() {
        return this._texture;
    },
    setECharts: function(chart) {
        this._chart = chart;
        var canvas = chart.getDom();
        if (!(canvas instanceof HTMLCanvasElement)) {
            console.error('ECharts must init on canvas if it is used as texture.'); // Use an empty canvas
            canvas = document.createElement('canvas');
        } else {
            var self = this; // Wrap refreshImmediately
            var zr = chart.getZr();
            var oldRefreshImmediately = zr.__oldRefreshImmediately || zr.refreshImmediately;
            zr.refreshImmediately = function() {
                oldRefreshImmediately.call(this);
                self._texture.dirty();
                self.onupdate && self.onupdate();
            };
            zr.__oldRefreshImmediately = oldRefreshImmediately;
        }
        this._texture.image = canvas;
        this._texture.dirty();
        this.onupdate && this.onupdate();
    },
    /**
   * @method
   * @param {clay.Mesh} attachedMesh
   * @param {Array.<number>} triangle Triangle indices
   * @param {clay.math.Vector3} point
   */ dispatchEvent: function() {
        var p0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var uv0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var uv1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var uv2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var uv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var vCross = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        return function(eventName, attachedMesh, triangle, point) {
            var geo = attachedMesh.geometry;
            var position = geo.attributes.position;
            var texcoord = geo.attributes.texcoord0;
            var dot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dot;
            var cross = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross;
            position.get(triangle[0], p0.array);
            position.get(triangle[1], p1.array);
            position.get(triangle[2], p2.array);
            texcoord.get(triangle[0], uv0.array);
            texcoord.get(triangle[1], uv1.array);
            texcoord.get(triangle[2], uv2.array);
            cross(vCross, p1, p2);
            var det = dot(p0, vCross);
            var t = dot(point, vCross) / det;
            cross(vCross, p2, p0);
            var u = dot(point, vCross) / det;
            cross(vCross, p0, p1);
            var v = dot(point, vCross) / det;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].scale(uv, uv0, t);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].scaleAndAdd(uv, uv, uv1, u);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].scaleAndAdd(uv, uv, uv2, v);
            var x = uv.x * this._chart.getWidth();
            var y = uv.y * this._chart.getHeight();
            this._chart.getZr().handler.dispatch(eventName, {
                zrX: x,
                zrY: y
            });
        };
    }(),
    attachToMesh: function(mesh) {
        if (this._meshes.indexOf(mesh) >= 0) {
            return;
        }
        events.forEach(function(eventName) {
            mesh.on(eventName, this[makeHandlerName(eventName)], this);
        }, this);
        this._meshes.push(mesh);
    },
    detachFromMesh: function(mesh) {
        var idx = this._meshes.indexOf(mesh);
        if (idx >= 0) {
            this._meshes.splice(idx, 1);
        }
        events.forEach(function(eventName) {
            mesh.off(eventName, this[makeHandlerName(eventName)]);
        }, this);
    },
    dispose: function() {
        this._meshes.forEach(function(mesh) {
            this.detachFromMesh(mesh);
        }, this);
    }
};
const __TURBOPACK__default__export__ = EChartsSurface;
}}),
"[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
;
var retrieve = {
    firstNotNull: function() {
        for(var i = 0, len = arguments.length; i < len; i++){
            if (arguments[i] != null) {
                return arguments[i];
            }
        }
    },
    /**
   * @param {module:echarts/data/List} data
   * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
   *                         each of which can be Array or primary type.
   * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
   */ queryDataIndex: function(data, payload) {
        if (payload.dataIndexInside != null) {
            return payload.dataIndexInside;
        } else if (payload.dataIndex != null) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(payload.dataIndex) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].map(payload.dataIndex, function(value) {
                return data.indexOfRawIndex(value);
            }) : data.indexOfRawIndex(payload.dataIndex);
        } else if (payload.name != null) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(payload.name) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].map(payload.name, function(value) {
                return data.indexOfName(value);
            }) : data.indexOfName(payload.name);
        }
    }
};
const __TURBOPACK__default__export__ = retrieve;
}}),
"[project]/node_modules/echarts-gl/lib/util/animatableMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$Animator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/animation/Animator.js [app-client] (ecmascript)");
;
var animatableMixin = {
    _animators: null,
    getAnimators: function() {
        this._animators = this._animators || [];
        return this._animators;
    },
    animate: function(path, opts) {
        this._animators = this._animators || [];
        var el = this;
        var target;
        if (path) {
            var pathSplitted = path.split('.');
            var prop = el;
            for(var i = 0, l = pathSplitted.length; i < l; i++){
                if (!prop) {
                    continue;
                }
                prop = prop[pathSplitted[i]];
            }
            if (prop) {
                target = prop;
            }
        } else {
            target = el;
        }
        if (target == null) {
            throw new Error('Target ' + path + ' not exists');
        }
        var animators = this._animators;
        var animator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$Animator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](target, opts);
        var self = this;
        animator.during(function() {
            if (self.__zr) {
                self.__zr.refresh();
            }
        }).done(function() {
            var idx = animators.indexOf(animator);
            if (idx >= 0) {
                animators.splice(idx, 1);
            }
        });
        animators.push(animator);
        if (this.__zr) {
            this.__zr.animation.addAnimator(animator);
        }
        return animator;
    },
    stopAnimation: function(forwardToLast) {
        this._animators = this._animators || [];
        var animators = this._animators;
        var len = animators.length;
        for(var i = 0; i < len; i++){
            animators[i].stop(forwardToLast);
        }
        animators.length = 0;
        return this;
    },
    addAnimatorsToZr: function(zr) {
        if (this._animators) {
            for(var i = 0; i < this._animators.length; i++){
                zr.animation.addAnimator(this._animators[i]);
            }
        }
    },
    removeAnimatorsFromZr: function(zr) {
        if (this._animators) {
            for(var i = 0; i < this._animators.length; i++){
                zr.animation.removeAnimator(this._animators[i]);
            }
        }
    }
};
const __TURBOPACK__default__export__ = animatableMixin;
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/common.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "\n@export ecgl.common.transformUniforms\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n@end\n\n@export ecgl.common.attributes\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n@end\n\n@export ecgl.common.uv.header\nuniform vec2 uvRepeat : [1.0, 1.0];\nuniform vec2 uvOffset : [0.0, 0.0];\nuniform vec2 detailUvRepeat : [1.0, 1.0];\nuniform vec2 detailUvOffset : [0.0, 0.0];\n\nvarying vec2 v_Texcoord;\nvarying vec2 v_DetailTexcoord;\n@end\n\n@export ecgl.common.uv.main\nv_Texcoord = texcoord * uvRepeat + uvOffset;\nv_DetailTexcoord = texcoord * detailUvRepeat + detailUvOffset;\n@end\n\n@export ecgl.common.uv.fragmentHeader\nvarying vec2 v_Texcoord;\nvarying vec2 v_DetailTexcoord;\n@end\n\n\n@export ecgl.common.albedo.main\n\n vec4 albedoTexel = vec4(1.0);\n#ifdef DIFFUSEMAP_ENABLED\n albedoTexel = texture2D(diffuseMap, v_Texcoord);\n #ifdef SRGB_DECODE\n albedoTexel = sRGBToLinear(albedoTexel);\n #endif\n#endif\n\n#ifdef DETAILMAP_ENABLED\n vec4 detailTexel = texture2D(detailMap, v_DetailTexcoord);\n #ifdef SRGB_DECODE\n detailTexel = sRGBToLinear(detailTexel);\n #endif\n albedoTexel.rgb = mix(albedoTexel.rgb, detailTexel.rgb, detailTexel.a);\n albedoTexel.a = detailTexel.a + (1.0 - detailTexel.a) * albedoTexel.a;\n#endif\n\n@end\n\n@export ecgl.common.wireframe.vertexHeader\n\n#ifdef WIREFRAME_QUAD\nattribute vec4 barycentric;\nvarying vec4 v_Barycentric;\n#elif defined(WIREFRAME_TRIANGLE)\nattribute vec3 barycentric;\nvarying vec3 v_Barycentric;\n#endif\n\n@end\n\n@export ecgl.common.wireframe.vertexMain\n\n#if defined(WIREFRAME_QUAD) || defined(WIREFRAME_TRIANGLE)\n v_Barycentric = barycentric;\n#endif\n\n@end\n\n\n@export ecgl.common.wireframe.fragmentHeader\n\nuniform float wireframeLineWidth : 1;\nuniform vec4 wireframeLineColor: [0, 0, 0, 0.5];\n\n#ifdef WIREFRAME_QUAD\nvarying vec4 v_Barycentric;\nfloat edgeFactor () {\n vec4 d = fwidth(v_Barycentric);\n vec4 a4 = smoothstep(vec4(0.0), d * wireframeLineWidth, v_Barycentric);\n return min(min(min(a4.x, a4.y), a4.z), a4.w);\n}\n#elif defined(WIREFRAME_TRIANGLE)\nvarying vec3 v_Barycentric;\nfloat edgeFactor () {\n vec3 d = fwidth(v_Barycentric);\n vec3 a3 = smoothstep(vec3(0.0), d * wireframeLineWidth, v_Barycentric);\n return min(min(a3.x, a3.y), a3.z);\n}\n#endif\n\n@end\n\n\n@export ecgl.common.wireframe.fragmentMain\n\n#if defined(WIREFRAME_QUAD) || defined(WIREFRAME_TRIANGLE)\n if (wireframeLineWidth > 0.) {\n vec4 lineColor = wireframeLineColor;\n#ifdef SRGB_DECODE\n lineColor = sRGBToLinear(lineColor);\n#endif\n\n gl_FragColor.rgb = mix(gl_FragColor.rgb, lineColor.rgb, (1.0 - edgeFactor()) * lineColor.a);\n }\n#endif\n@end\n\n\n\n\n@export ecgl.common.bumpMap.header\n\n#ifdef BUMPMAP_ENABLED\nuniform sampler2D bumpMap;\nuniform float bumpScale : 1.0;\n\n\nvec3 bumpNormal(vec3 surfPos, vec3 surfNormal, vec3 baseNormal)\n{\n vec2 dSTdx = dFdx(v_Texcoord);\n vec2 dSTdy = dFdy(v_Texcoord);\n\n float Hll = bumpScale * texture2D(bumpMap, v_Texcoord).x;\n float dHx = bumpScale * texture2D(bumpMap, v_Texcoord + dSTdx).x - Hll;\n float dHy = bumpScale * texture2D(bumpMap, v_Texcoord + dSTdy).x - Hll;\n\n vec3 vSigmaX = dFdx(surfPos);\n vec3 vSigmaY = dFdy(surfPos);\n vec3 vN = surfNormal;\n\n vec3 R1 = cross(vSigmaY, vN);\n vec3 R2 = cross(vN, vSigmaX);\n\n float fDet = dot(vSigmaX, R1);\n\n vec3 vGrad = sign(fDet) * (dHx * R1 + dHy * R2);\n return normalize(abs(fDet) * baseNormal - vGrad);\n\n}\n#endif\n\n@end\n\n@export ecgl.common.normalMap.vertexHeader\n\n#ifdef NORMALMAP_ENABLED\nattribute vec4 tangent : TANGENT;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@end\n\n@export ecgl.common.normalMap.vertexMain\n\n#ifdef NORMALMAP_ENABLED\n if (dot(tangent, tangent) > 0.0) {\n v_Tangent = normalize((worldInverseTranspose * vec4(tangent.xyz, 0.0)).xyz);\n v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n }\n#endif\n\n@end\n\n\n@export ecgl.common.normalMap.fragmentHeader\n\n#ifdef NORMALMAP_ENABLED\nuniform sampler2D normalMap;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@end\n\n@export ecgl.common.normalMap.fragmentMain\n#ifdef NORMALMAP_ENABLED\n if (dot(v_Tangent, v_Tangent) > 0.0) {\n vec3 normalTexel = texture2D(normalMap, v_DetailTexcoord).xyz;\n if (dot(normalTexel, normalTexel) > 0.0) { N = normalTexel * 2.0 - 1.0;\n mat3 tbn = mat3(v_Tangent, v_Bitangent, v_Normal);\n N = normalize(tbn * N);\n }\n }\n#endif\n@end\n\n\n\n@export ecgl.common.vertexAnimation.header\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute vec3 prevNormal;\nuniform float percent;\n#endif\n\n@end\n\n@export ecgl.common.vertexAnimation.main\n\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n vec3 norm = mix(prevNormal, normal, percent);\n#else\n vec3 pos = position;\n vec3 norm = normal;\n#endif\n\n@end\n\n\n@export ecgl.common.ssaoMap.header\n#ifdef SSAOMAP_ENABLED\nuniform sampler2D ssaoMap;\nuniform vec4 viewport : VIEWPORT;\n#endif\n@end\n\n@export ecgl.common.ssaoMap.main\n float ao = 1.0;\n#ifdef SSAOMAP_ENABLED\n ao = texture2D(ssaoMap, (gl_FragCoord.xy - viewport.xy) / viewport.zw).r;\n#endif\n@end\n\n\n\n\n@export ecgl.common.diffuseLayer.header\n\n#if (LAYER_DIFFUSEMAP_COUNT > 0)\nuniform float layerDiffuseIntensity[LAYER_DIFFUSEMAP_COUNT];\nuniform sampler2D layerDiffuseMap[LAYER_DIFFUSEMAP_COUNT];\n#endif\n\n@end\n\n@export ecgl.common.emissiveLayer.header\n\n#if (LAYER_EMISSIVEMAP_COUNT > 0)\nuniform float layerEmissionIntensity[LAYER_EMISSIVEMAP_COUNT];\nuniform sampler2D layerEmissiveMap[LAYER_EMISSIVEMAP_COUNT];\n#endif\n\n@end\n\n@export ecgl.common.layers.header\n@import ecgl.common.diffuseLayer.header\n@import ecgl.common.emissiveLayer.header\n@end\n\n@export ecgl.common.diffuseLayer.main\n\n#if (LAYER_DIFFUSEMAP_COUNT > 0)\n for (int _idx_ = 0; _idx_ < LAYER_DIFFUSEMAP_COUNT; _idx_++) {{\n float intensity = layerDiffuseIntensity[_idx_];\n vec4 texel2 = texture2D(layerDiffuseMap[_idx_], v_Texcoord);\n #ifdef SRGB_DECODE\n texel2 = sRGBToLinear(texel2);\n #endif\n albedoTexel.rgb = mix(albedoTexel.rgb, texel2.rgb * intensity, texel2.a);\n albedoTexel.a = texel2.a + (1.0 - texel2.a) * albedoTexel.a;\n }}\n#endif\n\n@end\n\n@export ecgl.common.emissiveLayer.main\n\n#if (LAYER_EMISSIVEMAP_COUNT > 0)\n for (int _idx_ = 0; _idx_ < LAYER_EMISSIVEMAP_COUNT; _idx_++)\n {{\n vec4 texel2 = texture2D(layerEmissiveMap[_idx_], v_Texcoord) * layerEmissionIntensity[_idx_];\n #ifdef SRGB_DECODE\n texel2 = sRGBToLinear(texel2);\n #endif\n float intensity = layerEmissionIntensity[_idx_];\n gl_FragColor.rgb += texel2.rgb * texel2.a * intensity;\n }}\n#endif\n\n@end\n";
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/color.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.color.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\n@import ecgl.common.uv.header\n\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 position: POSITION;\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nuniform float percent : 1.0;\n#endif\n\n#ifdef ATMOSPHERE_ENABLED\nattribute vec3 normal: NORMAL;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nvarying vec3 v_Normal;\n#endif\n\nvoid main()\n{\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n#else\n vec3 pos = position;\n#endif\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n @import ecgl.common.uv.main\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n#ifdef ATMOSPHERE_ENABLED\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n\n}\n\n@end\n\n@export ecgl.color.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n\nuniform sampler2D diffuseMap;\nuniform sampler2D detailMap;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\nvarying vec3 v_Normal;\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n@import ecgl.common.layers.header\n\n@import ecgl.common.uv.fragmentHeader\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color);\n#else\n gl_FragColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n gl_FragColor *= albedoTexel;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/lambert.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "/**\n * http: */\n\n@export ecgl.lambert.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n\n@import ecgl.common.attributes\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.vertexAnimation.header\n\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n @import ecgl.common.uv.main\n\n @import ecgl.common.vertexAnimation.main\n\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n v_Normal = normalize((worldInverseTranspose * vec4(norm, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n}\n\n@end\n\n\n@export ecgl.lambert.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform sampler2D diffuseMap;\nuniform sampler2D detailMap;\n\n@import ecgl.common.layers.header\n\nuniform float emissionIntensity: 1.0;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\n#endif\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color);\n#else\n gl_FragColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n gl_FragColor *= sRGBToLinear(v_Color);\n #else\n gl_FragColor *= v_Color;\n #endif\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n gl_FragColor *= albedoTexel;\n\n vec3 N = v_Normal;\n#ifdef DOUBLE_SIDED\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int i = 0; i < AMBIENT_LIGHT_COUNT; i++)\n {\n diffuseColor += ambientLightColor[i] * ambientFactor * ao;\n }\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n diffuseColor += calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_] * ao;\n }}\n#endif\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++)\n {\n vec3 lightDirection = -directionalLightDirection[i];\n vec3 lightColor = directionalLightColor[i];\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[i];\n }\n#endif\n\n float ndl = dot(N, normalize(lightDirection)) * shadowContrib;\n\n diffuseColor += lightColor * clamp(ndl, 0.0, 1.0);\n }\n#endif\n\n gl_FragColor.rgb *= diffuseColor;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/realistic.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.realistic.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef NORMALMAP_ENABLED\nattribute vec4 tangent : TANGENT;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@import ecgl.common.vertexAnimation.header\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n\n @import ecgl.common.uv.main\n\n @import ecgl.common.vertexAnimation.main\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n v_Normal = normalize((worldInverseTranspose * vec4(norm, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n#ifdef NORMALMAP_ENABLED\n v_Tangent = normalize((worldInverseTranspose * vec4(tangent.xyz, 0.0)).xyz);\n v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n\n}\n\n@end\n\n\n\n@export ecgl.realistic.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n#define PI 3.14159265358979\n#define ROUGHNESS_CHANEL 0\n#define METALNESS_CHANEL 1\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform sampler2D diffuseMap;\n\nuniform sampler2D detailMap;\nuniform sampler2D metalnessMap;\nuniform sampler2D roughnessMap;\n\n@import ecgl.common.layers.header\n\nuniform float emissionIntensity: 1.0;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nuniform float metalness : 0.0;\nuniform float roughness : 0.5;\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\n#endif\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef AMBIENT_CUBEMAP_LIGHT_COUNT\n@import clay.header.ambient_cubemap_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n@import ecgl.common.normalMap.fragmentHeader\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import clay.util.rgbm\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nvec3 F_Schlick(float ndv, vec3 spec) {\n return spec + (1.0 - spec) * pow(1.0 - ndv, 5.0);\n}\n\nfloat D_Phong(float g, float ndh) {\n float a = pow(8192.0, g);\n return (a + 2.0) / 8.0 * pow(ndh, a);\n}\n\nvoid main()\n{\n vec4 albedoColor = color;\n\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n albedoColor *= sRGBToLinear(v_Color);\n #else\n albedoColor *= v_Color;\n #endif\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n albedoColor *= albedoTexel;\n\n float m = metalness;\n\n#ifdef METALNESSMAP_ENABLED\n float m2 = texture2D(metalnessMap, v_DetailTexcoord)[METALNESS_CHANEL];\n m = clamp(m2 + (m - 0.5) * 2.0, 0.0, 1.0);\n#endif\n\n vec3 baseColor = albedoColor.rgb;\n albedoColor.rgb = baseColor * (1.0 - m);\n vec3 specFactor = mix(vec3(0.04), baseColor, m);\n\n float g = 1.0 - roughness;\n\n#ifdef ROUGHNESSMAP_ENABLED\n float g2 = 1.0 - texture2D(roughnessMap, v_DetailTexcoord)[ROUGHNESS_CHANEL];\n g = clamp(g2 + (g - 0.5) * 2.0, 0.0, 1.0);\n#endif\n\n vec3 N = v_Normal;\n\n#ifdef DOUBLE_SIDED\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n@import ecgl.common.normalMap.fragmentMain\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n vec3 diffuseTerm = vec3(0.0);\n vec3 specularTerm = vec3(0.0);\n\n float ndv = clamp(dot(N, V), 0.0, 1.0);\n vec3 fresnelTerm = F_Schlick(ndv, specFactor);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_LIGHT_COUNT; _idx_++)\n {{\n diffuseTerm += ambientLightColor[_idx_] * ambientFactor * ao;\n }}\n#endif\n\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n diffuseTerm += calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_] * ao;\n }}\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int _idx_ = 0; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++)\n {{\n vec3 L = -directionalLightDirection[_idx_];\n vec3 lc = directionalLightColor[_idx_];\n\n vec3 H = normalize(L + V);\n float ndl = clamp(dot(N, normalize(L)), 0.0, 1.0);\n float ndh = clamp(dot(N, H), 0.0, 1.0);\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[_idx_];\n }\n#endif\n\n vec3 li = lc * ndl * shadowContrib;\n\n diffuseTerm += li;\n specularTerm += li * fresnelTerm * D_Phong(g, ndh);\n }}\n#endif\n\n\n#ifdef AMBIENT_CUBEMAP_LIGHT_COUNT\n vec3 L = reflect(-V, N);\n L = vec3(L.x, L[NORMAL_UP_AXIS], L[NORMAL_FRONT_AXIS]);\n float rough2 = clamp(1.0 - g, 0.0, 1.0);\n float bias2 = rough2 * 5.0;\n vec2 brdfParam2 = texture2D(ambientCubemapLightBRDFLookup[0], vec2(rough2, ndv)).xy;\n vec3 envWeight2 = specFactor * brdfParam2.x + brdfParam2.y;\n vec3 envTexel2;\n for(int _idx_ = 0; _idx_ < AMBIENT_CUBEMAP_LIGHT_COUNT; _idx_++)\n {{\n envTexel2 = RGBMDecode(textureCubeLodEXT(ambientCubemapLightCubemap[_idx_], L, bias2), 8.12);\n specularTerm += ambientCubemapLightColor[_idx_] * envTexel2 * envWeight2 * ao;\n }}\n#endif\n\n gl_FragColor.rgb = albedoColor.rgb * diffuseTerm + specularTerm;\n gl_FragColor.a = albedoColor.a;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n#ifdef SRGB_ENCODE\n gl_FragColor = linearTosRGB(gl_FragColor);\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/hatching.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.hatching.vertex\n\n@import ecgl.realistic.vertex\n\n@end\n\n\n@export ecgl.hatching.fragment\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform vec4 color : [0.0, 0.0, 0.0, 1.0];\nuniform vec4 paperColor : [1.0, 1.0, 1.0, 1.0];\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nuniform sampler2D hatch1;\nuniform sampler2D hatch2;\nuniform sampler2D hatch3;\nuniform sampler2D hatch4;\nuniform sampler2D hatch5;\nuniform sampler2D hatch6;\n\nfloat shade(in float tone) {\n vec4 c = vec4(1. ,1., 1., 1.);\n float step = 1. / 6.;\n vec2 uv = v_DetailTexcoord;\n if (tone <= step / 2.0) {\n c = mix(vec4(0.), texture2D(hatch6, uv), 12. * tone);\n }\n else if (tone <= step) {\n c = mix(texture2D(hatch6, uv), texture2D(hatch5, uv), 6. * tone);\n }\n if(tone > step && tone <= 2. * step){\n c = mix(texture2D(hatch5, uv), texture2D(hatch4, uv) , 6. * (tone - step));\n }\n if(tone > 2. * step && tone <= 3. * step){\n c = mix(texture2D(hatch4, uv), texture2D(hatch3, uv), 6. * (tone - 2. * step));\n }\n if(tone > 3. * step && tone <= 4. * step){\n c = mix(texture2D(hatch3, uv), texture2D(hatch2, uv), 6. * (tone - 3. * step));\n }\n if(tone > 4. * step && tone <= 5. * step){\n c = mix(texture2D(hatch2, uv), texture2D(hatch1, uv), 6. * (tone - 4. * step));\n }\n if(tone > 5. * step){\n c = mix(texture2D(hatch1, uv), vec4(1.), 6. * (tone - 5. * step));\n }\n\n return c.r;\n}\n\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n vec4 inkColor = sRGBToLinear(color);\n#else\n vec4 inkColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n inkColor *= sRGBToLinear(v_Color);\n #else\n inkColor *= v_Color;\n #endif\n#endif\n\n vec3 N = v_Normal;\n#ifdef DOUBLE_SIDED\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float tone = 0.0;\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int i = 0; i < AMBIENT_LIGHT_COUNT; i++)\n {\n tone += dot(ambientLightColor[i], w) * ambientFactor * ao;\n }\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n tone += dot(calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_], w) * ao;\n }}\n#endif\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++)\n {\n vec3 lightDirection = -directionalLightDirection[i];\n float lightTone = dot(directionalLightColor[i], w);\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[i];\n }\n#endif\n\n float ndl = dot(N, normalize(lightDirection)) * shadowContrib;\n\n tone += lightTone * clamp(ndl, 0.0, 1.0);\n }\n#endif\n\n gl_FragColor = mix(inkColor, paperColor, shade(clamp(tone, 0.0, 1.0)));\n }\n@end\n";
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/shadow.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.sm.depth.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nuniform float percent : 1.0;\n#endif\n\nvarying vec4 v_ViewPosition;\nvarying vec2 v_Texcoord;\n\nvoid main(){\n\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n#else\n vec3 pos = position;\n#endif\n\n v_ViewPosition = worldViewProjection * vec4(pos, 1.0);\n gl_Position = v_ViewPosition;\n\n v_Texcoord = texcoord;\n\n}\n@end\n\n\n\n@export ecgl.sm.depth.fragment\n\n@import clay.sm.depth.fragment\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Renderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/tool/color.js [app-client] (ecmascript) <export * as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Scene.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$LRU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/core/LRU.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/util/texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$EChartsSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/EChartsSurface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$AmbientCubemap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/AmbientCubemap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$AmbientSH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/AmbientSH.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$sh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/util/sh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Sphere$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/geometry/Sphere.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/geometry/Plane.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Cube$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/geometry/Cube.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Ambient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/Ambient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Directional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/Directional.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Spot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/light/Spot.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/camera/Perspective.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/camera/Orthographic.js [app-client] (ecmascript)"); // Math
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Quaternion.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix2d$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix2d.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Plane.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Ray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$BoundingBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/BoundingBox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Frustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Frustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$animatableMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/animatableMixin.js [app-client] (ecmascript)"); // Some common shaders
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$util$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/util.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$prez$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/prez.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$common$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/common.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$color$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/color.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lambert$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lambert.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$realistic$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/realistic.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$hatching$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/hatching.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$shadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/shadow.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$animatableMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$util$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$prez$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$common$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$color$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lambert$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$realistic$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$hatching$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$shadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function isValueNone(value) {
    return !value || value === 'none';
}
function isValueImage(value) {
    return value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof Image;
}
function isECharts(value) {
    return value.getZr && value.setOption;
} // Overwrite addToScene and removeFromScene
var oldAddToScene = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.addToScene;
var oldRemoveFromScene = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.removeFromScene;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.addToScene = function(node) {
    oldAddToScene.call(this, node);
    if (this.__zr) {
        var zr = this.__zr;
        node.traverse(function(child) {
            child.__zr = zr;
            if (child.addAnimatorsToZr) {
                child.addAnimatorsToZr(zr);
            }
        });
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.removeFromScene = function(node) {
    oldRemoveFromScene.call(this, node);
    node.traverse(function(child) {
        var zr = child.__zr;
        child.__zr = null;
        if (zr && child.removeAnimatorsFromZr) {
            child.removeAnimatorsFromZr(zr);
        }
    });
};
/**
 * @param {string} textureName
 * @param {string|HTMLImageElement|HTMLCanvasElement} imgValue
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [textureOpts]
 */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.setTextureImage = function(textureName, imgValue, api, textureOpts) {
    if (!this.shader) {
        return;
    }
    var zr = api.getZr();
    var material = this;
    var texture;
    material.autoUpdateTextureStatus = false; // disableTexture first
    material.disableTexture(textureName);
    if (!isValueNone(imgValue)) {
        texture = graphicGL.loadTexture(imgValue, api, textureOpts, function(texture) {
            material.enableTexture(textureName);
            zr && zr.refresh();
        }); // Set texture immediately for other code to verify if have this texture.
        material.set(textureName, texture);
    }
    return texture;
};
var graphicGL = {};
graphicGL.Renderer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Mesh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Shader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Material = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Texture2D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]; // Geometries
graphicGL.Geometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.SphereGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Sphere$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.PlaneGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.CubeGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Cube$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]; // Lights
graphicGL.AmbientLight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Ambient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.DirectionalLight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Directional$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.PointLight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.SpotLight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$Spot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]; // Cameras
graphicGL.PerspectiveCamera = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.OrthographicCamera = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]; // Math
graphicGL.Vector2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Vector3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Vector4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Quaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Quaternion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Matrix2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Matrix2d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix2d$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Matrix3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Matrix4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Plane = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Ray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Ray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.BoundingBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$BoundingBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
graphicGL.Frustum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Frustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]; // Texture utilities
var blankImage = null;
function getBlankImage() {
    if (blankImage !== null) {
        return blankImage;
    }
    blankImage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlank('rgba(255,255,255,0)').image;
    return blankImage;
}
function nearestPowerOfTwo(val) {
    return Math.pow(2, Math.round(Math.log(val) / Math.LN2));
}
function convertTextureToPowerOfTwo(texture) {
    if ((texture.wrapS === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPEAT || texture.wrapT === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPEAT) && texture.image) {
        // var canvas = document.createElement('canvas');
        var width = nearestPowerOfTwo(texture.width);
        var height = nearestPowerOfTwo(texture.height);
        if (width !== texture.width || height !== texture.height) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(texture.image, 0, 0, width, height);
            texture.image = canvas;
        }
    }
}
/**
 * @param {string|HTMLImageElement|HTMLCanvasElement} imgValue
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [textureOpts]
 * @param {Function} cb
 */ // TODO Promise, test
graphicGL.loadTexture = function(imgValue, api, textureOpts, cb) {
    if (typeof textureOpts === 'function') {
        cb = textureOpts;
        textureOpts = {};
    }
    textureOpts = textureOpts || {};
    var keys = Object.keys(textureOpts).sort();
    var prefix = '';
    for(var i = 0; i < keys.length; i++){
        prefix += keys[i] + '_' + textureOpts[keys[i]] + '_';
    }
    var textureCache = api.__textureCache = api.__textureCache || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$LRU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](20);
    if (isECharts(imgValue)) {
        var id = imgValue.__textureid__;
        var textureObj = textureCache.get(prefix + id);
        if (!textureObj) {
            var surface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$EChartsSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](imgValue);
            surface.onupdate = function() {
                api.getZr().refresh();
            };
            textureObj = {
                texture: surface.getTexture()
            };
            for(var i = 0; i < keys.length; i++){
                textureObj.texture[keys[i]] = textureOpts[keys[i]];
            }
            id = imgValue.__textureid__ || '__ecgl_ec__' + textureObj.texture.__uid__;
            imgValue.__textureid__ = id;
            textureCache.put(prefix + id, textureObj);
            cb && cb(textureObj.texture);
        } else {
            textureObj.texture.surface.setECharts(imgValue);
            cb && cb(textureObj.texture);
        }
        return textureObj.texture;
    } else if (isValueImage(imgValue)) {
        var id = imgValue.__textureid__;
        var textureObj = textureCache.get(prefix + id);
        if (!textureObj) {
            textureObj = {
                texture: new graphicGL.Texture2D({
                    image: imgValue
                })
            };
            for(var i = 0; i < keys.length; i++){
                textureObj.texture[keys[i]] = textureOpts[keys[i]];
            }
            id = imgValue.__textureid__ || '__ecgl_image__' + textureObj.texture.__uid__;
            imgValue.__textureid__ = id;
            textureCache.put(prefix + id, textureObj);
            convertTextureToPowerOfTwo(textureObj.texture); // TODO Next tick?
            cb && cb(textureObj.texture);
        }
        return textureObj.texture;
    } else {
        var textureObj = textureCache.get(prefix + imgValue);
        if (textureObj) {
            if (textureObj.callbacks) {
                // Add to pending callbacks
                textureObj.callbacks.push(cb);
            } else {
                // TODO Next tick?
                cb && cb(textureObj.texture);
            }
        } else {
            // Maybe base64
            if (imgValue.match(/.hdr$|^data:application\/octet-stream/)) {
                textureObj = {
                    callbacks: [
                        cb
                    ]
                };
                var texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadTexture(imgValue, {
                    exposure: textureOpts.exposure,
                    fileType: 'hdr'
                }, function() {
                    texture.dirty();
                    textureObj.callbacks.forEach(function(cb) {
                        cb && cb(texture);
                    });
                    textureObj.callbacks = null;
                });
                textureObj.texture = texture;
                textureCache.put(prefix + imgValue, textureObj);
            } else {
                var texture = new graphicGL.Texture2D({
                    image: new Image()
                });
                for(var i = 0; i < keys.length; i++){
                    texture[keys[i]] = textureOpts[keys[i]];
                }
                textureObj = {
                    texture: texture,
                    callbacks: [
                        cb
                    ]
                };
                var originalImage = texture.image;
                originalImage.onload = function() {
                    texture.image = originalImage;
                    convertTextureToPowerOfTwo(texture);
                    texture.dirty();
                    textureObj.callbacks.forEach(function(cb) {
                        cb && cb(texture);
                    });
                    textureObj.callbacks = null;
                };
                originalImage.crossOrigin = 'Anonymous';
                originalImage.src = imgValue; // Use blank image as place holder.
                texture.image = getBlankImage();
                textureCache.put(prefix + imgValue, textureObj);
            }
        }
        return textureObj.texture;
    }
};
/**
 * Create ambientCubemap and ambientSH light. respectively to have specular and diffuse light
 * @return {Object} { specular, diffuse }
 */ graphicGL.createAmbientCubemap = function(opt, renderer, api, cb) {
    opt = opt || {};
    var textureUrl = opt.texture;
    var exposure = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(opt.exposure, 1.0);
    var ambientCubemap = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$AmbientCubemap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        intensity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(opt.specularIntensity, 1.0)
    });
    var ambientSH = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$light$2f$AmbientSH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        intensity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(opt.diffuseIntensity, 1.0),
        coefficients: [
            0.844,
            0.712,
            0.691,
            -0.037,
            0.083,
            0.167,
            0.343,
            0.288,
            0.299,
            -0.041,
            -0.021,
            -0.009,
            -0.003,
            -0.041,
            -0.064,
            -0.011,
            -0.007,
            -0.004,
            -0.031,
            0.034,
            0.081,
            -0.060,
            -0.049,
            -0.060,
            0.046,
            0.056,
            0.050
        ]
    });
    ambientCubemap.cubemap = graphicGL.loadTexture(textureUrl, api, {
        exposure: exposure
    }, function() {
        // TODO Performance when multiple view
        ambientCubemap.cubemap.flipY = false;
        if ("TURBOPACK compile-time truthy", 1) {
            var time = Date.now();
        }
        ambientCubemap.prefilter(renderer, 32);
        if ("TURBOPACK compile-time truthy", 1) {
            var dTime = Date.now() - time;
            console.log('Prefilter environment map: ' + dTime + 'ms');
        }
        ambientSH.coefficients = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$sh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].projectEnvironmentMap(renderer, ambientCubemap.cubemap, {
            lod: 1
        });
        cb && cb(); // TODO Refresh ?
    });
    return {
        specular: ambientCubemap,
        diffuse: ambientSH
    };
};
/**
 * Create a blank texture for placeholder
 */ graphicGL.createBlankTexture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlank;
/**
 * If value is image
 * @param {*}
 * @return {boolean}
 */ graphicGL.isImage = isValueImage;
graphicGL.additiveBlend = function(gl) {
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
};
/**
 * @param {string|Array.<number>} colorStr
 * @param {Array.<number>} [rgba]
 * @return {Array.<number>} rgba
 */ graphicGL.parseColor = function(colorStr, rgba) {
    if (colorStr instanceof Array) {
        if (!rgba) {
            rgba = [];
        } // Color has been parsed.
        rgba[0] = colorStr[0];
        rgba[1] = colorStr[1];
        rgba[2] = colorStr[2];
        if (colorStr.length > 3) {
            rgba[3] = colorStr[3];
        } else {
            rgba[3] = 1;
        }
        return rgba;
    }
    rgba = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__["color"].parse(colorStr || '#000', rgba) || [
        0,
        0,
        0,
        0
    ];
    rgba[0] /= 255;
    rgba[1] /= 255;
    rgba[2] /= 255;
    return rgba;
};
/**
 * Convert alpha beta rotation to direction.
 * @param {number} alpha
 * @param {number} beta
 * @return {Array.<number>}
 */ graphicGL.directionFromAlphaBeta = function(alpha, beta) {
    var theta = alpha / 180 * Math.PI + Math.PI / 2;
    var phi = -beta / 180 * Math.PI + Math.PI / 2;
    var dir = [];
    var r = Math.sin(theta);
    dir[0] = r * Math.cos(phi);
    dir[1] = -Math.cos(theta);
    dir[2] = r * Math.sin(phi);
    return dir;
};
/**
 * Get shadow resolution from shadowQuality configuration
 */ graphicGL.getShadowResolution = function(shadowQuality) {
    var shadowResolution = 1024;
    switch(shadowQuality){
        case 'low':
            shadowResolution = 512;
            break;
        case 'medium':
            break;
        case 'high':
            shadowResolution = 2048;
            break;
        case 'ultra':
            shadowResolution = 4096;
            break;
    }
    return shadowResolution;
};
/**
 * Shading utilities
 */ graphicGL.COMMON_SHADERS = [
    'lambert',
    'color',
    'realistic',
    'hatching',
    'shadow'
];
/**
 * Create shader including vertex and fragment
 * @param {string} prefix.
 */ graphicGL.createShader = function(prefix) {
    if (prefix === 'ecgl.shadow') {
        prefix = 'ecgl.displayShadow';
    }
    var vertexShaderStr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source(prefix + '.vertex');
    var fragmentShaderStr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source(prefix + '.fragment');
    if (!vertexShaderStr) {
        console.error('Vertex shader of \'%s\' not exits', prefix);
    }
    if (!fragmentShaderStr) {
        console.error('Fragment shader of \'%s\' not exits', prefix);
    }
    var shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](vertexShaderStr, fragmentShaderStr);
    shader.name = prefix;
    return shader;
};
graphicGL.createMaterial = function(prefix, defines) {
    if (!(defines instanceof Array)) {
        defines = [
            defines
        ];
    }
    var shader = graphicGL.createShader(prefix);
    var material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        shader: shader
    });
    defines.forEach(function(defineName) {
        if (typeof defineName === 'string') {
            material.define(defineName);
        }
    });
    return material;
};
/**
 * Set material from model.
 * @param {clay.Material} material
 * @param {module:echarts/model/Model} model
 * @param {module:echarts/ExtensionAPI} api
 */ graphicGL.setMaterialFromModel = function(shading, material, model, api) {
    material.autoUpdateTextureStatus = false;
    var materialModel = model.getModel(shading + 'Material');
    var detailTexture = materialModel.get('detailTexture');
    var uvRepeat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(materialModel.get('textureTiling'), 1.0);
    var uvOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(materialModel.get('textureOffset'), 0.0);
    if (typeof uvRepeat === 'number') {
        uvRepeat = [
            uvRepeat,
            uvRepeat
        ];
    }
    if (typeof uvOffset === 'number') {
        uvOffset = [
            uvOffset,
            uvOffset
        ];
    }
    var repeatParam = uvRepeat[0] > 1 || uvRepeat[1] > 1 ? graphicGL.Texture.REPEAT : graphicGL.Texture.CLAMP_TO_EDGE;
    var textureOpt = {
        anisotropic: 8,
        wrapS: repeatParam,
        wrapT: repeatParam
    };
    if (shading === 'realistic') {
        var roughness = materialModel.get('roughness');
        var metalness = materialModel.get('metalness');
        if (metalness != null) {
            // Try to treat as a texture, TODO More check
            if (isNaN(metalness)) {
                material.setTextureImage('metalnessMap', metalness, api, textureOpt);
                metalness = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(materialModel.get('metalnessAdjust'), 0.5);
            }
        } else {
            // Default metalness.
            metalness = 0;
        }
        if (roughness != null) {
            // Try to treat as a texture, TODO More check
            if (isNaN(roughness)) {
                material.setTextureImage('roughnessMap', roughness, api, textureOpt);
                roughness = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(materialModel.get('roughnessAdjust'), 0.5);
            }
        } else {
            // Default roughness.
            roughness = 0.5;
        }
        var normalTextureVal = materialModel.get('normalTexture');
        material.setTextureImage('detailMap', detailTexture, api, textureOpt);
        material.setTextureImage('normalMap', normalTextureVal, api, textureOpt);
        material.set({
            roughness: roughness,
            metalness: metalness,
            detailUvRepeat: uvRepeat,
            detailUvOffset: uvOffset
        }); // var normalTexture = material.get('normalMap');
    // if (normalTexture) {
    // PENDING
    // normalTexture.format = Texture.SRGB;
    // }
    } else if (shading === 'lambert') {
        material.setTextureImage('detailMap', detailTexture, api, textureOpt);
        material.set({
            detailUvRepeat: uvRepeat,
            detailUvOffset: uvOffset
        });
    } else if (shading === 'color') {
        material.setTextureImage('detailMap', detailTexture, api, textureOpt);
        material.set({
            detailUvRepeat: uvRepeat,
            detailUvOffset: uvOffset
        });
    } else if (shading === 'hatching') {
        var tams = materialModel.get('hatchingTextures') || [];
        if (tams.length < 6) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.error('Invalid hatchingTextures.');
            }
        }
        for(var i = 0; i < 6; i++){
            material.setTextureImage('hatch' + (i + 1), tams[i], api, {
                anisotropic: 8,
                wrapS: graphicGL.Texture.REPEAT,
                wrapT: graphicGL.Texture.REPEAT
            });
        }
        material.set({
            detailUvRepeat: uvRepeat,
            detailUvOffset: uvOffset
        });
    }
};
graphicGL.updateVertexAnimation = function(mappingAttributes, previousMesh, currentMesh, seriesModel) {
    var enableAnimation = seriesModel.get('animation');
    var duration = seriesModel.get('animationDurationUpdate');
    var easing = seriesModel.get('animationEasingUpdate');
    var shadowDepthMaterial = currentMesh.shadowDepthMaterial;
    if (enableAnimation && previousMesh && duration > 0 // Only animate when bar count are not changed
     && previousMesh.geometry.vertexCount === currentMesh.geometry.vertexCount) {
        currentMesh.material.define('vertex', 'VERTEX_ANIMATION');
        currentMesh.ignorePreZ = true;
        if (shadowDepthMaterial) {
            shadowDepthMaterial.define('vertex', 'VERTEX_ANIMATION');
        }
        for(var i = 0; i < mappingAttributes.length; i++){
            currentMesh.geometry.attributes[mappingAttributes[i][0]].value = previousMesh.geometry.attributes[mappingAttributes[i][1]].value;
        }
        currentMesh.geometry.dirty();
        currentMesh.__percent = 0;
        currentMesh.material.set('percent', 0);
        currentMesh.stopAnimation();
        currentMesh.animate().when(duration, {
            __percent: 1
        }).during(function() {
            currentMesh.material.set('percent', currentMesh.__percent);
            if (shadowDepthMaterial) {
                shadowDepthMaterial.set('percent', currentMesh.__percent);
            }
        }).done(function() {
            currentMesh.ignorePreZ = false;
            currentMesh.material.undefine('vertex', 'VERTEX_ANIMATION');
            if (shadowDepthMaterial) {
                shadowDepthMaterial.undefine('vertex', 'VERTEX_ANIMATION');
            }
        }).start(easing);
    } else {
        currentMesh.material.undefine('vertex', 'VERTEX_ANIMATION');
        if (shadowDepthMaterial) {
            shadowDepthMaterial.undefine('vertex', 'VERTEX_ANIMATION');
        }
    }
};
const __TURBOPACK__default__export__ = graphicGL;
}}),
"[project]/node_modules/echarts-gl/lib/core/LayerGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Provide WebGL layer to zrender. Which is rendered on top of clay.
 *
 *
 * Relationship between zrender, LayerGL(renderer) and ViewGL(Scene, Camera, Viewport)
 *           zrender
 *           /     \
 *      LayerGL   LayerGL
 *    (renderer) (renderer)
 *      /     \
 *  ViewGL   ViewGL
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Renderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$picking$2f$RayPicking$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/picking/RayPicking.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)"); // PENDING, clay. notifier is same with zrender Eventful
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$mixin$2f$notifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/core/mixin/notifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$requestAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/animation/requestAnimationFrame.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * @constructor
 * @alias module:echarts-gl/core/LayerGL
 * @param {string} id Layer ID
 * @param {module:zrender/ZRender} zr
 */ var LayerGL = function(id, zr) {
    /**
   * Layer ID
   * @type {string}
   */ this.id = id;
    /**
   * @type {module:zrender/ZRender}
   */ this.zr = zr;
    /**
   * @type {clay.Renderer}
   */ try {
        this.renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            clearBit: 0,
            devicePixelRatio: zr.painter.dpr,
            preserveDrawingBuffer: true,
            // PENDING
            premultipliedAlpha: true
        });
        this.renderer.resize(zr.painter.getWidth(), zr.painter.getHeight());
    } catch (e) {
        this.renderer = null;
        this.dom = document.createElement('div');
        this.dom.style.cssText = 'position:absolute; left: 0; top: 0; right: 0; bottom: 0;';
        this.dom.className = 'ecgl-nowebgl';
        this.dom.innerHTML = 'Sorry, your browser does not support WebGL';
        console.error(e);
        return;
    }
    this.onglobalout = this.onglobalout.bind(this);
    zr.on('globalout', this.onglobalout);
    /**
   * Canvas dom for webgl rendering
   * @type {HTMLCanvasElement}
   */ this.dom = this.renderer.canvas;
    var style = this.dom.style;
    style.position = 'absolute';
    style.left = '0';
    style.top = '0';
    /**
   * @type {Array.<clay.Scene>}
   */ this.views = [];
    this._picking = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$picking$2f$RayPicking$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        renderer: this.renderer
    });
    this._viewsToDispose = [];
    /**
   * Current accumulating id.
   */ this._accumulatingId = 0;
    this._zrEventProxy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Rect({
        shape: {
            x: -1,
            y: -1,
            width: 2,
            height: 2
        },
        // FIXME Better solution.
        __isGLToZRProxy: true
    });
    this._backgroundColor = null;
    this._disposed = false;
};
LayerGL.prototype.setUnpainted = function() {};
/**
 * @param {module:echarts-gl/core/ViewGL} view
 */ LayerGL.prototype.addView = function(view) {
    if (view.layer === this) {
        return;
    } // If needs to dispose in this layer. unmark it.
    var idx = this._viewsToDispose.indexOf(view);
    if (idx >= 0) {
        this._viewsToDispose.splice(idx, 1);
    }
    this.views.push(view);
    view.layer = this;
    var zr = this.zr;
    view.scene.traverse(function(node) {
        node.__zr = zr;
        if (node.addAnimatorsToZr) {
            node.addAnimatorsToZr(zr);
        }
    });
};
function removeFromZr(node) {
    var zr = node.__zr;
    node.__zr = null;
    if (zr && node.removeAnimatorsFromZr) {
        node.removeAnimatorsFromZr(zr);
    }
}
/**
 * @param {module:echarts-gl/core/ViewGL} view
 */ LayerGL.prototype.removeView = function(view) {
    if (view.layer !== this) {
        return;
    }
    var idx = this.views.indexOf(view);
    if (idx >= 0) {
        this.views.splice(idx, 1);
        view.scene.traverse(removeFromZr, this);
        view.layer = null; // Mark to dispose in this layer.
        this._viewsToDispose.push(view);
    }
};
/**
 * Remove all views
 */ LayerGL.prototype.removeViewsAll = function() {
    this.views.forEach(function(view) {
        view.scene.traverse(removeFromZr, this);
        view.layer = null; // Mark to dispose in this layer.
        this._viewsToDispose.push(view);
    }, this);
    this.views.length = 0;
};
/**
 * Resize the canvas and viewport, will be invoked by zrender
 * @param  {number} width
 * @param  {number} height
 */ LayerGL.prototype.resize = function(width, height) {
    var renderer = this.renderer;
    renderer.resize(width, height);
};
/**
 * Clear color and depth
 * @return {[type]} [description]
 */ LayerGL.prototype.clear = function() {
    var gl = this.renderer.gl;
    var clearColor = this._backgroundColor || [
        0,
        0,
        0,
        0
    ];
    gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    gl.depthMask(true);
    gl.colorMask(true, true, true, true);
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
};
/**
 * Clear depth
 */ LayerGL.prototype.clearDepth = function() {
    var gl = this.renderer.gl;
    gl.clear(gl.DEPTH_BUFFER_BIT);
};
/**
 * Clear color
 */ LayerGL.prototype.clearColor = function() {
    var gl = this.renderer.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};
/**
 * Mark layer to refresh next tick
 */ LayerGL.prototype.needsRefresh = function() {
    this.zr.refresh();
};
/**
 * Refresh the layer, will be invoked by zrender
 */ LayerGL.prototype.refresh = function(bgColor) {
    this._backgroundColor = bgColor ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(bgColor) : [
        0,
        0,
        0,
        0
    ];
    this.renderer.clearColor = this._backgroundColor;
    for(var i = 0; i < this.views.length; i++){
        this.views[i].prepareRender(this.renderer);
    }
    this._doRender(false); // Auto dispose unused resources on GPU, like program(shader), texture, geometry(buffers)
    this._trackAndClean(); // Dispose trashed views
    for(var i = 0; i < this._viewsToDispose.length; i++){
        this._viewsToDispose[i].dispose(this.renderer);
    }
    this._viewsToDispose.length = 0;
    this._startAccumulating();
};
LayerGL.prototype.renderToCanvas = function(ctx) {
    // PENDING will block the page
    this._startAccumulating(true);
    ctx.drawImage(this.dom, 0, 0, ctx.canvas.width, ctx.canvas.height);
};
LayerGL.prototype._doRender = function(accumulating) {
    this.clear();
    this.renderer.saveViewport();
    for(var i = 0; i < this.views.length; i++){
        this.views[i].render(this.renderer, accumulating);
    }
    this.renderer.restoreViewport();
};
/**
 * Stop accumulating
 */ LayerGL.prototype._stopAccumulating = function() {
    this._accumulatingId = 0;
    clearTimeout(this._accumulatingTimeout);
};
var accumulatingId = 1;
/**
 * Start accumulating all the views.
 * Accumulating is for antialising and have more sampling in SSAO
 * @private
 */ LayerGL.prototype._startAccumulating = function(immediate) {
    var self = this;
    this._stopAccumulating();
    var needsAccumulate = false;
    for(var i = 0; i < this.views.length; i++){
        needsAccumulate = this.views[i].needsAccumulate() || needsAccumulate;
    }
    if (!needsAccumulate) {
        return;
    }
    function accumulate(id) {
        if (!self._accumulatingId || id !== self._accumulatingId) {
            return;
        }
        var isFinished = true;
        for(var i = 0; i < self.views.length; i++){
            isFinished = self.views[i].isAccumulateFinished() && needsAccumulate;
        }
        if (!isFinished) {
            self._doRender(true);
            if (immediate) {
                accumulate(id);
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$requestAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(function() {
                    accumulate(id);
                });
            }
        }
    }
    this._accumulatingId = accumulatingId++;
    if (immediate) {
        accumulate(self._accumulatingId);
    } else {
        this._accumulatingTimeout = setTimeout(function() {
            accumulate(self._accumulatingId);
        }, 50);
    }
};
LayerGL.prototype._trackAndClean = function() {
    var textureList = [];
    var geometriesList = []; // Mark all resources unused;
    if (this._textureList) {
        markUnused(this._textureList);
        markUnused(this._geometriesList);
    }
    for(var i = 0; i < this.views.length; i++){
        collectResources(this.views[i].scene, textureList, geometriesList);
    } // Dispose those unsed resources.
    if (this._textureList) {
        checkAndDispose(this.renderer, this._textureList);
        checkAndDispose(this.renderer, this._geometriesList);
    }
    this._textureList = textureList;
    this._geometriesList = geometriesList;
};
function markUnused(resourceList) {
    for(var i = 0; i < resourceList.length; i++){
        resourceList[i].__used__ = 0;
    }
}
function checkAndDispose(renderer, resourceList) {
    for(var i = 0; i < resourceList.length; i++){
        if (!resourceList[i].__used__) {
            resourceList[i].dispose(renderer);
        }
    }
}
function updateUsed(resource, list) {
    resource.__used__ = resource.__used__ || 0;
    resource.__used__++;
    if (resource.__used__ === 1) {
        // Don't push to the list twice.
        list.push(resource);
    }
}
function collectResources(scene, textureResourceList, geometryResourceList) {
    var prevMaterial;
    var prevGeometry;
    scene.traverse(function(renderable) {
        if (renderable.isRenderable()) {
            var geometry = renderable.geometry;
            var material = renderable.material; // TODO optimize!!
            if (material !== prevMaterial) {
                var textureUniforms = material.getTextureUniforms();
                for(var u = 0; u < textureUniforms.length; u++){
                    var uniformName = textureUniforms[u];
                    var val = material.uniforms[uniformName].value;
                    if (!val) {
                        continue;
                    }
                    if (val instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
                        updateUsed(val, textureResourceList);
                    } else if (val instanceof Array) {
                        for(var k = 0; k < val.length; k++){
                            if (val[k] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
                                updateUsed(val[k], textureResourceList);
                            }
                        }
                    }
                }
            }
            if (geometry !== prevGeometry) {
                updateUsed(geometry, geometryResourceList);
            }
            prevMaterial = material;
            prevGeometry = geometry;
        }
    });
    for(var k = 0; k < scene.lights.length; k++){
        // Track AmbientCubemap
        if (scene.lights[k].cubemap) {
            updateUsed(scene.lights[k].cubemap, textureResourceList);
        }
    }
}
/**
 * Dispose the layer
 */ LayerGL.prototype.dispose = function() {
    if (this._disposed) {
        return;
    }
    this._stopAccumulating();
    if (this._textureList) {
        markUnused(this._textureList);
        markUnused(this._geometriesList);
        checkAndDispose(this.renderer, this._textureList);
        checkAndDispose(this.renderer, this._geometriesList);
    }
    this.zr.off('globalout', this.onglobalout);
    this._disposed = true;
}; // Event handlers
LayerGL.prototype.onmousedown = function(e) {
    if (e.target && e.target.__isGLToZRProxy) {
        return;
    }
    e = e.event;
    var obj = this.pickObject(e.offsetX, e.offsetY);
    if (obj) {
        this._dispatchEvent('mousedown', e, obj);
        this._dispatchDataEvent('mousedown', e, obj);
    }
    this._downX = e.offsetX;
    this._downY = e.offsetY;
};
LayerGL.prototype.onmousemove = function(e) {
    if (e.target && e.target.__isGLToZRProxy) {
        return;
    }
    e = e.event;
    var obj = this.pickObject(e.offsetX, e.offsetY);
    var target = obj && obj.target;
    var lastHovered = this._hovered;
    this._hovered = obj;
    if (lastHovered && target !== lastHovered.target) {
        lastHovered.relatedTarget = target;
        this._dispatchEvent('mouseout', e, lastHovered); // this._dispatchDataEvent('mouseout', e, lastHovered);
        this.zr.setCursorStyle('default');
    }
    this._dispatchEvent('mousemove', e, obj);
    if (obj) {
        this.zr.setCursorStyle('pointer');
        if (!lastHovered || target !== lastHovered.target) {
            this._dispatchEvent('mouseover', e, obj); // this._dispatchDataEvent('mouseover', e, obj);
        }
    }
    this._dispatchDataEvent('mousemove', e, obj);
};
LayerGL.prototype.onmouseup = function(e) {
    if (e.target && e.target.__isGLToZRProxy) {
        return;
    }
    e = e.event;
    var obj = this.pickObject(e.offsetX, e.offsetY);
    if (obj) {
        this._dispatchEvent('mouseup', e, obj);
        this._dispatchDataEvent('mouseup', e, obj);
    }
    this._upX = e.offsetX;
    this._upY = e.offsetY;
};
LayerGL.prototype.onclick = LayerGL.prototype.dblclick = function(e) {
    if (e.target && e.target.__isGLToZRProxy) {
        return;
    } // Ignore click event if mouse moved
    var dx = this._upX - this._downX;
    var dy = this._upY - this._downY;
    if (Math.sqrt(dx * dx + dy * dy) > 20) {
        return;
    }
    e = e.event;
    var obj = this.pickObject(e.offsetX, e.offsetY);
    if (obj) {
        this._dispatchEvent(e.type, e, obj);
        this._dispatchDataEvent(e.type, e, obj);
    } // Try set depth of field onclick
    var result = this._clickToSetFocusPoint(e);
    if (result) {
        var success = result.view.setDOFFocusOnPoint(result.distance);
        if (success) {
            this.zr.refresh();
        }
    }
};
LayerGL.prototype._clickToSetFocusPoint = function(e) {
    var renderer = this.renderer;
    var oldViewport = renderer.viewport;
    for(var i = this.views.length - 1; i >= 0; i--){
        var viewGL = this.views[i];
        if (viewGL.hasDOF() && viewGL.containPoint(e.offsetX, e.offsetY)) {
            this._picking.scene = viewGL.scene;
            this._picking.camera = viewGL.camera; // Only used for picking, renderer.setViewport will also invoke gl.viewport.
            // Set directly, PENDING.
            renderer.viewport = viewGL.viewport;
            var result = this._picking.pick(e.offsetX, e.offsetY, true);
            if (result) {
                result.view = viewGL;
                return result;
            }
        }
    }
    renderer.viewport = oldViewport;
};
LayerGL.prototype.onglobalout = function(e) {
    var lastHovered = this._hovered;
    if (lastHovered) {
        this._dispatchEvent('mouseout', e, {
            target: lastHovered.target
        });
    }
};
LayerGL.prototype.pickObject = function(x, y) {
    var output = [];
    var renderer = this.renderer;
    var oldViewport = renderer.viewport;
    for(var i = 0; i < this.views.length; i++){
        var viewGL = this.views[i];
        if (viewGL.containPoint(x, y)) {
            this._picking.scene = viewGL.scene;
            this._picking.camera = viewGL.camera; // Only used for picking, renderer.setViewport will also invoke gl.viewport.
            // Set directly, PENDING.
            renderer.viewport = viewGL.viewport;
            this._picking.pickAll(x, y, output);
        }
    }
    renderer.viewport = oldViewport;
    output.sort(function(a, b) {
        return a.distance - b.distance;
    });
    return output[0];
};
LayerGL.prototype._dispatchEvent = function(eveName, originalEvent, newEvent) {
    if (!newEvent) {
        newEvent = {};
    }
    var current = newEvent.target;
    newEvent.cancelBubble = false;
    newEvent.event = originalEvent;
    newEvent.type = eveName;
    newEvent.offsetX = originalEvent.offsetX;
    newEvent.offsetY = originalEvent.offsetY;
    while(current){
        current.trigger(eveName, newEvent);
        current = current.getParent();
        if (newEvent.cancelBubble) {
            break;
        }
    }
    this._dispatchToView(eveName, newEvent);
};
LayerGL.prototype._dispatchDataEvent = function(eveName, originalEvent, newEvent) {
    var mesh = newEvent && newEvent.target;
    var dataIndex = mesh && mesh.dataIndex;
    var seriesIndex = mesh && mesh.seriesIndex; // Custom event data
    var eventData = mesh && mesh.eventData;
    var elChangedInMouseMove = false;
    var eventProxy = this._zrEventProxy;
    eventProxy.x = originalEvent.offsetX;
    eventProxy.y = originalEvent.offsetY;
    eventProxy.update();
    var targetInfo = {
        target: eventProxy
    };
    const ecData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].getECData(eventProxy);
    if (eveName === 'mousemove') {
        if (dataIndex != null) {
            if (dataIndex !== this._lastDataIndex) {
                if (parseInt(this._lastDataIndex, 10) >= 0) {
                    ecData.dataIndex = this._lastDataIndex;
                    ecData.seriesIndex = this._lastSeriesIndex; // FIXME May cause double events.
                    this.zr.handler.dispatchToElement(targetInfo, 'mouseout', originalEvent);
                }
                elChangedInMouseMove = true;
            }
        } else if (eventData != null) {
            if (eventData !== this._lastEventData) {
                if (this._lastEventData != null) {
                    ecData.eventData = this._lastEventData; // FIXME May cause double events.
                    this.zr.handler.dispatchToElement(targetInfo, 'mouseout', originalEvent);
                }
                elChangedInMouseMove = true;
            }
        }
        this._lastEventData = eventData;
        this._lastDataIndex = dataIndex;
        this._lastSeriesIndex = seriesIndex;
    }
    ecData.eventData = eventData;
    ecData.dataIndex = dataIndex;
    ecData.seriesIndex = seriesIndex;
    if (eventData != null || parseInt(dataIndex, 10) >= 0 && parseInt(seriesIndex, 10) >= 0) {
        this.zr.handler.dispatchToElement(targetInfo, eveName, originalEvent);
        if (elChangedInMouseMove) {
            this.zr.handler.dispatchToElement(targetInfo, 'mouseover', originalEvent);
        }
    }
};
LayerGL.prototype._dispatchToView = function(eventName, e) {
    for(var i = 0; i < this.views.length; i++){
        if (this.views[i].containPoint(e.offsetX, e.offsetY)) {
            this.views[i].trigger(eventName, e);
        }
    }
};
Object.assign(LayerGL.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$mixin$2f$notifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = LayerGL;
}}),
"[project]/node_modules/echarts-gl/lib/preprocessor/backwardCompat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
;
var GL_SERIES = [
    'bar3D',
    'line3D',
    'map3D',
    'scatter3D',
    'surface',
    'lines3D',
    'scatterGL',
    'scatter3D'
];
function convertNormalEmphasis(option, optType) {
    if (option && option[optType] && (option[optType].normal || option[optType].emphasis)) {
        var normalOpt = option[optType].normal;
        var emphasisOpt = option[optType].emphasis;
        if (normalOpt) {
            option[optType] = normalOpt;
        }
        if (emphasisOpt) {
            option.emphasis = option.emphasis || {};
            option.emphasis[optType] = emphasisOpt;
        }
    }
}
function convertNormalEmphasisForEach(option) {
    convertNormalEmphasis(option, 'itemStyle');
    convertNormalEmphasis(option, 'lineStyle');
    convertNormalEmphasis(option, 'areaStyle');
    convertNormalEmphasis(option, 'label');
}
function removeTextStyleInAxis(axesOpt) {
    if (!axesOpt) {
        return;
    }
    if (!(axesOpt instanceof Array)) {
        axesOpt = [
            axesOpt
        ];
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(axesOpt, function(axisOpt) {
        if (axisOpt.axisLabel) {
            var labelOpt = axisOpt.axisLabel;
            Object.assign(labelOpt, labelOpt.textStyle);
            labelOpt.textStyle = null;
        }
    });
}
function __TURBOPACK__default__export__(option) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(option.series, function(series) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].indexOf(GL_SERIES, series.type) >= 0) {
            convertNormalEmphasisForEach(series); // Compatitable with original mapbox
            if (series.coordinateSystem === 'mapbox') {
                series.coordinateSystem = 'mapbox3D';
                option.mapbox3D = option.mapbox;
            }
        }
    });
    removeTextStyleInAxis(option.xAxis3D);
    removeTextStyleInAxis(option.yAxis3D);
    removeTextStyleInAxis(option.zAxis3D);
    removeTextStyleInAxis(option.grid3D);
    convertNormalEmphasis(option.geo3D);
}
;
}}),
"[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * echarts-gl
 * Extension pack of ECharts providing 3d plots and globe visualization
 *
 * Copyright (c) 2014, echarts-gl
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/core/echarts.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$LayerGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/LayerGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$preprocessor$2f$backwardCompat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/preprocessor/backwardCompat.js [app-client] (ecmascript)");
;
;
;
function EChartsGL(zr) {
    this._layers = {};
    this._zr = zr;
}
EChartsGL.prototype.update = function(ecModel, api) {
    var self = this;
    var zr = api.getZr();
    if (!zr.getWidth() || !zr.getHeight()) {
        console.warn('Dom has no width or height');
        return;
    }
    function getLayerGL(model) {
        // Disable auto sleep in gl layer.
        zr.setSleepAfterStill(0);
        var zlevel; // Host on coordinate system.
        if (model.coordinateSystem && model.coordinateSystem.model) {
            zlevel = model.get('zlevel');
        } else {
            zlevel = model.get('zlevel');
        }
        var layers = self._layers;
        var layerGL = layers[zlevel];
        if (!layerGL) {
            layerGL = layers[zlevel] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$LayerGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('gl-' + zlevel, zr);
            if (zr.painter.isSingleCanvas()) {
                layerGL.virtual = true; // If container is canvas, use image to represent LayerGL
                // FIXME Performance
                var img = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Image({
                    z: 1e4,
                    style: {
                        image: layerGL.renderer.canvas
                    },
                    silent: true
                });
                layerGL.__hostImage = img;
                zr.add(img);
            }
            zr.painter.insertLayer(zlevel, layerGL);
        }
        if (layerGL.__hostImage) {
            layerGL.__hostImage.setStyle({
                width: layerGL.renderer.getWidth(),
                height: layerGL.renderer.getHeight()
            });
        }
        return layerGL;
    }
    function setSilent(groupGL, silent) {
        if (groupGL) {
            groupGL.traverse(function(mesh) {
                if (mesh.isRenderable && mesh.isRenderable()) {
                    mesh.ignorePicking = mesh.$ignorePicking != null ? mesh.$ignorePicking : silent;
                }
            });
        }
    }
    for(var zlevel in this._layers){
        this._layers[zlevel].removeViewsAll();
    }
    ecModel.eachComponent(function(componentType, componentModel) {
        if (componentType !== 'series') {
            var view = api.getViewOfComponentModel(componentModel);
            var coordSys = componentModel.coordinateSystem; // View with __ecgl__ flag is a echarts-gl component.
            if (view.__ecgl__) {
                var viewGL;
                if (coordSys) {
                    if (!coordSys.viewGL) {
                        console.error('Can\'t find viewGL in coordinateSystem of component ' + componentModel.id);
                        return;
                    }
                    viewGL = coordSys.viewGL;
                } else {
                    if (!componentModel.viewGL) {
                        console.error('Can\'t find viewGL of component ' + componentModel.id);
                        return;
                    }
                    viewGL = coordSys.viewGL;
                }
                var viewGL = coordSys.viewGL;
                var layerGL = getLayerGL(componentModel);
                layerGL.addView(viewGL);
                view.afterRender && view.afterRender(componentModel, ecModel, api, layerGL);
                setSilent(view.groupGL, componentModel.get('silent'));
            }
        }
    });
    ecModel.eachSeries(function(seriesModel) {
        var chartView = api.getViewOfSeriesModel(seriesModel);
        var coordSys = seriesModel.coordinateSystem;
        if (chartView.__ecgl__) {
            if (coordSys && !coordSys.viewGL && !chartView.viewGL) {
                console.error('Can\'t find viewGL of series ' + chartView.id);
                return;
            }
            var viewGL = coordSys && coordSys.viewGL || chartView.viewGL; // TODO Check zlevel not same with component of coordinate system ?
            var layerGL = getLayerGL(seriesModel);
            layerGL.addView(viewGL);
            chartView.afterRender && chartView.afterRender(seriesModel, ecModel, api, layerGL);
            setSilent(chartView.groupGL, seriesModel.get('silent'));
        }
    });
}; // Hack original getRenderedCanvas. Will removed after new echarts released
// TODO
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["registerPostInit"])(function(chart) {
    var zr = chart.getZr();
    var oldDispose = zr.painter.dispose;
    zr.painter.dispose = function() {
        if (typeof this.eachOtherLayer === 'function') {
            this.eachOtherLayer(function(layer) {
                if (layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$LayerGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
                    layer.dispose();
                }
            });
        }
        oldDispose.call(this);
    };
    zr.painter.getRenderedCanvas = function(opts) {
        opts = opts || {};
        if (this._singleCanvas) {
            return this._layers[0].dom;
        }
        var canvas = document.createElement('canvas');
        var dpr = opts.pixelRatio || this.dpr;
        canvas.width = this.getWidth() * dpr;
        canvas.height = this.getHeight() * dpr;
        var ctx = canvas.getContext('2d');
        ctx.dpr = dpr;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (opts.backgroundColor) {
            ctx.fillStyle = opts.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        var displayList = this.storage.getDisplayList(true);
        var scope = {};
        var zlevel;
        var self = this;
        function findAndDrawOtherLayer(smaller, larger) {
            var zlevelList = self._zlevelList;
            if (smaller == null) {
                smaller = -Infinity;
            }
            var intermediateLayer;
            for(var i = 0; i < zlevelList.length; i++){
                var z = zlevelList[i];
                var layer = self._layers[z];
                if (!layer.__builtin__ && z > smaller && z < larger) {
                    intermediateLayer = layer;
                    break;
                }
            }
            if (intermediateLayer && intermediateLayer.renderToCanvas) {
                ctx.save();
                intermediateLayer.renderToCanvas(ctx);
                ctx.restore();
            }
        }
        var layer = {
            ctx: ctx
        };
        for(var i = 0; i < displayList.length; i++){
            var el = displayList[i];
            if (el.zlevel !== zlevel) {
                findAndDrawOtherLayer(zlevel, el.zlevel);
                zlevel = el.zlevel;
            }
            this._doPaintEl(el, layer, true, null, scope);
        }
        findAndDrawOtherLayer(zlevel, Infinity);
        return canvas;
    };
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["registerPostUpdate"])(function(ecModel, api) {
    var zr = api.getZr();
    var egl = zr.__egl = zr.__egl || new EChartsGL(zr);
    egl.update(ecModel, api);
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["registerPreprocessor"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$preprocessor$2f$backwardCompat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = EChartsGL;
}}),
"[project]/node_modules/echarts-gl/lib/component/common/componentViewControlMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    defaultOption: {
        viewControl: {
            // perspective, orthographic.
            // TODO Isometric
            projection: 'perspective',
            // If rotate on on init
            autoRotate: false,
            // cw or ccw
            autoRotateDirection: 'cw',
            // Degree per second
            autoRotateSpeed: 10,
            // Start rotating after still for a given time
            // default is 3 seconds
            autoRotateAfterStill: 3,
            // Rotate, zoom damping.
            damping: 0.8,
            // Sensitivities for operations.
            // Can be array to set x,y respectively
            rotateSensitivity: 1,
            zoomSensitivity: 1,
            // Can be array to set x,y respectively
            panSensitivity: 1,
            // Which mouse button do rotate or pan
            panMouseButton: 'middle',
            rotateMouseButton: 'left',
            // Distance to the target
            // Only available when camera is perspective.
            distance: 150,
            // Min distance mouse can zoom in
            minDistance: 40,
            // Max distance mouse can zoom out
            maxDistance: 400,
            // Size of viewing volume.
            // Only available when camera is orthographic
            orthographicSize: 150,
            maxOrthographicSize: 400,
            minOrthographicSize: 20,
            // Center view point
            center: [
                0,
                0,
                0
            ],
            // Alpha angle for top-down rotation
            // Positive to rotate to top.
            alpha: 0,
            // beta angle for left-right rotation
            // Positive to rotate to right.
            beta: 0,
            minAlpha: -90,
            maxAlpha: 90 // minBeta: -Infinity
        }
    },
    setView: function(opts) {
        opts = opts || {};
        this.option.viewControl = this.option.viewControl || {};
        if (opts.alpha != null) {
            this.option.viewControl.alpha = opts.alpha;
        }
        if (opts.beta != null) {
            this.option.viewControl.beta = opts.beta;
        }
        if (opts.distance != null) {
            this.option.viewControl.distance = opts.distance;
        }
        if (opts.center != null) {
            this.option.viewControl.center = opts.center;
        }
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    defaultOption: {
        // Post effect
        postEffect: {
            enable: false,
            bloom: {
                enable: true,
                intensity: 0.1
            },
            depthOfField: {
                enable: false,
                focalRange: 20,
                focalDistance: 50,
                blurRadius: 10,
                fstop: 2.8,
                quality: 'medium'
            },
            screenSpaceAmbientOcclusion: {
                enable: false,
                radius: 2,
                // low, medium, high, ultra
                quality: 'medium',
                intensity: 1
            },
            screenSpaceReflection: {
                enable: false,
                quality: 'medium',
                maxRoughness: 0.8
            },
            colorCorrection: {
                enable: true,
                exposure: 0,
                brightness: 0,
                contrast: 1,
                saturation: 1,
                lookupTexture: ''
            },
            edge: {
                enable: false
            },
            FXAA: {
                enable: false
            }
        },
        // Temporal super sampling when the picture is still.
        temporalSuperSampling: {
            // Only enabled when postEffect is enabled
            enable: 'auto'
        }
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    defaultOption: {
        // Light is available when material.shading is not color
        light: {
            // Main light
            main: {
                shadow: false,
                // low, medium, high, ultra
                shadowQuality: 'high',
                color: '#fff',
                intensity: 1,
                alpha: 0,
                beta: 0
            },
            ambient: {
                color: '#fff',
                intensity: 0.2
            },
            ambientCubemap: {
                // Panorama environment texture,
                // Support .hdr and commmon web formats.
                texture: null,
                // Available when texture is hdr.
                exposure: 1,
                // Intensity for diffuse term
                diffuseIntensity: 0.5,
                // Intensity for specular term, only available when shading is realastic
                specularIntensity: 0.5
            }
        }
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentViewControlMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
;
;
;
;
var Grid3DModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'grid3D',
    dependencies: [
        'xAxis3D',
        'yAxis3D',
        'zAxis3D'
    ],
    defaultOption: {
        show: true,
        zlevel: -10,
        // Layout used for viewport
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        environment: 'auto',
        // Dimension of grid3D
        boxWidth: 100,
        boxHeight: 100,
        boxDepth: 100,
        // Common axis options.
        axisPointer: {
            show: true,
            lineStyle: {
                color: 'rgba(0, 0, 0, 0.8)',
                width: 1
            },
            label: {
                show: true,
                // (dimValue: number, value: Array) => string
                formatter: null,
                // TODO, Consider boxWidth
                margin: 8,
                // backgroundColor: '#ffbd67',
                // borderColor: '#000',
                // borderWidth: 0,
                textStyle: {
                    fontSize: 14,
                    color: '#fff',
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    padding: 3,
                    borderRadius: 3
                }
            }
        },
        axisLine: {
            show: true,
            lineStyle: {
                color: '#333',
                width: 2,
                type: 'solid'
            }
        },
        axisTick: {
            show: true,
            inside: false,
            length: 3,
            lineStyle: {
                width: 1
            }
        },
        axisLabel: {
            show: true,
            inside: false,
            rotate: 0,
            margin: 8,
            textStyle: {
                fontSize: 12
            }
        },
        splitLine: {
            show: true,
            lineStyle: {
                color: [
                    '#ccc'
                ],
                width: 1,
                type: 'solid'
            }
        },
        splitArea: {
            show: false,
            areaStyle: {
                color: [
                    'rgba(250,250,250,0.3)',
                    'rgba(200,200,200,0.3)'
                ]
            }
        },
        // Light options
        light: {
            main: {
                // Alpha angle for top-down rotation
                // Positive to rotate to top.
                alpha: 30,
                // beta angle for left-right rotation
                // Positive to rotate to right.
                beta: 40
            },
            ambient: {
                intensity: 0.4
            }
        },
        viewControl: {
            // Small damping for precise control.
            // damping: 0.1,
            // Alpha angle for top-down rotation
            // Positive to rotate to top.
            alpha: 20,
            // beta angle for left-right rotation
            // Positive to rotate to right.
            beta: 40,
            autoRotate: false,
            // Distance to the surface of grid3D.
            distance: 200,
            // Min distance to the surface of grid3D
            minDistance: 40,
            // Max distance to the surface of grid3D
            maxDistance: 400
        }
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Grid3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Grid3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Grid3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Grid3DModel;
}}),
"[project]/node_modules/echarts-gl/lib/util/OrbitControl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Provide orbit control for 3D objects
 *
 * @module echarts-gl/util/OrbitControl
 * @author Yi Shen(http://github.com/pissang)
 */ // TODO Remove magic numbers on sensitivity
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$Base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/core/Base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
;
;
;
;
;
var firstNotNull = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull;
var MOUSE_BUTTON_KEY_MAP = {
    left: 0,
    middle: 1,
    right: 2
};
function convertToArray(val) {
    if (!(val instanceof Array)) {
        val = [
            val,
            val
        ];
    }
    return val;
}
/**
 * @alias module:echarts-x/util/OrbitControl
 */ var OrbitControl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$Base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        /**
     * @type {module:zrender~ZRender}
     */ zr: null,
        /**
     * @type {module:echarts-gl/core/ViewGL}
     */ viewGL: null,
        /**
     * @type {clay.math.Vector3}
     */ _center: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
        /**
     * Minimum distance to the center
     * Only available when camera is perspective.
     * @type {number}
     * @default 0.5
     */ minDistance: 0.5,
        /**
     * Maximum distance to the center
     * Only available when camera is perspective.
     * @type {number}
     * @default 2
     */ maxDistance: 1.5,
        /**
     * Only available when camera is orthographic
     */ maxOrthographicSize: 300,
        /**
     * Only available when camera is orthographic
     */ minOrthographicSize: 30,
        /**
     * Minimum alpha rotation
     */ minAlpha: -90,
        /**
     * Maximum alpha rotation
     */ maxAlpha: 90,
        /**
     * Minimum beta rotation
     */ minBeta: -Infinity,
        /**
     * Maximum beta rotation
     */ maxBeta: Infinity,
        /**
     * Start auto rotating after still for the given time
     */ autoRotateAfterStill: 0,
        /**
     * Direction of autoRotate. cw or ccw when looking top down.
     */ autoRotateDirection: 'cw',
        /**
     * Degree per second
     */ autoRotateSpeed: 60,
        /**
     * @param {number}
     */ damping: 0.8,
        /**
     * @param {number}
     */ rotateSensitivity: 1,
        /**
     * @param {number}
     */ zoomSensitivity: 1,
        /**
     * @param {number}
     */ panSensitivity: 1,
        panMouseButton: 'middle',
        rotateMouseButton: 'left',
        /**
     * Pan or rotate
     * @private
     * @type {String}
     */ _mode: 'rotate',
        /**
     * @private
     * @type {clay.Camera}
     */ _camera: null,
        _needsUpdate: false,
        _rotating: false,
        // Rotation around yAxis in radian
        _phi: 0,
        // Rotation around xAxis in radian
        _theta: 0,
        _mouseX: 0,
        _mouseY: 0,
        _rotateVelocity: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
        _panVelocity: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
        _distance: 500,
        _zoomSpeed: 0,
        _stillTimeout: 0,
        _animators: []
    };
}, function() {
    // Each OrbitControl has it's own handler
    [
        '_mouseDownHandler',
        '_mouseWheelHandler',
        '_mouseMoveHandler',
        '_mouseUpHandler',
        '_pinchHandler',
        '_contextMenuHandler',
        '_update'
    ].forEach(function(hdlName) {
        this[hdlName] = this[hdlName].bind(this);
    }, this);
}, {
    /**
   * Initialize.
   * Mouse event binding
   */ init: function() {
        var zr = this.zr;
        if (zr) {
            zr.on('mousedown', this._mouseDownHandler);
            zr.on('globalout', this._mouseUpHandler);
            zr.on('mousewheel', this._mouseWheelHandler);
            zr.on('pinch', this._pinchHandler);
            zr.animation.on('frame', this._update);
            zr.dom.addEventListener('contextmenu', this._contextMenuHandler);
        }
    },
    /**
   * Dispose.
   * Mouse event unbinding
   */ dispose: function() {
        var zr = this.zr;
        if (zr) {
            zr.off('mousedown', this._mouseDownHandler);
            zr.off('mousemove', this._mouseMoveHandler);
            zr.off('mouseup', this._mouseUpHandler);
            zr.off('mousewheel', this._mouseWheelHandler);
            zr.off('pinch', this._pinchHandler);
            zr.off('globalout', this._mouseUpHandler);
            zr.dom.removeEventListener('contextmenu', this._contextMenuHandler);
            zr.animation.off('frame', this._update);
        }
        this.stopAllAnimation();
    },
    /**
   * Get distance
   * @return {number}
   */ getDistance: function() {
        return this._distance;
    },
    /**
   * Set distance
   * @param {number} distance
   */ setDistance: function(distance) {
        this._distance = distance;
        this._needsUpdate = true;
    },
    /**
   * Get size of orthographic viewing volume
   * @return {number}
   */ getOrthographicSize: function() {
        return this._orthoSize;
    },
    /**
   * Set size of orthographic viewing volume
   * @param {number} size
   */ setOrthographicSize: function(size) {
        this._orthoSize = size;
        this._needsUpdate = true;
    },
    /**
   * Get alpha rotation
   * Alpha angle for top-down rotation. Positive to rotate to top.
   *
   * Which means camera rotation around x axis.
   */ getAlpha: function() {
        return this._theta / Math.PI * 180;
    },
    /**
   * Get beta rotation
   * Beta angle for left-right rotation. Positive to rotate to right.
   *
   * Which means camera rotation around y axis.
   */ getBeta: function() {
        return -this._phi / Math.PI * 180;
    },
    /**
   * Get control center
   * @return {Array.<number>}
   */ getCenter: function() {
        return this._center.toArray();
    },
    /**
   * Set alpha rotation angle
   * @param {number} alpha
   */ setAlpha: function(alpha) {
        alpha = Math.max(Math.min(this.maxAlpha, alpha), this.minAlpha);
        this._theta = alpha / 180 * Math.PI;
        this._needsUpdate = true;
    },
    /**
   * Set beta rotation angle
   * @param {number} beta
   */ setBeta: function(beta) {
        beta = Math.max(Math.min(this.maxBeta, beta), this.minBeta);
        this._phi = -beta / 180 * Math.PI;
        this._needsUpdate = true;
    },
    /**
   * Set control center
   * @param {Array.<number>} center
   */ setCenter: function(centerArr) {
        this._center.setArray(centerArr);
    },
    /**
   * @param {module:echarts-gl/core/ViewGL} viewGL
   */ setViewGL: function(viewGL) {
        this.viewGL = viewGL;
    },
    /**
   * @return {clay.Camera}
   */ getCamera: function() {
        return this.viewGL.camera;
    },
    setFromViewControlModel: function(viewControlModel, extraOpts) {
        extraOpts = extraOpts || {};
        var baseDistance = extraOpts.baseDistance || 0;
        var baseOrthoSize = extraOpts.baseOrthoSize || 1;
        var projection = viewControlModel.get('projection');
        if (projection !== 'perspective' && projection !== 'orthographic' && projection !== 'isometric') {
            if ("TURBOPACK compile-time truthy", 1) {
                console.error('Unkown projection type %s, use perspective projection instead.', projection);
            }
            projection = 'perspective';
        }
        this._projection = projection;
        this.viewGL.setProjection(projection);
        var targetDistance = viewControlModel.get('distance') + baseDistance;
        var targetOrthographicSize = viewControlModel.get('orthographicSize') + baseOrthoSize;
        [
            [
                'damping',
                0.8
            ],
            [
                'autoRotate',
                false
            ],
            [
                'autoRotateAfterStill',
                3
            ],
            [
                'autoRotateDirection',
                'cw'
            ],
            [
                'autoRotateSpeed',
                10
            ],
            [
                'minDistance',
                30
            ],
            [
                'maxDistance',
                400
            ],
            [
                'minOrthographicSize',
                30
            ],
            [
                'maxOrthographicSize',
                300
            ],
            [
                'minAlpha',
                -90
            ],
            [
                'maxAlpha',
                90
            ],
            [
                'minBeta',
                -Infinity
            ],
            [
                'maxBeta',
                Infinity
            ],
            [
                'rotateSensitivity',
                1
            ],
            [
                'zoomSensitivity',
                1
            ],
            [
                'panSensitivity',
                1
            ],
            [
                'panMouseButton',
                'left'
            ],
            [
                'rotateMouseButton',
                'middle'
            ]
        ].forEach(function(prop) {
            this[prop[0]] = firstNotNull(viewControlModel.get(prop[0]), prop[1]);
        }, this);
        this.minDistance += baseDistance;
        this.maxDistance += baseDistance;
        this.minOrthographicSize += baseOrthoSize, this.maxOrthographicSize += baseOrthoSize;
        var ecModel = viewControlModel.ecModel;
        var animationOpts = {};
        [
            'animation',
            'animationDurationUpdate',
            'animationEasingUpdate'
        ].forEach(function(key) {
            animationOpts[key] = firstNotNull(viewControlModel.get(key), ecModel && ecModel.get(key));
        });
        var alpha = firstNotNull(extraOpts.alpha, viewControlModel.get('alpha')) || 0;
        var beta = firstNotNull(extraOpts.beta, viewControlModel.get('beta')) || 0;
        var center = firstNotNull(extraOpts.center, viewControlModel.get('center')) || [
            0,
            0,
            0
        ];
        if (animationOpts.animation && animationOpts.animationDurationUpdate > 0 && this._notFirst) {
            this.animateTo({
                alpha: alpha,
                beta: beta,
                center: center,
                distance: targetDistance,
                orthographicSize: targetOrthographicSize,
                easing: animationOpts.animationEasingUpdate,
                duration: animationOpts.animationDurationUpdate
            });
        } else {
            this.setDistance(targetDistance);
            this.setAlpha(alpha);
            this.setBeta(beta);
            this.setCenter(center);
            this.setOrthographicSize(targetOrthographicSize);
        }
        this._notFirst = true;
        this._validateProperties();
    },
    _validateProperties: function() {
        if ("TURBOPACK compile-time truthy", 1) {
            if (MOUSE_BUTTON_KEY_MAP[this.panMouseButton] == null) {
                console.error('Unkown panMouseButton %s. It should be left|middle|right', this.panMouseButton);
            }
            if (MOUSE_BUTTON_KEY_MAP[this.rotateMouseButton] == null) {
                console.error('Unkown rotateMouseButton %s. It should be left|middle|right', this.rotateMouseButton);
            }
            if (this.autoRotateDirection !== 'cw' && this.autoRotateDirection !== 'ccw') {
                console.error('Unkown autoRotateDirection %s. It should be cw|ccw', this.autoRotateDirection);
            }
        }
    },
    /**
   * @param {Object} opts
   * @param {number} opts.distance
   * @param {number} opts.alpha
   * @param {number} opts.beta
   * @param {number} opts.orthographicSize
   * @param {number} [opts.duration=1000]
   * @param {number} [opts.easing='linear']
   */ animateTo: function(opts) {
        var zr = this.zr;
        var self = this;
        var obj = {};
        var target = {};
        if (opts.distance != null) {
            obj.distance = this.getDistance();
            target.distance = opts.distance;
        }
        if (opts.orthographicSize != null) {
            obj.orthographicSize = this.getOrthographicSize();
            target.orthographicSize = opts.orthographicSize;
        }
        if (opts.alpha != null) {
            obj.alpha = this.getAlpha();
            target.alpha = opts.alpha;
        }
        if (opts.beta != null) {
            obj.beta = this.getBeta();
            target.beta = opts.beta;
        }
        if (opts.center != null) {
            obj.center = this.getCenter();
            target.center = opts.center;
        }
        return this._addAnimator(zr.animation.animate(obj).when(opts.duration || 1000, target).during(function() {
            if (obj.alpha != null) {
                self.setAlpha(obj.alpha);
            }
            if (obj.beta != null) {
                self.setBeta(obj.beta);
            }
            if (obj.distance != null) {
                self.setDistance(obj.distance);
            }
            if (obj.center != null) {
                self.setCenter(obj.center);
            }
            if (obj.orthographicSize != null) {
                self.setOrthographicSize(obj.orthographicSize);
            }
            self._needsUpdate = true;
        })).start(opts.easing || 'linear');
    },
    /**
   * Stop all animation
   */ stopAllAnimation: function() {
        for(var i = 0; i < this._animators.length; i++){
            this._animators[i].stop();
        }
        this._animators.length = 0;
    },
    update: function() {
        this._needsUpdate = true;
        this._update(20);
    },
    _isAnimating: function() {
        return this._animators.length > 0;
    },
    /**
   * Call update each frame
   * @param  {number} deltaTime Frame time
   */ _update: function(deltaTime) {
        if (this._rotating) {
            var radian = (this.autoRotateDirection === 'cw' ? 1 : -1) * this.autoRotateSpeed / 180 * Math.PI;
            this._phi -= radian * deltaTime / 1000;
            this._needsUpdate = true;
        } else if (this._rotateVelocity.len() > 0) {
            this._needsUpdate = true;
        }
        if (Math.abs(this._zoomSpeed) > 0.1 || this._panVelocity.len() > 0) {
            this._needsUpdate = true;
        }
        if (!this._needsUpdate) {
            return;
        }
        deltaTime = Math.min(deltaTime, 50);
        this._updateDistanceOrSize(deltaTime);
        this._updatePan(deltaTime);
        this._updateRotate(deltaTime);
        this._updateTransform();
        this.getCamera().update();
        this.zr && this.zr.refresh();
        this.trigger('update');
        this._needsUpdate = false;
    },
    _updateRotate: function(deltaTime) {
        var velocity = this._rotateVelocity;
        this._phi = velocity.y * deltaTime / 20 + this._phi;
        this._theta = velocity.x * deltaTime / 20 + this._theta;
        this.setAlpha(this.getAlpha());
        this.setBeta(this.getBeta());
        this._vectorDamping(velocity, Math.pow(this.damping, deltaTime / 16));
    },
    _updateDistanceOrSize: function(deltaTime) {
        if (this._projection === 'perspective') {
            this._setDistance(this._distance + this._zoomSpeed * deltaTime / 20);
        } else {
            this._setOrthoSize(this._orthoSize + this._zoomSpeed * deltaTime / 20);
        }
        this._zoomSpeed *= Math.pow(this.damping, deltaTime / 16);
    },
    _setDistance: function(distance) {
        this._distance = Math.max(Math.min(distance, this.maxDistance), this.minDistance);
    },
    _setOrthoSize: function(size) {
        this._orthoSize = Math.max(Math.min(size, this.maxOrthographicSize), this.minOrthographicSize);
        var camera = this.getCamera();
        var cameraHeight = this._orthoSize;
        var cameraWidth = cameraHeight / this.viewGL.viewport.height * this.viewGL.viewport.width;
        camera.left = -cameraWidth / 2;
        camera.right = cameraWidth / 2;
        camera.top = cameraHeight / 2;
        camera.bottom = -cameraHeight / 2;
    },
    _updatePan: function(deltaTime) {
        var velocity = this._panVelocity;
        var len = this._distance;
        var target = this.getCamera();
        var yAxis = target.worldTransform.y;
        var xAxis = target.worldTransform.x; // PENDING
        this._center.scaleAndAdd(xAxis, -velocity.x * len / 200).scaleAndAdd(yAxis, -velocity.y * len / 200);
        this._vectorDamping(velocity, 0);
    },
    _updateTransform: function() {
        var camera = this.getCamera();
        var dir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var theta = this._theta + Math.PI / 2;
        var phi = this._phi + Math.PI / 2;
        var r = Math.sin(theta);
        dir.x = r * Math.cos(phi);
        dir.y = -Math.cos(theta);
        dir.z = r * Math.sin(phi);
        camera.position.copy(this._center).scaleAndAdd(dir, this._distance);
        camera.rotation.identity() // First around y, then around x
        .rotateY(-this._phi).rotateX(-this._theta);
    },
    _startCountingStill: function() {
        clearTimeout(this._stillTimeout);
        var time = this.autoRotateAfterStill;
        var self = this;
        if (!isNaN(time) && time > 0) {
            this._stillTimeout = setTimeout(function() {
                self._rotating = true;
            }, time * 1000);
        }
    },
    _vectorDamping: function(v, damping) {
        var speed = v.len();
        speed = speed * damping;
        if (speed < 1e-4) {
            speed = 0;
        }
        v.normalize().scale(speed);
    },
    _decomposeTransform: function() {
        if (!this.getCamera()) {
            return;
        }
        this.getCamera().updateWorldTransform();
        var forward = this.getCamera().worldTransform.z;
        var alpha = Math.asin(forward.y);
        var beta = Math.atan2(forward.x, forward.z);
        this._theta = alpha;
        this._phi = -beta;
        this.setBeta(this.getBeta());
        this.setAlpha(this.getAlpha()); // Is perspective
        if (this.getCamera().aspect) {
            this._setDistance(this.getCamera().position.dist(this._center));
        } else {
            this._setOrthoSize(this.getCamera().top - this.getCamera().bottom);
        }
    },
    _mouseDownHandler: function(e) {
        if (e.target) {
            // If mouseon some zrender element.
            return;
        }
        if (this._isAnimating()) {
            return;
        }
        var x = e.offsetX;
        var y = e.offsetY;
        if (this.viewGL && !this.viewGL.containPoint(x, y)) {
            return;
        }
        this.zr.on('mousemove', this._mouseMoveHandler);
        this.zr.on('mouseup', this._mouseUpHandler);
        if (e.event.targetTouches) {
            if (e.event.targetTouches.length === 1) {
                this._mode = 'rotate';
            }
        } else {
            if (e.event.button === MOUSE_BUTTON_KEY_MAP[this.rotateMouseButton]) {
                this._mode = 'rotate';
            } else if (e.event.button === MOUSE_BUTTON_KEY_MAP[this.panMouseButton]) {
                this._mode = 'pan';
            } else {
                this._mode = '';
            }
        } // Reset rotate velocity
        this._rotateVelocity.set(0, 0);
        this._rotating = false;
        if (this.autoRotate) {
            this._startCountingStill();
        }
        this._mouseX = e.offsetX;
        this._mouseY = e.offsetY;
    },
    _mouseMoveHandler: function(e) {
        if (e.target && e.target.__isGLToZRProxy) {
            return;
        }
        if (this._isAnimating()) {
            return;
        }
        var panSensitivity = convertToArray(this.panSensitivity);
        var rotateSensitivity = convertToArray(this.rotateSensitivity);
        if (this._mode === 'rotate') {
            this._rotateVelocity.y = (e.offsetX - this._mouseX) / this.zr.getHeight() * 2 * rotateSensitivity[0];
            this._rotateVelocity.x = (e.offsetY - this._mouseY) / this.zr.getWidth() * 2 * rotateSensitivity[1];
        } else if (this._mode === 'pan') {
            this._panVelocity.x = (e.offsetX - this._mouseX) / this.zr.getWidth() * panSensitivity[0] * 400;
            this._panVelocity.y = (-e.offsetY + this._mouseY) / this.zr.getHeight() * panSensitivity[1] * 400;
        }
        this._mouseX = e.offsetX;
        this._mouseY = e.offsetY;
        e.event.preventDefault();
    },
    _mouseWheelHandler: function(e) {
        if (this._isAnimating()) {
            return;
        }
        var delta = e.event.wheelDelta // Webkit
         || -e.event.detail; // Firefox
        this._zoomHandler(e, delta);
    },
    _pinchHandler: function(e) {
        if (this._isAnimating()) {
            return;
        }
        this._zoomHandler(e, e.pinchScale > 1 ? 1 : -1); // Not rotate when pinch
        this._mode = '';
    },
    _zoomHandler: function(e, delta) {
        if (delta === 0) {
            return;
        }
        var x = e.offsetX;
        var y = e.offsetY;
        if (this.viewGL && !this.viewGL.containPoint(x, y)) {
            return;
        }
        var speed;
        if (this._projection === 'perspective') {
            speed = Math.max(Math.max(Math.min(this._distance - this.minDistance, this.maxDistance - this._distance)) / 20, 0.5);
        } else {
            speed = Math.max(Math.max(Math.min(this._orthoSize - this.minOrthographicSize, this.maxOrthographicSize - this._orthoSize)) / 20, 0.5);
        }
        this._zoomSpeed = (delta > 0 ? -1 : 1) * speed * this.zoomSensitivity;
        this._rotating = false;
        if (this.autoRotate && this._mode === 'rotate') {
            this._startCountingStill();
        }
        e.event.preventDefault();
    },
    _mouseUpHandler: function() {
        this.zr.off('mousemove', this._mouseMoveHandler);
        this.zr.off('mouseup', this._mouseUpHandler);
    },
    _isRightMouseButtonUsed: function() {
        return this.rotateMouseButton === 'right' || this.panMouseButton === 'right';
    },
    _contextMenuHandler: function(e) {
        if (this._isRightMouseButtonUsed()) {
            e.preventDefault();
        }
    },
    _addAnimator: function(animator) {
        var animators = this._animators;
        animators.push(animator);
        animator.done(function() {
            var idx = animators.indexOf(animator);
            if (idx >= 0) {
                animators.splice(idx, 1);
            }
        });
        return animator;
    }
});
/**
 * If auto rotate the target
 * @type {boolean}
 * @default false
 */ Object.defineProperty(OrbitControl.prototype, 'autoRotate', {
    get: function(val) {
        return this._autoRotate;
    },
    set: function(val) {
        this._autoRotate = val;
        this._rotating = val;
    }
});
const __TURBOPACK__default__export__ = OrbitControl;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    convertToDynamicArray: function(clear) {
        if (clear) {
            this.resetOffset();
        }
        var attributes = this.attributes;
        for(var name in attributes){
            if (clear || !attributes[name].value) {
                attributes[name].value = [];
            } else {
                attributes[name].value = Array.prototype.slice.call(attributes[name].value);
            }
        }
        if (clear || !this.indices) {
            this.indices = [];
        } else {
            this.indices = Array.prototype.slice.call(this.indices);
        }
    },
    convertToTypedArray: function() {
        var attributes = this.attributes;
        for(var name in attributes){
            if (attributes[name].value && attributes[name].value.length > 0) {
                attributes[name].value = new Float32Array(attributes[name].value);
            } else {
                attributes[name].value = null;
            }
        }
        if (this.indices && this.indices.length > 0) {
            this.indices = this.vertexCount > 0xffff ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.dirty();
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Lines geometry
 * Use screen space projected lines lineWidth > MAX_LINE_WIDTH
 * https://mattdesl.svbtle.com/drawing-lines-is-hard
 * @module echarts-gl/util/geometry/LinesGeometry
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3; // var CURVE_RECURSION_LIMIT = 8;
// var CURVE_COLLINEAR_EPSILON = 40;
var sampleLinePoints = [
    [
        0,
        0
    ],
    [
        1,
        1
    ]
];
/**
 * @constructor
 * @alias module:echarts-gl/util/geometry/LinesGeometry
 * @extends clay.Geometry
 */ var LinesGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        segmentScale: 1,
        dynamic: true,
        /**
     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH
     */ useNativeLine: true,
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 3, 'POSITION'),
            positionPrev: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('positionPrev', 'float', 3),
            positionNext: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('positionNext', 'float', 3),
            prevPositionPrev: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('prevPositionPrev', 'float', 3),
            prevPosition: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('prevPosition', 'float', 3),
            prevPositionNext: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('prevPositionNext', 'float', 3),
            offset: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('offset', 'float', 1),
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('color', 'float', 4, 'COLOR')
        }
    };
}, /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */ {
    /**
   * Reset offset
   */ resetOffset: function() {
        this._vertexOffset = 0;
        this._triangleOffset = 0;
        this._itemVertexOffsets = [];
    },
    /**
   * @param {number} nVertex
   */ setVertexCount: function(nVertex) {
        var attributes = this.attributes;
        if (this.vertexCount !== nVertex) {
            attributes.position.init(nVertex);
            attributes.color.init(nVertex);
            if (!this.useNativeLine) {
                attributes.positionPrev.init(nVertex);
                attributes.positionNext.init(nVertex);
                attributes.offset.init(nVertex);
            }
            if (nVertex > 0xffff) {
                if (this.indices instanceof Uint16Array) {
                    this.indices = new Uint32Array(this.indices);
                }
            } else {
                if (this.indices instanceof Uint32Array) {
                    this.indices = new Uint16Array(this.indices);
                }
            }
        }
    },
    /**
   * @param {number} nTriangle
   */ setTriangleCount: function(nTriangle) {
        if (this.triangleCount !== nTriangle) {
            if (nTriangle === 0) {
                this.indices = null;
            } else {
                this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
            }
        }
    },
    _getCubicCurveApproxStep: function(p0, p1, p2, p3) {
        var len = vec3.dist(p0, p1) + vec3.dist(p2, p1) + vec3.dist(p3, p2);
        var step = 1 / (len + 1) * this.segmentScale;
        return step;
    },
    /**
   * Get vertex count of cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @return number
   */ getCubicCurveVertexCount: function(p0, p1, p2, p3) {
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var segCount = Math.ceil(1 / step);
        if (!this.useNativeLine) {
            return segCount * 2 + 2;
        } else {
            return segCount * 2;
        }
    },
    /**
   * Get face count of cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @return number
   */ getCubicCurveTriangleCount: function(p0, p1, p2, p3) {
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var segCount = Math.ceil(1 / step);
        if (!this.useNativeLine) {
            return segCount * 2;
        } else {
            return 0;
        }
    },
    /**
   * Get vertex count of line
   * @return {number}
   */ getLineVertexCount: function() {
        return this.getPolylineVertexCount(sampleLinePoints);
    },
    /**
   * Get face count of line
   * @return {number}
   */ getLineTriangleCount: function() {
        return this.getPolylineTriangleCount(sampleLinePoints);
    },
    /**
   * Get how many vertices will polyline take.
   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
   * @return {number}
   */ getPolylineVertexCount: function(points) {
        var pointsLen;
        if (typeof points === 'number') {
            pointsLen = points;
        } else {
            var is2DArray = typeof points[0] !== 'number';
            pointsLen = is2DArray ? points.length : points.length / 3;
        }
        return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;
    },
    /**
   * Get how many triangles will polyline take.
   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
   * @return {number}
   */ getPolylineTriangleCount: function(points) {
        var pointsLen;
        if (typeof points === 'number') {
            pointsLen = points;
        } else {
            var is2DArray = typeof points[0] !== 'number';
            pointsLen = is2DArray ? points.length : points.length / 3;
        }
        return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;
    },
    /**
   * Add a cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @param {Array.<number>} color
   * @param {number} [lineWidth=1]
   */ addCubicCurve: function(p0, p1, p2, p3, color, lineWidth) {
        if (lineWidth == null) {
            lineWidth = 1;
        } // incremental interpolation
        // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION
        var x0 = p0[0], y0 = p0[1], z0 = p0[2];
        var x1 = p1[0], y1 = p1[1], z1 = p1[2];
        var x2 = p2[0], y2 = p2[1], z2 = p2[2];
        var x3 = p3[0], y3 = p3[1], z3 = p3[2];
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var step2 = step * step;
        var step3 = step2 * step;
        var pre1 = 3.0 * step;
        var pre2 = 3.0 * step2;
        var pre4 = 6.0 * step2;
        var pre5 = 6.0 * step3;
        var tmp1x = x0 - x1 * 2.0 + x2;
        var tmp1y = y0 - y1 * 2.0 + y2;
        var tmp1z = z0 - z1 * 2.0 + z2;
        var tmp2x = (x1 - x2) * 3.0 - x0 + x3;
        var tmp2y = (y1 - y2) * 3.0 - y0 + y3;
        var tmp2z = (z1 - z2) * 3.0 - z0 + z3;
        var fx = x0;
        var fy = y0;
        var fz = z0;
        var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;
        var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;
        var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;
        var ddfx = tmp1x * pre4 + tmp2x * pre5;
        var ddfy = tmp1y * pre4 + tmp2y * pre5;
        var ddfz = tmp1z * pre4 + tmp2z * pre5;
        var dddfx = tmp2x * pre5;
        var dddfy = tmp2y * pre5;
        var dddfz = tmp2z * pre5;
        var t = 0;
        var k = 0;
        var segCount = Math.ceil(1 / step);
        var points = new Float32Array((segCount + 1) * 3);
        var points = [];
        var offset = 0;
        for(var k = 0; k < segCount + 1; k++){
            points[offset++] = fx;
            points[offset++] = fy;
            points[offset++] = fz;
            fx += dfx;
            fy += dfy;
            fz += dfz;
            dfx += ddfx;
            dfy += ddfy;
            dfz += ddfz;
            ddfx += dddfx;
            ddfy += dddfy;
            ddfz += dddfz;
            t += step;
            if (t > 1) {
                fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);
                fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);
                fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);
            }
        }
        return this.addPolyline(points, color, lineWidth);
    },
    /**
   * Add a straight line
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} color
   * @param {number} [lineWidth=1]
   */ addLine: function(p0, p1, color, lineWidth) {
        return this.addPolyline([
            p0,
            p1
        ], color, lineWidth);
    },
    /**
   * Add a straight line
   * @param {Array.<Array> | Array.<number>} points
   * @param {Array.<number> | Array.<Array>} color
   * @param {number} [lineWidth=1]
   * @param {number} [startOffset=0]
   * @param {number} [pointsCount] Default to be amount of points in the first argument
   */ addPolyline: function(points, color, lineWidth, startOffset, pointsCount) {
        if (!points.length) {
            return;
        }
        var is2DArray = typeof points[0] !== 'number';
        if (pointsCount == null) {
            pointsCount = is2DArray ? points.length : points.length / 3;
        }
        if (pointsCount < 2) {
            return;
        }
        if (startOffset == null) {
            startOffset = 0;
        }
        if (lineWidth == null) {
            lineWidth = 1;
        }
        this._itemVertexOffsets.push(this._vertexOffset);
        var is2DArray = typeof points[0] !== 'number';
        var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;
        var positionAttr = this.attributes.position;
        var positionPrevAttr = this.attributes.positionPrev;
        var positionNextAttr = this.attributes.positionNext;
        var colorAttr = this.attributes.color;
        var offsetAttr = this.attributes.offset;
        var indices = this.indices;
        var vertexOffset = this._vertexOffset;
        var point;
        var pointColor;
        lineWidth = Math.max(lineWidth, 0.01);
        for(var k = startOffset; k < pointsCount; k++){
            if (is2DArray) {
                point = points[k];
                if (notSharingColor) {
                    pointColor = color[k];
                } else {
                    pointColor = color;
                }
            } else {
                var k3 = k * 3;
                point = point || [];
                point[0] = points[k3];
                point[1] = points[k3 + 1];
                point[2] = points[k3 + 2];
                if (notSharingColor) {
                    var k4 = k * 4;
                    pointColor = pointColor || [];
                    pointColor[0] = color[k4];
                    pointColor[1] = color[k4 + 1];
                    pointColor[2] = color[k4 + 2];
                    pointColor[3] = color[k4 + 3];
                } else {
                    pointColor = color;
                }
            }
            if (!this.useNativeLine) {
                if (k < pointsCount - 1) {
                    // Set to next two points
                    positionPrevAttr.set(vertexOffset + 2, point);
                    positionPrevAttr.set(vertexOffset + 3, point);
                }
                if (k > 0) {
                    // Set to previous two points
                    positionNextAttr.set(vertexOffset - 2, point);
                    positionNextAttr.set(vertexOffset - 1, point);
                }
                positionAttr.set(vertexOffset, point);
                positionAttr.set(vertexOffset + 1, point);
                colorAttr.set(vertexOffset, pointColor);
                colorAttr.set(vertexOffset + 1, pointColor);
                offsetAttr.set(vertexOffset, lineWidth / 2);
                offsetAttr.set(vertexOffset + 1, -lineWidth / 2);
                vertexOffset += 2;
            } else {
                if (k > 1) {
                    positionAttr.copy(vertexOffset, vertexOffset - 1);
                    colorAttr.copy(vertexOffset, vertexOffset - 1);
                    vertexOffset++;
                }
            }
            if (!this.useNativeLine) {
                if (k > 0) {
                    var idx3 = this._triangleOffset * 3;
                    var indices = this.indices; // 0-----2
                    // 1-----3
                    // 0->1->2, 1->3->2
                    indices[idx3] = vertexOffset - 4;
                    indices[idx3 + 1] = vertexOffset - 3;
                    indices[idx3 + 2] = vertexOffset - 2;
                    indices[idx3 + 3] = vertexOffset - 3;
                    indices[idx3 + 4] = vertexOffset - 1;
                    indices[idx3 + 5] = vertexOffset - 2;
                    this._triangleOffset += 2;
                }
            } else {
                colorAttr.set(vertexOffset, pointColor);
                positionAttr.set(vertexOffset, point);
                vertexOffset++;
            }
        }
        if (!this.useNativeLine) {
            var start = this._vertexOffset;
            var end = this._vertexOffset + pointsCount * 2;
            positionPrevAttr.copy(start, start + 2);
            positionPrevAttr.copy(start + 1, start + 3);
            positionNextAttr.copy(end - 1, end - 3);
            positionNextAttr.copy(end - 2, end - 4);
        }
        this._vertexOffset = vertexOffset;
        return this._vertexOffset;
    },
    /**
   * Set color of single line.
   */ setItemColor: function(idx, color) {
        var startOffset = this._itemVertexOffsets[idx];
        var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;
        for(var i = startOffset; i < endOffset; i++){
            this.attributes.color.set(i, color);
        }
        this.dirty('color');
    },
    /**
   * @return {number}
   */ currentTriangleOffset: function() {
        return this._triangleOffset;
    },
    /**
   * @return {number}
   */ currentVertexOffset: function() {
        return this._vertexOffset;
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(LinesGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = LinesGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/util/ZRTextureAtlasSurface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Texture Atlas for the sprites.
 * It uses zrender for 2d element management and rendering
 * @module echarts-gl/util/ZRTextureAtlasSurface
 */ // TODO Expand.
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$zrender$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__zrender$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/zrender.js [app-client] (ecmascript) <export * as zrender>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
;
;
function ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr) {
    this._zr = zr;
    /**
   * Current cursor x
   * @type {number}
   * @private
   */ this._x = 0;
    /**
   * Current cursor y
   * @type {number}
   */ this._y = 0;
    this._rowHeight = 0;
    /**
   * width without dpr.
   * @type {number}
   * @private
   */ this.width = width;
    /**
   * height without dpr.
   * @type {number}
   * @private
   */ this.height = height;
    /**
   * offsetX without dpr
   * @type {number}
   */ this.offsetX = offsetX;
    /**
   * offsetY without dpr
   * @type {number}
   */ this.offsetY = offsetY;
    this.dpr = dpr;
    this.gap = gap;
}
ZRTextureAtlasSurfaceNode.prototype = {
    constructor: ZRTextureAtlasSurfaceNode,
    clear: function() {
        this._x = 0;
        this._y = 0;
        this._rowHeight = 0;
    },
    /**
   * Add shape to atlas
   * @param {module:zrender/graphic/Displayable} shape
   * @param {number} width
   * @param {number} height
   * @return {Array}
   */ add: function(el, width, height) {
        // FIXME Text element not consider textAlign and textVerticalAlign.
        // TODO, inner text, shadow
        var rect = el.getBoundingRect(); // FIXME aspect ratio
        if (width == null) {
            width = rect.width;
        }
        if (height == null) {
            height = rect.height;
        }
        width *= this.dpr;
        height *= this.dpr;
        this._fitElement(el, width, height); // var aspect = el.scale[1] / el.scale[0];
        // Adjust aspect ratio to make the text more clearly
        // FIXME If height > width, width is useless ?
        // width = height * aspect;
        // el.position[0] *= aspect;
        // el.scale[0] = el.scale[1];
        var x = this._x;
        var y = this._y;
        var canvasWidth = this.width * this.dpr;
        var canvasHeight = this.height * this.dpr;
        var gap = this.gap;
        if (x + width + gap > canvasWidth) {
            // Change a new row
            x = this._x = 0;
            y += this._rowHeight + gap;
            this._y = y; // Reset row height
            this._rowHeight = 0;
        }
        this._x += width + gap;
        this._rowHeight = Math.max(this._rowHeight, height);
        if (y + height + gap > canvasHeight) {
            // There is no space anymore
            return null;
        } // Shift the el
        el.x += this.offsetX * this.dpr + x;
        el.y += this.offsetY * this.dpr + y;
        this._zr.add(el);
        var coordsOffset = [
            this.offsetX / this.width,
            this.offsetY / this.height
        ];
        var coords = [
            [
                x / canvasWidth + coordsOffset[0],
                y / canvasHeight + coordsOffset[1]
            ],
            [
                (x + width) / canvasWidth + coordsOffset[0],
                (y + height) / canvasHeight + coordsOffset[1]
            ]
        ];
        return coords;
    },
    /**
   * Fit element size by correct its position and scaling
   * @param {module:zrender/graphic/Displayable} el
   * @param {number} spriteWidth
   * @param {number} spriteHeight
   */ _fitElement: function(el, spriteWidth, spriteHeight) {
        // TODO, inner text, shadow
        var rect = el.getBoundingRect();
        var scaleX = spriteWidth / rect.width;
        var scaleY = spriteHeight / rect.height;
        el.x = -rect.x * scaleX;
        el.y = -rect.y * scaleY;
        el.scaleX = scaleX;
        el.scaleY = scaleY;
        el.update();
    }
};
/**
 * constructor
 * @alias module:echarts-gl/util/ZRTextureAtlasSurface
 * @param {number} opt.width
 * @param {number} opt.height
 * @param {number} opt.devicePixelRatio
 * @param {number} opt.gap Gap for safe.
 * @param {Function} opt.onupdate
 */ function ZRTextureAtlasSurface(opt) {
    opt = opt || {};
    opt.width = opt.width || 512;
    opt.height = opt.height || 512;
    opt.devicePixelRatio = opt.devicePixelRatio || 1;
    opt.gap = opt.gap == null ? 2 : opt.gap;
    var canvas = document.createElement('canvas');
    canvas.width = opt.width * opt.devicePixelRatio;
    canvas.height = opt.height * opt.devicePixelRatio;
    this._canvas = canvas;
    this._texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        image: canvas,
        flipY: false
    });
    var self = this;
    /**
   * zrender instance in the Chart
   * @type {zrender~ZRender}
   */ this._zr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$zrender$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__zrender$3e$__["zrender"].init(canvas);
    var oldRefreshImmediately = this._zr.refreshImmediately;
    this._zr.refreshImmediately = function() {
        oldRefreshImmediately.call(this);
        self._texture.dirty();
        self.onupdate && self.onupdate();
    };
    this._dpr = opt.devicePixelRatio;
    /**
   * Texture coords map for each sprite image
   * @type {Object}
   */ this._coords = {};
    this.onupdate = opt.onupdate;
    this._gap = opt.gap; // Left sub atlas.
    this._textureAtlasNodes = [
        new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)
    ];
    this._nodeWidth = opt.width;
    this._nodeHeight = opt.height;
    this._currentNodeIdx = 0;
}
ZRTextureAtlasSurface.prototype = {
    /**
   * Clear the texture atlas
   */ clear: function() {
        for(var i = 0; i < this._textureAtlasNodes.length; i++){
            this._textureAtlasNodes[i].clear();
        }
        this._currentNodeIdx = 0;
        this._zr.clear();
        this._coords = {};
    },
    /**
   * @return {number}
   */ getWidth: function() {
        return this._width;
    },
    /**
   * @return {number}
   */ getHeight: function() {
        return this._height;
    },
    /**
   * @return {number}
   */ getTexture: function() {
        return this._texture;
    },
    /**
   * @return {number}
   */ getDevicePixelRatio: function() {
        return this._dpr;
    },
    getZr: function() {
        return this._zr;
    },
    _getCurrentNode: function() {
        return this._textureAtlasNodes[this._currentNodeIdx];
    },
    _expand: function() {
        this._currentNodeIdx++;
        if (this._textureAtlasNodes[this._currentNodeIdx]) {
            // Use the node created previously.
            return this._textureAtlasNodes[this._currentNodeIdx];
        }
        var maxSize = 4096 / this._dpr;
        var textureAtlasNodes = this._textureAtlasNodes;
        var nodeLen = textureAtlasNodes.length;
        var offsetX = nodeLen * this._nodeWidth % maxSize;
        var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;
        if (offsetY >= maxSize) {
            // Failed if image is too large.
            if ("TURBOPACK compile-time truthy", 1) {
                console.error('Too much labels. Some will be ignored.');
            }
            return;
        }
        var width = (offsetX + this._nodeWidth) * this._dpr;
        var height = (offsetY + this._nodeHeight) * this._dpr;
        try {
            // Resize will error in node.
            this._zr.resize({
                width: width,
                height: height
            });
        } catch (e) {
            this._canvas.width = width;
            this._canvas.height = height;
        }
        var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);
        this._textureAtlasNodes.push(newNode);
        return newNode;
    },
    add: function(el, width, height) {
        if (this._coords[el.id]) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Element already been add');
            }
            return this._coords[el.id];
        }
        var coords = this._getCurrentNode().add(el, width, height);
        if (!coords) {
            var newNode = this._expand();
            if (!newNode) {
                // To maximum
                return;
            }
            coords = newNode.add(el, width, height);
        }
        this._coords[el.id] = coords;
        return coords;
    },
    /**
   * Get coord scale after texture atlas is expanded.
   * @return {Array.<number>}
   */ getCoordsScale: function() {
        var dpr = this._dpr;
        return [
            this._nodeWidth / this._canvas.width * dpr,
            this._nodeHeight / this._canvas.height * dpr
        ];
    },
    /**
   * Get texture coords of sprite image
   * @param  {string} id Image id
   * @return {Array}
   */ getCoords: function(id) {
        return this._coords[id];
    },
    dispose: function() {
        this._zr.dispose();
    }
};
const __TURBOPACK__default__export__ = ZRTextureAtlasSurface;
}}),
"[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$plugin$2f$Skybox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/plugin/Skybox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/tool/color.js [app-client] (ecmascript) <export * as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$canvas$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__brushSingle__as__innerDrawElementOnCanvas$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/canvas/graphic.js [app-client] (ecmascript) <export brushSingle as innerDrawElementOnCanvas>");
;
;
;
function SceneHelper() {}
SceneHelper.prototype = {
    constructor: SceneHelper,
    setScene: function(scene) {
        this._scene = scene;
        if (this._skybox) {
            this._skybox.attachScene(this._scene);
        }
    },
    initLight: function(rootNode) {
        this._lightRoot = rootNode;
        /**
     * @type {clay.light.Directional}
     */ this.mainLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DirectionalLight({
            shadowBias: 0.005
        });
        /**
     * @type {clay.light.Ambient}
     */ this.ambientLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].AmbientLight();
        rootNode.add(this.mainLight);
        rootNode.add(this.ambientLight);
    },
    dispose: function() {
        if (this._lightRoot) {
            this._lightRoot.remove(this.mainLight);
            this._lightRoot.remove(this.ambientLight);
        }
    },
    updateLight: function(componentModel) {
        var mainLight = this.mainLight;
        var ambientLight = this.ambientLight;
        var lightModel = componentModel.getModel('light');
        var mainLightModel = lightModel.getModel('main');
        var ambientLightModel = lightModel.getModel('ambient');
        mainLight.intensity = mainLightModel.get('intensity');
        ambientLight.intensity = ambientLightModel.get('intensity');
        mainLight.color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(mainLightModel.get('color')).slice(0, 3);
        ambientLight.color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(ambientLightModel.get('color')).slice(0, 3);
        var alpha = mainLightModel.get('alpha') || 0;
        var beta = mainLightModel.get('beta') || 0;
        mainLight.position.setArray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].directionFromAlphaBeta(alpha, beta));
        mainLight.lookAt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3.ZERO);
        mainLight.castShadow = mainLightModel.get('shadow');
        mainLight.shadowResolution = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getShadowResolution(mainLightModel.get('shadowQuality'));
    },
    updateAmbientCubemap: function(renderer, componentModel, api) {
        var ambientCubemapModel = componentModel.getModel('light.ambientCubemap');
        var textureUrl = ambientCubemapModel.get('texture');
        if (textureUrl) {
            this._cubemapLightsCache = this._cubemapLightsCache || {};
            var lights = this._cubemapLightsCache[textureUrl];
            if (!lights) {
                var self = this;
                lights = this._cubemapLightsCache[textureUrl] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createAmbientCubemap(ambientCubemapModel.option, renderer, api, function() {
                    // Use prefitered cubemap
                    if (self._isSkyboxFromAmbientCubemap) {
                        self._skybox.setEnvironmentMap(lights.specular.cubemap);
                    }
                    api.getZr().refresh();
                });
            }
            this._lightRoot.add(lights.diffuse);
            this._lightRoot.add(lights.specular);
            this._currentCubemapLights = lights;
        } else if (this._currentCubemapLights) {
            this._lightRoot.remove(this._currentCubemapLights.diffuse);
            this._lightRoot.remove(this._currentCubemapLights.specular);
            this._currentCubemapLights = null;
        }
    },
    updateSkybox: function(renderer, componentModel, api) {
        var environmentUrl = componentModel.get('environment');
        var self = this;
        function getSkybox() {
            self._skybox = self._skybox || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$plugin$2f$Skybox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            return self._skybox;
        }
        var skybox = getSkybox();
        if (environmentUrl && environmentUrl !== 'none') {
            if (environmentUrl === 'auto') {
                this._isSkyboxFromAmbientCubemap = true; // Use environment in ambient cubemap
                if (this._currentCubemapLights) {
                    var cubemap = this._currentCubemapLights.specular.cubemap;
                    skybox.setEnvironmentMap(cubemap);
                    if (this._scene) {
                        skybox.attachScene(this._scene);
                    }
                    skybox.material.set('lod', 3);
                } else if (this._skybox) {
                    this._skybox.detachScene();
                }
            } else if (typeof environmentUrl === 'object' && environmentUrl.colorStops || typeof environmentUrl === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__["color"].parse(environmentUrl)) {
                this._isSkyboxFromAmbientCubemap = false;
                var texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D({
                    anisotropic: 8,
                    flipY: false
                });
                skybox.setEnvironmentMap(texture);
                var canvas = texture.image = document.createElement('canvas');
                canvas.width = canvas.height = 16;
                var ctx = canvas.getContext('2d');
                var rect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Rect({
                    shape: {
                        x: 0,
                        y: 0,
                        width: 16,
                        height: 16
                    },
                    style: {
                        fill: environmentUrl
                    }
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$canvas$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__brushSingle__as__innerDrawElementOnCanvas$3e$__["innerDrawElementOnCanvas"])(ctx, rect);
                skybox.attachScene(this._scene);
            } else {
                this._isSkyboxFromAmbientCubemap = false; // Panorama
                var texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadTexture(environmentUrl, api, {
                    anisotropic: 8,
                    flipY: false
                });
                skybox.setEnvironmentMap(texture);
                skybox.attachScene(this._scene);
            }
        } else {
            if (this._skybox) {
                this._skybox.detachScene(this._scene);
            }
            this._skybox = null;
        }
        var coordSys = componentModel.coordinateSystem;
        if (this._skybox) {
            if (coordSys && coordSys.viewGL && environmentUrl !== 'auto' && !(environmentUrl.match && environmentUrl.match(/.hdr$/))) {
                var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
                this._skybox.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');
            } else {
                this._skybox.material.undefine('fragment', 'SRGB_DECODE');
            } // var ambientCubemapUrl = environmentUrl === 'auto'
        //     ? componentModel.get('light.ambientCubemap.texture')
        //     : environmentUrl;
        }
    }
};
const __TURBOPACK__default__export__ = SceneHelper;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/Quads.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @module echarts-gl/util/geometry/QuadsGeometry
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
/**
 * @constructor
 * @alias module:echarts-gl/util/geometry/QuadsGeometry
 * @extends clay.Geometry
 */ var QuadsGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        segmentScale: 1,
        /**
     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH
     */ useNativeLine: true,
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 3, 'POSITION'),
            normal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('normal', 'float', 3, 'NORMAL'),
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('color', 'float', 4, 'COLOR')
        }
    };
}, /** @lends module: echarts-gl/util/geometry/QuadsGeometry.prototype */ {
    /**
   * Reset offset
   */ resetOffset: function() {
        this._vertexOffset = 0;
        this._faceOffset = 0;
    },
    /**
   * @param {number} nQuad
   */ setQuadCount: function(nQuad) {
        var attributes = this.attributes;
        var vertexCount = this.getQuadVertexCount() * nQuad;
        var triangleCount = this.getQuadTriangleCount() * nQuad;
        if (this.vertexCount !== vertexCount) {
            attributes.position.init(vertexCount);
            attributes.normal.init(vertexCount);
            attributes.color.init(vertexCount);
        }
        if (this.triangleCount !== triangleCount) {
            this.indices = vertexCount > 0xffff ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
        }
    },
    getQuadVertexCount: function() {
        return 4;
    },
    getQuadTriangleCount: function() {
        return 2;
    },
    /**
   * Add a quad, which in following order:
   * 0-----1
   * 3-----2
   */ addQuad: function() {
        var a = vec3.create();
        var b = vec3.create();
        var normal = vec3.create();
        var indices = [
            0,
            3,
            1,
            3,
            2,
            1
        ];
        return function(coords, color) {
            var positionAttr = this.attributes.position;
            var normalAttr = this.attributes.normal;
            var colorAttr = this.attributes.color;
            vec3.sub(a, coords[1], coords[0]);
            vec3.sub(b, coords[2], coords[1]);
            vec3.cross(normal, a, b);
            vec3.normalize(normal, normal);
            for(var i = 0; i < 4; i++){
                positionAttr.set(this._vertexOffset + i, coords[i]);
                colorAttr.set(this._vertexOffset + i, color);
                normalAttr.set(this._vertexOffset + i, normal);
            }
            var idx = this._faceOffset * 3;
            for(var i = 0; i < 6; i++){
                this.indices[idx + i] = indices[i] + this._vertexOffset;
            }
            this._vertexOffset += 4;
            this._faceOffset += 2;
        };
    }()
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(QuadsGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = QuadsGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DFace.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Quads$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Quads.js [app-client] (ecmascript)");
;
;
;
;
;
var firstNotNull = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull;
var dimIndicesMap = {
    // Left to right
    x: 0,
    // Far to near
    y: 2,
    // Bottom to up
    z: 1
};
function updateFacePlane(node, plane, otherAxis, dir) {
    var coord = [
        0,
        0,
        0
    ];
    var distance = dir < 0 ? otherAxis.getExtentMin() : otherAxis.getExtentMax();
    coord[dimIndicesMap[otherAxis.dim]] = distance;
    node.position.setArray(coord);
    node.rotation.identity(); // Negative distance because on the opposite of normal direction.
    plane.distance = -Math.abs(distance);
    plane.normal.set(0, 0, 0);
    if (otherAxis.dim === 'x') {
        node.rotation.rotateY(dir * Math.PI / 2);
        plane.normal.x = -dir;
    } else if (otherAxis.dim === 'z') {
        node.rotation.rotateX(-dir * Math.PI / 2);
        plane.normal.y = -dir;
    } else {
        if (dir > 0) {
            node.rotation.rotateY(Math.PI);
        }
        plane.normal.z = -dir;
    }
}
function Grid3DFace(faceInfo, linesMaterial, quadsMaterial) {
    this.rootNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
    var linesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            useNativeLine: false
        }),
        material: linesMaterial,
        castShadow: false,
        ignorePicking: true,
        $ignorePicking: true,
        renderOrder: 1
    });
    var quadsMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Quads$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
        material: quadsMaterial,
        castShadow: false,
        culling: false,
        ignorePicking: true,
        $ignorePicking: true,
        renderOrder: 0
    }); // Quads are behind lines.
    this.rootNode.add(quadsMesh);
    this.rootNode.add(linesMesh);
    this.faceInfo = faceInfo;
    this.plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Plane();
    this.linesMesh = linesMesh;
    this.quadsMesh = quadsMesh;
}
Grid3DFace.prototype.update = function(grid3DModel, ecModel, api) {
    var cartesian = grid3DModel.coordinateSystem;
    var axes = [
        cartesian.getAxis(this.faceInfo[0]),
        cartesian.getAxis(this.faceInfo[1])
    ];
    var lineGeometry = this.linesMesh.geometry;
    var quadsGeometry = this.quadsMesh.geometry;
    lineGeometry.convertToDynamicArray(true);
    quadsGeometry.convertToDynamicArray(true);
    this._updateSplitLines(lineGeometry, axes, grid3DModel, api);
    this._udpateSplitAreas(quadsGeometry, axes, grid3DModel, api);
    lineGeometry.convertToTypedArray();
    quadsGeometry.convertToTypedArray();
    var otherAxis = cartesian.getAxis(this.faceInfo[2]);
    updateFacePlane(this.rootNode, this.plane, otherAxis, this.faceInfo[3]);
};
Grid3DFace.prototype._updateSplitLines = function(geometry, axes, grid3DModel, api) {
    var dpr = api.getDevicePixelRatio();
    axes.forEach(function(axis, idx) {
        var axisModel = axis.model;
        var otherExtent = axes[1 - idx].getExtent();
        if (axis.scale.isBlank()) {
            return;
        }
        var splitLineModel = axisModel.getModel('splitLine', grid3DModel.getModel('splitLine')); // Render splitLines
        if (splitLineModel.get('show')) {
            var lineStyleModel = splitLineModel.getModel('lineStyle');
            var lineColors = lineStyleModel.get('color');
            var opacity = firstNotNull(lineStyleModel.get('opacity'), 1.0);
            var lineWidth = firstNotNull(lineStyleModel.get('width'), 1.0);
            lineColors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(lineColors) ? lineColors : [
                lineColors
            ];
            var ticksCoords = axis.getTicksCoords({
                tickModel: splitLineModel
            });
            var count = 0;
            for(var i = 0; i < ticksCoords.length; i++){
                var tickCoord = ticksCoords[i].coord;
                var lineColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(lineColors[count % lineColors.length]);
                lineColor[3] *= opacity;
                var p0 = [
                    0,
                    0,
                    0
                ];
                var p1 = [
                    0,
                    0,
                    0
                ]; // 0 - x, 1 - y
                p0[idx] = p1[idx] = tickCoord;
                p0[1 - idx] = otherExtent[0];
                p1[1 - idx] = otherExtent[1];
                geometry.addLine(p0, p1, lineColor, lineWidth * dpr);
                count++;
            }
        }
    });
};
Grid3DFace.prototype._udpateSplitAreas = function(geometry, axes, grid3DModel, api) {
    axes.forEach(function(axis, idx) {
        var axisModel = axis.model;
        var otherExtent = axes[1 - idx].getExtent();
        if (axis.scale.isBlank()) {
            return;
        }
        var splitAreaModel = axisModel.getModel('splitArea', grid3DModel.getModel('splitArea')); // Render splitAreas
        if (splitAreaModel.get('show')) {
            var areaStyleModel = splitAreaModel.getModel('areaStyle');
            var colors = areaStyleModel.get('color');
            var opacity = firstNotNull(areaStyleModel.get('opacity'), 1.0);
            colors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(colors) ? colors : [
                colors
            ];
            var ticksCoords = axis.getTicksCoords({
                tickModel: splitAreaModel,
                clamp: true
            });
            var count = 0;
            var prevP0 = [
                0,
                0,
                0
            ];
            var prevP1 = [
                0,
                0,
                0
            ]; // 0 - x, 1 - y
            for(var i = 0; i < ticksCoords.length; i++){
                var tickCoord = ticksCoords[i].coord;
                var p0 = [
                    0,
                    0,
                    0
                ];
                var p1 = [
                    0,
                    0,
                    0
                ]; // 0 - x, 1 - y
                p0[idx] = p1[idx] = tickCoord;
                p0[1 - idx] = otherExtent[0];
                p1[1 - idx] = otherExtent[1];
                if (i === 0) {
                    prevP0 = p0;
                    prevP1 = p1;
                    continue;
                }
                var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(colors[count % colors.length]);
                color[3] *= opacity;
                geometry.addQuad([
                    prevP0,
                    p0,
                    p1,
                    prevP1
                ], color);
                prevP0 = p0;
                prevP1 = p1;
                count++;
            }
        }
    });
};
const __TURBOPACK__default__export__ = Grid3DFace;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/Sprites.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Geometry collecting sprites
 *
 * @module echarts-gl/util/geometry/Sprites
 * @author Yi Shen(https://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)");
;
;
;
var squareTriangles = [
    0,
    1,
    2,
    0,
    2,
    3
];
var SpritesGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 3, 'POSITION'),
            texcoord: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('texcoord', 'float', 2, 'TEXCOORD_0'),
            offset: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('offset', 'float', 2),
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('color', 'float', 4, 'COLOR')
        }
    };
}, {
    resetOffset: function() {
        this._vertexOffset = 0;
        this._faceOffset = 0;
    },
    setSpriteCount: function(spriteCount) {
        this._spriteCount = spriteCount;
        var vertexCount = spriteCount * 4;
        var triangleCount = spriteCount * 2;
        if (this.vertexCount !== vertexCount) {
            this.attributes.position.init(vertexCount);
            this.attributes.offset.init(vertexCount);
            this.attributes.color.init(vertexCount);
        }
        if (this.triangleCount !== triangleCount) {
            this.indices = vertexCount > 0xffff ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
        }
    },
    setSpriteAlign: function(spriteOffset, size, align, verticalAlign, margin) {
        if (align == null) {
            align = 'left';
        }
        if (verticalAlign == null) {
            verticalAlign = 'top';
        }
        var leftOffset, topOffset, rightOffset, bottomOffset;
        margin = margin || 0;
        switch(align){
            case 'left':
                leftOffset = margin;
                rightOffset = size[0] + margin;
                break;
            case 'center':
            case 'middle':
                leftOffset = -size[0] / 2;
                rightOffset = size[0] / 2;
                break;
            case 'right':
                leftOffset = -size[0] - margin;
                rightOffset = -margin;
                break;
        }
        switch(verticalAlign){
            case 'bottom':
                topOffset = margin;
                bottomOffset = size[1] + margin;
                break;
            case 'middle':
                topOffset = -size[1] / 2;
                bottomOffset = size[1] / 2;
                break;
            case 'top':
                topOffset = -size[1] - margin;
                bottomOffset = -margin;
                break;
        } // 3----2
        // 0----1
        var vertexOffset = spriteOffset * 4;
        var offsetAttr = this.attributes.offset;
        offsetAttr.set(vertexOffset, [
            leftOffset,
            bottomOffset
        ]);
        offsetAttr.set(vertexOffset + 1, [
            rightOffset,
            bottomOffset
        ]);
        offsetAttr.set(vertexOffset + 2, [
            rightOffset,
            topOffset
        ]);
        offsetAttr.set(vertexOffset + 3, [
            leftOffset,
            topOffset
        ]);
    },
    /**
   * Add sprite
   * @param {Array.<number>} position
   * @param {Array.<number>} size [width, height]
   * @param {Array.<Array>} coords [leftBottom, rightTop]
   * @param {string} [align='left'] 'left' 'center' 'right'
   * @param {string} [verticalAlign='top'] 'top' 'middle' 'bottom'
   * @param {number} [screenMargin=0]
   */ addSprite: function(position, size, coords, align, verticalAlign, screenMargin) {
        var vertexOffset = this._vertexOffset;
        this.setSprite(this._vertexOffset / 4, position, size, coords, align, verticalAlign, screenMargin);
        for(var i = 0; i < squareTriangles.length; i++){
            this.indices[this._faceOffset * 3 + i] = squareTriangles[i] + vertexOffset;
        }
        this._faceOffset += 2;
        this._vertexOffset += 4;
        return vertexOffset / 4;
    },
    setSprite: function(spriteOffset, position, size, coords, align, verticalAlign, screenMargin) {
        var vertexOffset = spriteOffset * 4;
        var attributes = this.attributes;
        for(var i = 0; i < 4; i++){
            attributes.position.set(vertexOffset + i, position);
        } // 3----2
        // 0----1
        var texcoordAttr = attributes.texcoord;
        texcoordAttr.set(vertexOffset, [
            coords[0][0],
            coords[0][1]
        ]);
        texcoordAttr.set(vertexOffset + 1, [
            coords[1][0],
            coords[0][1]
        ]);
        texcoordAttr.set(vertexOffset + 2, [
            coords[1][0],
            coords[1][1]
        ]);
        texcoordAttr.set(vertexOffset + 3, [
            coords[0][0],
            coords[1][1]
        ]);
        this.setSpriteAlign(spriteOffset, size, align, verticalAlign, screenMargin);
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(SpritesGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = SpritesGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/labels.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.labels.vertex\n\nattribute vec3 position: POSITION;\nattribute vec2 texcoord: TEXCOORD_0;\nattribute vec2 offset;\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n vec4 proj = worldViewProjection * vec4(position, 1.0);\n\n vec2 screen = (proj.xy / abs(proj.w) + 1.0) * 0.5 * viewport.zw;\n\n screen += offset;\n\n proj.xy = (screen / viewport.zw - 0.5) * 2.0 * abs(proj.w);\n gl_Position = proj;\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n v_Texcoord = texcoord;\n}\n@end\n\n\n@export ecgl.labels.fragment\n\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform float alpha : 1.0;\nuniform sampler2D textureAtlas;\nuniform vec2 uvScale: [1.0, 1.0];\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\nvarying float v_Miter;\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n gl_FragColor = vec4(color, alpha) * texture2D(textureAtlas, v_Texcoord * uvScale);\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n#endif\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/util/mesh/LabelsMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Sprites$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Sprites.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$labels$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/labels.glsl.js [app-client] (ecmascript)");
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$labels$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.extend(function() {
    var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Sprites$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        dynamic: true
    });
    var material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
        shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.labels'),
        transparent: true,
        depthMask: false
    });
    return {
        geometry: geometry,
        material: material,
        culling: false,
        castShadow: false,
        ignorePicking: true
    };
});
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DAxis.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Model.js [app-client] (ecmascript) <export default as Model>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/label/labelStyle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/mesh/LabelsMesh.js [app-client] (ecmascript)");
;
;
;
;
;
;
var firstNotNull = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull;
var dimIndicesMap = {
    // Left to right
    x: 0,
    // Far to near
    y: 2,
    // Bottom to up
    z: 1
};
function Grid3DAxis(dim, linesMaterial) {
    var linesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            useNativeLine: false
        }),
        material: linesMaterial,
        castShadow: false,
        ignorePicking: true,
        renderOrder: 2
    });
    var axisLabelsMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    axisLabelsMesh.material.depthMask = false;
    var rootNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
    rootNode.add(linesMesh);
    rootNode.add(axisLabelsMesh);
    this.rootNode = rootNode;
    this.dim = dim;
    this.linesMesh = linesMesh;
    this.labelsMesh = axisLabelsMesh;
    this.axisLineCoords = null;
    this.labelElements = [];
}
var otherDim = {
    x: 'y',
    y: 'x',
    z: 'y'
};
Grid3DAxis.prototype.update = function(grid3DModel, axisLabelSurface, api) {
    var cartesian = grid3DModel.coordinateSystem;
    var axis = cartesian.getAxis(this.dim);
    var linesGeo = this.linesMesh.geometry;
    var labelsGeo = this.labelsMesh.geometry;
    linesGeo.convertToDynamicArray(true);
    labelsGeo.convertToDynamicArray(true);
    var axisModel = axis.model;
    var extent = axis.getExtent();
    var dpr = api.getDevicePixelRatio();
    var axisLineModel = axisModel.getModel('axisLine', grid3DModel.getModel('axisLine'));
    var axisTickModel = axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));
    var axisLabelModel = axisModel.getModel('axisLabel', grid3DModel.getModel('axisLabel'));
    var axisLineColor = axisLineModel.get('lineStyle.color'); // Render axisLine
    if (axisLineModel.get('show')) {
        var axisLineStyleModel = axisLineModel.getModel('lineStyle');
        var p0 = [
            0,
            0,
            0
        ];
        var p1 = [
            0,
            0,
            0
        ];
        var idx = dimIndicesMap[axis.dim];
        p0[idx] = extent[0];
        p1[idx] = extent[1]; // Save some useful info.
        this.axisLineCoords = [
            p0,
            p1
        ];
        var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(axisLineColor);
        var lineWidth = firstNotNull(axisLineStyleModel.get('width'), 1.0);
        var opacity = firstNotNull(axisLineStyleModel.get('opacity'), 1.0);
        color[3] *= opacity;
        linesGeo.addLine(p0, p1, color, lineWidth * dpr);
    } // Render axis ticksCoords
    if (axisTickModel.get('show')) {
        var lineStyleModel = axisTickModel.getModel('lineStyle');
        var lineColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(firstNotNull(lineStyleModel.get('color'), axisLineColor));
        var lineWidth = firstNotNull(lineStyleModel.get('width'), 1.0);
        lineColor[3] *= firstNotNull(lineStyleModel.get('opacity'), 1.0);
        var ticksCoords = axis.getTicksCoords();
        var tickLength = axisTickModel.get('length');
        for(var i = 0; i < ticksCoords.length; i++){
            var tickCoord = ticksCoords[i].coord;
            var p0 = [
                0,
                0,
                0
            ];
            var p1 = [
                0,
                0,
                0
            ];
            var idx = dimIndicesMap[axis.dim];
            var otherIdx = dimIndicesMap[otherDim[axis.dim]]; // 0 : x, 1 : y
            p0[idx] = p1[idx] = tickCoord;
            p1[otherIdx] = tickLength;
            linesGeo.addLine(p0, p1, lineColor, lineWidth * dpr);
        }
    }
    this.labelElements = [];
    var dpr = api.getDevicePixelRatio();
    if (axisLabelModel.get('show')) {
        var ticksCoords = axis.getTicksCoords();
        var categoryData = axisModel.get('data');
        var labelMargin = axisLabelModel.get('margin');
        var labels = axis.getViewLabels();
        for(var i = 0; i < labels.length; i++){
            var tickValue = labels[i].tickValue;
            var formattedLabel = labels[i].formattedLabel;
            var rawLabel = labels[i].rawLabel;
            var tickCoord = axis.dataToCoord(tickValue);
            var p = [
                0,
                0,
                0
            ];
            var idx = dimIndicesMap[axis.dim];
            var otherIdx = dimIndicesMap[otherDim[axis.dim]]; // 0 : x, 1 : y
            p[idx] = p[idx] = tickCoord;
            p[otherIdx] = labelMargin;
            var itemTextStyleModel = axisLabelModel;
            if (categoryData && categoryData[tickValue] && categoryData[tickValue].textStyle) {
                itemTextStyleModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__["Model"](categoryData[tickValue].textStyle, axisLabelModel, axisModel.ecModel);
            }
            var textColor = firstNotNull(itemTextStyleModel.get('color'), axisLineColor);
            var textEl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Text({
                style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextStyle"])(itemTextStyleModel, {
                    text: formattedLabel,
                    fill: typeof textColor === 'function' ? textColor(// index of axis.data. So tick should not be exposed to user
                    // in category axis.
                    // (2) Compatible with previous version, which always returns labelStr.
                    // But in interval scale labelStr is like '223,445', which maked
                    // user repalce ','. So we modify it to return original val but remain
                    // it as 'string' to avoid error in replacing.
                    axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, i) : textColor,
                    verticalAlign: 'top',
                    align: 'left'
                })
            });
            var coords = axisLabelSurface.add(textEl);
            var rect = textEl.getBoundingRect();
            labelsGeo.addSprite(p, [
                rect.width * dpr,
                rect.height * dpr
            ], coords);
            this.labelElements.push(textEl);
        }
    }
    if (axisModel.get('name')) {
        var nameTextStyleModel = axisModel.getModel('nameTextStyle');
        var p = [
            0,
            0,
            0
        ];
        var idx = dimIndicesMap[axis.dim];
        var otherIdx = dimIndicesMap[otherDim[axis.dim]];
        var labelColor = firstNotNull(nameTextStyleModel.get('color'), axisLineColor);
        var strokeColor = nameTextStyleModel.get('borderColor');
        var lineWidth = nameTextStyleModel.get('borderWidth'); // TODO start and end
        p[idx] = p[idx] = (extent[0] + extent[1]) / 2;
        p[otherIdx] = axisModel.get('nameGap');
        var textEl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Text({
            style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextStyle"])(nameTextStyleModel, {
                text: axisModel.get('name'),
                fill: labelColor,
                stroke: strokeColor,
                lineWidth: lineWidth
            })
        });
        var coords = axisLabelSurface.add(textEl);
        var rect = textEl.getBoundingRect();
        labelsGeo.addSprite(p, [
            rect.width * dpr,
            rect.height * dpr
        ], coords);
        textEl.__idx = this.labelElements.length;
        this.nameLabelElement = textEl;
    }
    this.labelsMesh.material.set('textureAtlas', axisLabelSurface.getTexture());
    this.labelsMesh.material.set('uvScale', axisLabelSurface.getCoordsScale());
    linesGeo.convertToTypedArray();
    labelsGeo.convertToTypedArray();
};
Grid3DAxis.prototype.setSpriteAlign = function(textAlign, textVerticalAlign, api) {
    var dpr = api.getDevicePixelRatio();
    var labelGeo = this.labelsMesh.geometry;
    for(var i = 0; i < this.labelElements.length; i++){
        var labelEl = this.labelElements[i];
        var rect = labelEl.getBoundingRect();
        labelGeo.setSpriteAlign(i, [
            rect.width * dpr,
            rect.height * dpr
        ], textAlign, textVerticalAlign);
    } // name label
    var nameLabelEl = this.nameLabelElement;
    if (nameLabelEl) {
        var rect = nameLabelEl.getBoundingRect();
        labelGeo.setSpriteAlign(nameLabelEl.__idx, [
            rect.width * dpr,
            rect.height * dpr
        ], textAlign, textVerticalAlign);
        labelGeo.dirty();
    }
    this.textAlign = textAlign;
    this.textVerticalAlign = textVerticalAlign;
};
const __TURBOPACK__default__export__ = Grid3DAxis;
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/lines3D.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.lines3D.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position: POSITION;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(position, 1.0);\n v_Color = a_Color;\n}\n\n@end\n\n@export ecgl.lines3D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n}\n@end\n\n\n\n@export ecgl.lines3D.clipNear\n\nvec4 clipNear(vec4 p1, vec4 p2) {\n float n = (p1.w - near) / (p1.w - p2.w);\n return vec4(mix(p1.xy, p2.xy, n), -near, near);\n}\n\n@end\n\n@export ecgl.lines3D.expandLine\n#ifdef VERTEX_ANIMATION\n vec4 prevProj = worldViewProjection * vec4(mix(prevPositionPrev, positionPrev, percent), 1.0);\n vec4 currProj = worldViewProjection * vec4(mix(prevPosition, position, percent), 1.0);\n vec4 nextProj = worldViewProjection * vec4(mix(prevPositionNext, positionNext, percent), 1.0);\n#else\n vec4 prevProj = worldViewProjection * vec4(positionPrev, 1.0);\n vec4 currProj = worldViewProjection * vec4(position, 1.0);\n vec4 nextProj = worldViewProjection * vec4(positionNext, 1.0);\n#endif\n\n if (currProj.w < 0.0) {\n if (nextProj.w > 0.0) {\n currProj = clipNear(currProj, nextProj);\n }\n else if (prevProj.w > 0.0) {\n currProj = clipNear(currProj, prevProj);\n }\n }\n\n vec2 prevScreen = (prevProj.xy / abs(prevProj.w) + 1.0) * 0.5 * viewport.zw;\n vec2 currScreen = (currProj.xy / abs(currProj.w) + 1.0) * 0.5 * viewport.zw;\n vec2 nextScreen = (nextProj.xy / abs(nextProj.w) + 1.0) * 0.5 * viewport.zw;\n\n vec2 dir;\n float len = offset;\n if (position == positionPrev) {\n dir = normalize(nextScreen - currScreen);\n }\n else if (position == positionNext) {\n dir = normalize(currScreen - prevScreen);\n }\n else {\n vec2 dirA = normalize(currScreen - prevScreen);\n vec2 dirB = normalize(nextScreen - currScreen);\n\n vec2 tanget = normalize(dirA + dirB);\n\n float miter = 1.0 / max(dot(tanget, dirA), 0.5);\n len *= miter;\n dir = tanget;\n }\n\n dir = vec2(-dir.y, dir.x) * len;\n currScreen += dir;\n\n currProj.xy = (currScreen / viewport.zw - 0.5) * 2.0 * abs(currProj.w);\n@end\n\n\n@export ecgl.meshLines3D.vertex\n\nattribute vec3 position: POSITION;\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float offset;\nattribute vec4 a_Color : COLOR;\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute vec3 prevPositionPrev;\nattribute vec3 prevPositionNext;\nuniform float percent : 1.0;\n#endif\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\nuniform float near : NEAR;\n\nvarying vec4 v_Color;\n\n@import ecgl.common.wireframe.vertexHeader\n\n@import ecgl.lines3D.clipNear\n\nvoid main()\n{\n @import ecgl.lines3D.expandLine\n\n gl_Position = currProj;\n\n v_Color = a_Color;\n\n @import ecgl.common.wireframe.vertexMain\n}\n@end\n\n\n@export ecgl.meshLines3D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO orthographic camera
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Component.js [app-client] (ecmascript) <export default as ComponentView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/number.js [app-client] (ecmascript) <export * as number>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/label/labelStyle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/OrbitControl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ZRTextureAtlasSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/ZRTextureAtlasSurface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DFace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DFace.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DAxis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DAxis.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/mesh/LabelsMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lines3D.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
var firstNotNull = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var dimIndicesMap = {
    // Left to right
    x: 0,
    // Far to near
    y: 2,
    // Bottom to up
    z: 1
};
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__["ComponentView"].extend({
    type: 'grid3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        var FACES = [
            [
                'y',
                'z',
                'x',
                -1,
                'left'
            ],
            [
                'y',
                'z',
                'x',
                1,
                'right'
            ],
            [
                'x',
                'y',
                'z',
                -1,
                'bottom'
            ],
            [
                'x',
                'y',
                'z',
                1,
                'top'
            ],
            [
                'x',
                'z',
                'y',
                -1,
                'far'
            ],
            [
                'x',
                'z',
                'y',
                1,
                'near'
            ]
        ];
        var DIMS = [
            'x',
            'y',
            'z'
        ];
        var quadsMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            // transparent: true,
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.color'),
            depthMask: false,
            transparent: true
        });
        var linesMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            // transparent: true,
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines3D'),
            depthMask: false,
            transparent: true
        });
        quadsMaterial.define('fragment', 'DOUBLE_SIDED');
        quadsMaterial.define('both', 'VERTEX_COLOR');
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            zr: api.getZr()
        });
        this._control.init(); // Save mesh and other infos for each face.
        this._faces = FACES.map(function(faceInfo) {
            var face = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DFace$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](faceInfo, linesMaterial, quadsMaterial);
            this.groupGL.add(face.rootNode);
            return face;
        }, this); // Save mesh and other infos for each axis.
        this._axes = DIMS.map(function(dim) {
            var axis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DAxis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dim, linesMaterial);
            this.groupGL.add(axis.rootNode);
            return axis;
        }, this);
        var dpr = api.getDevicePixelRatio(); // Texture surface for label.
        this._axisLabelSurface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ZRTextureAtlasSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            width: 256,
            height: 256,
            devicePixelRatio: dpr
        });
        this._axisLabelSurface.onupdate = function() {
            api.getZr().refresh();
        };
        this._axisPointerLineMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                useNativeLine: false
            }),
            material: linesMaterial,
            castShadow: false,
            // PENDING
            ignorePicking: true,
            renderOrder: 3
        });
        this.groupGL.add(this._axisPointerLineMesh);
        this._axisPointerLabelsSurface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ZRTextureAtlasSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            width: 128,
            height: 128,
            devicePixelRatio: dpr
        });
        this._axisPointerLabelsMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            ignorePicking: true,
            renderOrder: 4,
            castShadow: false
        });
        this._axisPointerLabelsMesh.material.set('textureAtlas', this._axisPointerLabelsSurface.getTexture());
        this.groupGL.add(this._axisPointerLabelsMesh);
        this._lightRoot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._sceneHelper.initLight(this._lightRoot);
    },
    render: function(grid3DModel, ecModel, api) {
        this._model = grid3DModel;
        this._api = api;
        var cartesian = grid3DModel.coordinateSystem; // Always have light.
        cartesian.viewGL.add(this._lightRoot);
        if (grid3DModel.get('show')) {
            cartesian.viewGL.add(this.groupGL);
        } else {
            cartesian.viewGL.remove(this.groupGL);
        } // cartesian.viewGL.setCameraType(grid3DModel.get('viewControl.projection'));
        var control = this._control;
        control.setViewGL(cartesian.viewGL);
        var viewControlModel = grid3DModel.getModel('viewControl');
        control.setFromViewControlModel(viewControlModel, 0);
        this._axisLabelSurface.clear();
        control.off('update');
        if (grid3DModel.get('show')) {
            this._faces.forEach(function(face) {
                face.update(grid3DModel, ecModel, api);
            }, this);
            this._axes.forEach(function(axis) {
                axis.update(grid3DModel, this._axisLabelSurface, api);
            }, this);
        }
        control.on('update', this._onCameraChange.bind(this, grid3DModel, api), this);
        this._sceneHelper.setScene(cartesian.viewGL.scene);
        this._sceneHelper.updateLight(grid3DModel); // Set post effect
        cartesian.viewGL.setPostEffect(grid3DModel.getModel('postEffect'), api);
        cartesian.viewGL.setTemporalSuperSampling(grid3DModel.getModel('temporalSuperSampling'));
        this._initMouseHandler(grid3DModel);
    },
    afterRender: function(grid3DModel, ecModel, api, layerGL) {
        // Create ambient cubemap after render because we need to know the renderer.
        // TODO
        var renderer = layerGL.renderer;
        this._sceneHelper.updateAmbientCubemap(renderer, grid3DModel, api);
        this._sceneHelper.updateSkybox(renderer, grid3DModel, api);
    },
    /**
   * showAxisPointer will be triggered by action.
   */ showAxisPointer: function(grid3dModel, ecModel, api, payload) {
        this._doShowAxisPointer();
        this._updateAxisPointer(payload.value);
    },
    /**
   * hideAxisPointer will be triggered by action.
   */ hideAxisPointer: function(grid3dModel, ecModel, api, payload) {
        this._doHideAxisPointer();
    },
    _initMouseHandler: function(grid3DModel) {
        var cartesian = grid3DModel.coordinateSystem;
        var viewGL = cartesian.viewGL; // TODO xAxis3D.axisPointer.show ?
        if (grid3DModel.get('show') && grid3DModel.get('axisPointer.show')) {
            viewGL.on('mousemove', this._updateAxisPointerOnMousePosition, this);
        } else {
            viewGL.off('mousemove', this._updateAxisPointerOnMousePosition);
        }
    },
    /**
   * Try find and show axisPointer on the intersect point
   * of mouse ray with grid plane.
   */ _updateAxisPointerOnMousePosition: function(e) {
        // Ignore if mouse is on the element.
        if (e.target) {
            return;
        }
        var grid3DModel = this._model;
        var cartesian = grid3DModel.coordinateSystem;
        var viewGL = cartesian.viewGL;
        var ray = viewGL.castRay(e.offsetX, e.offsetY, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Ray());
        var nearestIntersectPoint;
        for(var i = 0; i < this._faces.length; i++){
            var face = this._faces[i];
            if (face.rootNode.invisible) {
                continue;
            } // Plane is not face the camera. flip it
            if (face.plane.normal.dot(viewGL.camera.worldTransform.z) < 0) {
                face.plane.normal.negate();
            }
            var point = ray.intersectPlane(face.plane);
            if (!point) {
                continue;
            }
            var axis0 = cartesian.getAxis(face.faceInfo[0]);
            var axis1 = cartesian.getAxis(face.faceInfo[1]);
            var idx0 = dimIndicesMap[face.faceInfo[0]];
            var idx1 = dimIndicesMap[face.faceInfo[1]];
            if (axis0.contain(point.array[idx0]) && axis1.contain(point.array[idx1])) {
                nearestIntersectPoint = point;
            }
        }
        if (nearestIntersectPoint) {
            var data = cartesian.pointToData(nearestIntersectPoint.array, [], true);
            this._updateAxisPointer(data);
            this._doShowAxisPointer();
        } else {
            this._doHideAxisPointer();
        }
    },
    _onCameraChange: function(grid3DModel, api) {
        if (grid3DModel.get('show')) {
            this._updateFaceVisibility();
            this._updateAxisLinePosition();
        }
        var control = this._control;
        api.dispatchAction({
            type: 'grid3DChangeCamera',
            alpha: control.getAlpha(),
            beta: control.getBeta(),
            distance: control.getDistance(),
            center: control.getCenter(),
            from: this.uid,
            grid3DId: grid3DModel.id
        });
    },
    /**
   * Update visibility of each face when camera view changed, front face will be invisible.
   * @private
   */ _updateFaceVisibility: function() {
        var camera = this._control.getCamera();
        var viewSpacePos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3();
        camera.update();
        for(var idx = 0; idx < this._faces.length / 2; idx++){
            var depths = [];
            for(var k = 0; k < 2; k++){
                var face = this._faces[idx * 2 + k];
                face.rootNode.getWorldPosition(viewSpacePos);
                viewSpacePos.transformMat4(camera.viewMatrix);
                depths[k] = viewSpacePos.z;
            } // Set the front face invisible
            var frontIndex = depths[0] > depths[1] ? 0 : 1;
            var frontFace = this._faces[idx * 2 + frontIndex];
            var backFace = this._faces[idx * 2 + 1 - frontIndex]; // Update rotation.
            frontFace.rootNode.invisible = true;
            backFace.rootNode.invisible = false;
        }
    },
    /**
   * Update axis line position when camera view changed.
   * @private
   */ _updateAxisLinePosition: function() {
        // Put xAxis, yAxis on x, y visible plane.
        // Put zAxis on the left.
        // TODO
        var cartesian = this._model.coordinateSystem;
        var xAxis = cartesian.getAxis('x');
        var yAxis = cartesian.getAxis('y');
        var zAxis = cartesian.getAxis('z');
        var top = zAxis.getExtentMax();
        var bottom = zAxis.getExtentMin();
        var left = xAxis.getExtentMin();
        var right = xAxis.getExtentMax();
        var near = yAxis.getExtentMax();
        var far = yAxis.getExtentMin();
        var xAxisNode = this._axes[0].rootNode;
        var yAxisNode = this._axes[1].rootNode;
        var zAxisNode = this._axes[2].rootNode;
        var faces = this._faces; // Notice: in cartesian up axis is z, but in webgl up axis is y.
        var xAxisZOffset = faces[4].rootNode.invisible ? far : near;
        var xAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
        var yAxisXOffset = faces[0].rootNode.invisible ? left : right;
        var yAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
        var zAxisXOffset = faces[0].rootNode.invisible ? right : left;
        var zAxisZOffset = faces[4].rootNode.invisible ? far : near;
        xAxisNode.rotation.identity();
        yAxisNode.rotation.identity();
        zAxisNode.rotation.identity();
        if (faces[4].rootNode.invisible) {
            this._axes[0].flipped = true;
            xAxisNode.rotation.rotateX(Math.PI);
        }
        if (faces[0].rootNode.invisible) {
            this._axes[1].flipped = true;
            yAxisNode.rotation.rotateZ(Math.PI);
        }
        if (faces[4].rootNode.invisible) {
            this._axes[2].flipped = true;
            zAxisNode.rotation.rotateY(Math.PI);
        }
        xAxisNode.position.set(0, xAxisYOffset, xAxisZOffset);
        yAxisNode.position.set(yAxisXOffset, yAxisYOffset, 0); // Actually z
        zAxisNode.position.set(zAxisXOffset, 0, zAxisZOffset); // Actually y
        xAxisNode.update();
        yAxisNode.update();
        zAxisNode.update();
        this._updateAxisLabelAlign();
    },
    /**
   * Update label align on axis when axisLine position changed.
   * @private
   */ _updateAxisLabelAlign: function() {
        // var cartesian = this._model.coordinateSystem;
        var camera = this._control.getCamera();
        var coords = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector4(),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector4()
        ];
        var center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector4();
        this.groupGL.getWorldPosition(center);
        center.w = 1.0;
        center.transformMat4(camera.viewMatrix).transformMat4(camera.projectionMatrix);
        center.x /= center.w;
        center.y /= center.w;
        this._axes.forEach(function(axisInfo) {
            var lineCoords = axisInfo.axisLineCoords;
            var labelGeo = axisInfo.labelsMesh.geometry;
            for(var i = 0; i < coords.length; i++){
                coords[i].setArray(lineCoords[i]);
                coords[i].w = 1.0;
                coords[i].transformMat4(axisInfo.rootNode.worldTransform).transformMat4(camera.viewMatrix).transformMat4(camera.projectionMatrix);
                coords[i].x /= coords[i].w;
                coords[i].y /= coords[i].w;
            }
            var dx = coords[1].x - coords[0].x;
            var dy = coords[1].y - coords[0].y;
            var cx = (coords[1].x + coords[0].x) / 2;
            var cy = (coords[1].y + coords[0].y) / 2;
            var textAlign;
            var verticalAlign;
            if (Math.abs(dy / dx) < 0.5) {
                textAlign = 'center';
                verticalAlign = cy > center.y ? 'bottom' : 'top';
            } else {
                verticalAlign = 'middle';
                textAlign = cx > center.x ? 'left' : 'right';
            } // axis labels
            axisInfo.setSpriteAlign(textAlign, verticalAlign, this._api);
        }, this);
    },
    _doShowAxisPointer: function() {
        if (!this._axisPointerLineMesh.invisible) {
            return;
        }
        this._axisPointerLineMesh.invisible = false;
        this._axisPointerLabelsMesh.invisible = false;
        this._api.getZr().refresh();
    },
    _doHideAxisPointer: function() {
        if (this._axisPointerLineMesh.invisible) {
            return;
        }
        this._axisPointerLineMesh.invisible = true;
        this._axisPointerLabelsMesh.invisible = true;
        this._api.getZr().refresh();
    },
    /**
   * @private updateAxisPointer.
   */ _updateAxisPointer: function(data) {
        var cartesian = this._model.coordinateSystem;
        var point = cartesian.dataToPoint(data);
        var axisPointerLineMesh = this._axisPointerLineMesh;
        var linesGeo = axisPointerLineMesh.geometry;
        var axisPointerParentModel = this._model.getModel('axisPointer');
        var dpr = this._api.getDevicePixelRatio();
        linesGeo.convertToDynamicArray(true);
        function ifShowAxisPointer(axis) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(axis.model.get('axisPointer.show'), axisPointerParentModel.get('show'));
        }
        function getAxisColorAndLineWidth(axis) {
            var axisPointerModel = axis.model.getModel('axisPointer', axisPointerParentModel);
            var lineStyleModel = axisPointerModel.getModel('lineStyle');
            var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(lineStyleModel.get('color'));
            var lineWidth = firstNotNull(lineStyleModel.get('width'), 1);
            var opacity = firstNotNull(lineStyleModel.get('opacity'), 1);
            color[3] *= opacity;
            return {
                color: color,
                lineWidth: lineWidth
            };
        }
        for(var k = 0; k < this._faces.length; k++){
            var face = this._faces[k];
            if (face.rootNode.invisible) {
                continue;
            }
            var faceInfo = face.faceInfo;
            var otherCoord = faceInfo[3] < 0 ? cartesian.getAxis(faceInfo[2]).getExtentMin() : cartesian.getAxis(faceInfo[2]).getExtentMax();
            var otherDimIdx = dimIndicesMap[faceInfo[2]]; // Line on face.
            for(var i = 0; i < 2; i++){
                var dim = faceInfo[i];
                var faceOtherDim = faceInfo[1 - i];
                var axis = cartesian.getAxis(dim);
                var faceOtherAxis = cartesian.getAxis(faceOtherDim);
                if (!ifShowAxisPointer(axis)) {
                    continue;
                }
                var p0 = [
                    0,
                    0,
                    0
                ];
                var p1 = [
                    0,
                    0,
                    0
                ];
                var dimIdx = dimIndicesMap[dim];
                var faceOtherDimIdx = dimIndicesMap[faceOtherDim];
                p0[dimIdx] = p1[dimIdx] = point[dimIdx];
                p0[otherDimIdx] = p1[otherDimIdx] = otherCoord;
                p0[faceOtherDimIdx] = faceOtherAxis.getExtentMin();
                p1[faceOtherDimIdx] = faceOtherAxis.getExtentMax();
                var colorAndLineWidth = getAxisColorAndLineWidth(axis);
                linesGeo.addLine(p0, p1, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr);
            } // Project line.
            if (ifShowAxisPointer(cartesian.getAxis(faceInfo[2]))) {
                var p0 = point.slice();
                var p1 = point.slice();
                p1[otherDimIdx] = otherCoord;
                var colorAndLineWidth = getAxisColorAndLineWidth(cartesian.getAxis(faceInfo[2]));
                linesGeo.addLine(p0, p1, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr);
            }
        }
        linesGeo.convertToTypedArray();
        this._updateAxisPointerLabelsMesh(data);
        this._api.getZr().refresh();
    },
    _updateAxisPointerLabelsMesh: function(data) {
        var grid3dModel = this._model;
        var axisPointerLabelsMesh = this._axisPointerLabelsMesh;
        var axisPointerLabelsSurface = this._axisPointerLabelsSurface;
        var cartesian = grid3dModel.coordinateSystem;
        var axisPointerParentModel = grid3dModel.getModel('axisPointer');
        axisPointerLabelsMesh.geometry.convertToDynamicArray(true);
        axisPointerLabelsSurface.clear();
        var otherDim = {
            x: 'y',
            y: 'x',
            z: 'y'
        };
        this._axes.forEach(function(axisInfo, idx) {
            var axis = cartesian.getAxis(axisInfo.dim);
            var axisModel = axis.model;
            var axisPointerModel = axisModel.getModel('axisPointer', axisPointerParentModel);
            var labelModel = axisPointerModel.getModel('label');
            var lineColor = axisPointerModel.get('lineStyle.color');
            if (!labelModel.get('show') || !axisPointerModel.get('show')) {
                return;
            }
            var val = data[idx];
            var formatter = labelModel.get('formatter');
            var text = axis.scale.getLabel({
                value: val
            });
            if (formatter != null) {
                text = formatter(text, data);
            } else {
                if (axis.scale.type === 'interval' || axis.scale.type === 'log') {
                    var precision = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].getPrecisionSafe(axis.scale.getTicks()[0]);
                    text = val.toFixed(precision + 2);
                }
            }
            var labelColor = labelModel.get('color');
            var textEl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Text({
                style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextStyle"])(labelModel, {
                    text: text,
                    fill: labelColor || lineColor,
                    align: 'left',
                    verticalAlign: 'top'
                })
            });
            var coords = axisPointerLabelsSurface.add(textEl);
            var rect = textEl.getBoundingRect();
            var dpr = this._api.getDevicePixelRatio();
            var pos = axisInfo.rootNode.position.toArray();
            var otherIdx = dimIndicesMap[otherDim[axisInfo.dim]];
            pos[otherIdx] += (axisInfo.flipped ? -1 : 1) * labelModel.get('margin');
            pos[dimIndicesMap[axisInfo.dim]] = axis.dataToCoord(data[idx]);
            axisPointerLabelsMesh.geometry.addSprite(pos, [
                rect.width * dpr,
                rect.height * dpr
            ], coords, axisInfo.textAlign, axisInfo.textVerticalAlign);
        }, this);
        axisPointerLabelsSurface.getZr().refreshImmediately();
        axisPointerLabelsMesh.material.set('uvScale', axisPointerLabelsSurface.getCoordsScale());
        axisPointerLabelsMesh.geometry.convertToTypedArray();
    },
    dispose: function() {
        this.groupGL.removeAll();
        this._control.dispose();
        this._axisLabelSurface.dispose();
        this._axisPointerLabelsSurface.dispose();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/coord/grid3D/Cartesian3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$cartesian$2f$Cartesian$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/cartesian/Cartesian.js [app-client] (ecmascript)");
;
;
function Cartesian3D(name) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$cartesian$2f$Cartesian$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].call(this, name);
    this.type = 'cartesian3D';
    this.dimensions = [
        'x',
        'y',
        'z'
    ];
    this.size = [
        0,
        0,
        0
    ];
}
Cartesian3D.prototype = {
    constructor: Cartesian3D,
    model: null,
    containPoint: function(point) {
        return this.getAxis('x').contain(point[0]) && this.getAxis('y').contain(point[2]) && this.getAxis('z').contain(point[1]);
    },
    containData: function(data) {
        return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]) && this.getAxis('z').containData(data[2]);
    },
    dataToPoint: function(data, out, clamp) {
        out = out || [];
        out[0] = this.getAxis('x').dataToCoord(data[0], clamp);
        out[2] = this.getAxis('y').dataToCoord(data[1], clamp);
        out[1] = this.getAxis('z').dataToCoord(data[2], clamp);
        return out;
    },
    pointToData: function(point, out, clamp) {
        out = out || [];
        out[0] = this.getAxis('x').coordToData(point[0], clamp);
        out[1] = this.getAxis('y').coordToData(point[2], clamp);
        out[2] = this.getAxis('z').coordToData(point[1], clamp);
        return out;
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].inherits(Cartesian3D, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$cartesian$2f$Cartesian$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Cartesian3D;
}}),
"[project]/node_modules/echarts-gl/lib/coord/grid3D/Axis3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/Axis.js [app-client] (ecmascript) <export default as Axis>");
;
function Axis3D(dim, scale, extent) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__["Axis"].call(this, dim, scale, extent);
}
Axis3D.prototype = {
    constructor: Axis3D,
    getExtentMin: function() {
        var extent = this._extent;
        return Math.min(extent[0], extent[1]);
    },
    getExtentMax: function() {
        var extent = this._extent;
        return Math.max(extent[0], extent[1]);
    },
    calculateCategoryInterval: function() {
        // TODO consider label length
        return Math.floor(this.scale.count() / 8);
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].inherits(Axis3D, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__["Axis"]);
const __TURBOPACK__default__export__ = Axis3D;
}}),
"[project]/node_modules/echarts-gl/lib/effect/halton.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Generate halton sequence
// https://en.wikipedia.org/wiki/Halton_sequence
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function halton(index, base) {
    var result = 0;
    var f = 1 / base;
    var i = index;
    while(i > 0){
        result = result + f * (i % base);
        i = Math.floor(i / base);
        f = f / base;
    }
    return result;
}
const __TURBOPACK__default__export__ = halton;
}}),
"[project]/node_modules/echarts-gl/lib/effect/SSAO.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.ssao.estimate\n\nuniform sampler2D depthTex;\n\nuniform sampler2D normalTex;\n\nuniform sampler2D noiseTex;\n\nuniform vec2 depthTexSize;\n\nuniform vec2 noiseTexSize;\n\nuniform mat4 projection;\n\nuniform mat4 projectionInv;\n\nuniform mat4 viewInverseTranspose;\n\nuniform vec3 kernel[KERNEL_SIZE];\n\nuniform float radius : 1;\n\nuniform float power : 1;\n\nuniform float bias: 1e-2;\n\nuniform float intensity: 1.0;\n\nvarying vec2 v_Texcoord;\n\nfloat ssaoEstimator(in vec3 originPos, in mat3 kernelBasis) {\n float occlusion = 0.0;\n\n for (int i = 0; i < KERNEL_SIZE; i++) {\n vec3 samplePos = kernel[i];\n#ifdef NORMALTEX_ENABLED\n samplePos = kernelBasis * samplePos;\n#endif\n samplePos = samplePos * radius + originPos;\n\n vec4 texCoord = projection * vec4(samplePos, 1.0);\n texCoord.xy /= texCoord.w;\n\n vec4 depthTexel = texture2D(depthTex, texCoord.xy * 0.5 + 0.5);\n\n float sampleDepth = depthTexel.r * 2.0 - 1.0;\n if (projection[3][3] == 0.0) {\n sampleDepth = projection[3][2] / (sampleDepth * projection[2][3] - projection[2][2]);\n }\n else {\n sampleDepth = (sampleDepth - projection[3][2]) / projection[2][2];\n }\n \n float rangeCheck = smoothstep(0.0, 1.0, radius / abs(originPos.z - sampleDepth));\n occlusion += rangeCheck * step(samplePos.z, sampleDepth - bias);\n }\n#ifdef NORMALTEX_ENABLED\n occlusion = 1.0 - occlusion / float(KERNEL_SIZE);\n#else\n occlusion = 1.0 - clamp((occlusion / float(KERNEL_SIZE) - 0.6) * 2.5, 0.0, 1.0);\n#endif\n return pow(occlusion, power);\n}\n\nvoid main()\n{\n\n vec4 depthTexel = texture2D(depthTex, v_Texcoord);\n\n#ifdef NORMALTEX_ENABLED\n vec4 tex = texture2D(normalTex, v_Texcoord);\n if (dot(tex.rgb, tex.rgb) == 0.0) {\n gl_FragColor = vec4(1.0);\n return;\n }\n vec3 N = tex.rgb * 2.0 - 1.0;\n N = (viewInverseTranspose * vec4(N, 0.0)).xyz;\n\n vec2 noiseTexCoord = depthTexSize / vec2(noiseTexSize) * v_Texcoord;\n vec3 rvec = texture2D(noiseTex, noiseTexCoord).rgb * 2.0 - 1.0;\n vec3 T = normalize(rvec - N * dot(rvec, N));\n vec3 BT = normalize(cross(N, T));\n mat3 kernelBasis = mat3(T, BT, N);\n#else\n if (depthTexel.r > 0.99999) {\n gl_FragColor = vec4(1.0);\n return;\n }\n mat3 kernelBasis;\n#endif\n\n float z = depthTexel.r * 2.0 - 1.0;\n\n vec4 projectedPos = vec4(v_Texcoord * 2.0 - 1.0, z, 1.0);\n vec4 p4 = projectionInv * projectedPos;\n\n vec3 position = p4.xyz / p4.w;\n\n float ao = ssaoEstimator(position, kernelBasis);\n ao = clamp(1.0 - (1.0 - ao) * intensity, 0.0, 1.0);\n gl_FragColor = vec4(vec3(ao), 1.0);\n}\n\n@end\n\n\n@export ecgl.ssao.blur\n#define SHADER_NAME SSAO_BLUR\n\nuniform sampler2D ssaoTexture;\n\n#ifdef NORMALTEX_ENABLED\nuniform sampler2D normalTex;\n#endif\n\nvarying vec2 v_Texcoord;\n\nuniform vec2 textureSize;\nuniform float blurSize : 1.0;\n\nuniform int direction: 0.0;\n\n#ifdef DEPTHTEX_ENABLED\nuniform sampler2D depthTex;\nuniform mat4 projection;\nuniform float depthRange : 0.5;\n\nfloat getLinearDepth(vec2 coord)\n{\n float depth = texture2D(depthTex, coord).r * 2.0 - 1.0;\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n}\n#endif\n\nvoid main()\n{\n float kernel[5];\n kernel[0] = 0.122581;\n kernel[1] = 0.233062;\n kernel[2] = 0.288713;\n kernel[3] = 0.233062;\n kernel[4] = 0.122581;\n\n vec2 off = vec2(0.0);\n if (direction == 0) {\n off[0] = blurSize / textureSize.x;\n }\n else {\n off[1] = blurSize / textureSize.y;\n }\n\n vec2 coord = v_Texcoord;\n\n float sum = 0.0;\n float weightAll = 0.0;\n\n#ifdef NORMALTEX_ENABLED\n vec3 centerNormal = texture2D(normalTex, v_Texcoord).rgb * 2.0 - 1.0;\n#endif\n#if defined(DEPTHTEX_ENABLED)\n float centerDepth = getLinearDepth(v_Texcoord);\n#endif\n\n for (int i = 0; i < 5; i++) {\n vec2 coord = clamp(v_Texcoord + vec2(float(i) - 2.0) * off, vec2(0.0), vec2(1.0));\n\n float w = kernel[i];\n#ifdef NORMALTEX_ENABLED\n vec3 normal = texture2D(normalTex, coord).rgb * 2.0 - 1.0;\n w *= clamp(dot(normal, centerNormal), 0.0, 1.0);\n#endif\n#ifdef DEPTHTEX_ENABLED\n float d = getLinearDepth(coord);\n w *= (1.0 - smoothstep(abs(centerDepth - d) / depthRange, 0.0, 1.0));\n#endif\n\n weightAll += w;\n sum += texture2D(ssaoTexture, coord).r * w;\n }\n\n gl_FragColor = vec4(vec3(sum / weightAll), 1.0);\n}\n\n@end\n";
}}),
"[project]/node_modules/echarts-gl/lib/effect/SSAOPass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/halton.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSAO$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/SSAO.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSAO$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function generateNoiseData(size) {
    var data = new Uint8Array(size * size * 4);
    var n = 0;
    var v3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    for(var i = 0; i < size; i++){
        for(var j = 0; j < size; j++){
            v3.set(Math.random() * 2 - 1, Math.random() * 2 - 1, 0).normalize();
            data[n++] = (v3.x * 0.5 + 0.5) * 255;
            data[n++] = (v3.y * 0.5 + 0.5) * 255;
            data[n++] = 0;
            data[n++] = 255;
        }
    }
    return data;
}
function generateNoiseTexture(size) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        pixels: generateNoiseData(size),
        wrapS: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPEAT,
        wrapT: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REPEAT,
        width: size,
        height: size
    });
}
function generateKernel(size, offset, hemisphere) {
    var kernel = new Float32Array(size * 3);
    offset = offset || 0;
    for(var i = 0; i < size; i++){
        var phi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i + offset, 2) * (hemisphere ? 1 : 2) * Math.PI;
        var theta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i + offset, 3) * Math.PI;
        var r = Math.random();
        var x = Math.cos(phi) * Math.sin(theta) * r;
        var y = Math.cos(theta) * r;
        var z = Math.sin(phi) * Math.sin(theta) * r;
        kernel[i * 3] = x;
        kernel[i * 3 + 1] = y;
        kernel[i * 3 + 2] = z;
    }
    return kernel; // var kernel = new Float32Array(size * 3);
// var v3 = new Vector3();
// for (var i = 0; i < size; i++) {
//     v3.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random())
//         .normalize().scale(Math.random());
//     kernel[i * 3] = v3.x;
//     kernel[i * 3 + 1] = v3.y;
//     kernel[i * 3 + 2] = v3.z;
// }
// return kernel;
}
function SSAOPass(opt) {
    opt = opt || {};
    this._ssaoPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.ssao.estimate')
    });
    this._blurPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.ssao.blur')
    });
    this._framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        depthBuffer: false
    });
    this._ssaoTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._blurTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._blurTexture2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._depthTex = opt.depthTexture;
    this._normalTex = opt.normalTexture;
    this.setNoiseSize(4);
    this.setKernelSize(opt.kernelSize || 12);
    if (opt.radius != null) {
        this.setParameter('radius', opt.radius);
    }
    if (opt.power != null) {
        this.setParameter('power', opt.power);
    }
    if (!this._normalTex) {
        this._ssaoPass.material.disableTexture('normalTex');
        this._blurPass.material.disableTexture('normalTex');
    }
    if (!this._depthTex) {
        this._blurPass.material.disableTexture('depthTex');
    }
    this._blurPass.material.setUniform('normalTex', this._normalTex);
    this._blurPass.material.setUniform('depthTex', this._depthTex);
}
SSAOPass.prototype.setDepthTexture = function(depthTex) {
    this._depthTex = depthTex;
};
SSAOPass.prototype.setNormalTexture = function(normalTex) {
    this._normalTex = normalTex;
    this._ssaoPass.material[normalTex ? 'enableTexture' : 'disableTexture']('normalTex'); // Switch between hemisphere and shere kernel.
    this.setKernelSize(this._kernelSize);
};
SSAOPass.prototype.update = function(renderer, camera, frame) {
    var width = renderer.getWidth();
    var height = renderer.getHeight();
    var ssaoPass = this._ssaoPass;
    var blurPass = this._blurPass;
    ssaoPass.setUniform('kernel', this._kernels[frame % this._kernels.length]);
    ssaoPass.setUniform('depthTex', this._depthTex);
    if (this._normalTex != null) {
        ssaoPass.setUniform('normalTex', this._normalTex);
    }
    ssaoPass.setUniform('depthTexSize', [
        this._depthTex.width,
        this._depthTex.height
    ]);
    var viewInverseTranspose = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(viewInverseTranspose, camera.worldTransform);
    ssaoPass.setUniform('projection', camera.projectionMatrix.array);
    ssaoPass.setUniform('projectionInv', camera.invProjectionMatrix.array);
    ssaoPass.setUniform('viewInverseTranspose', viewInverseTranspose.array);
    var ssaoTexture = this._ssaoTexture;
    var blurTexture = this._blurTexture;
    var blurTexture2 = this._blurTexture2;
    ssaoTexture.width = width / 2;
    ssaoTexture.height = height / 2;
    blurTexture.width = width;
    blurTexture.height = height;
    blurTexture2.width = width;
    blurTexture2.height = height;
    this._framebuffer.attach(ssaoTexture);
    this._framebuffer.bind(renderer);
    renderer.gl.clearColor(1, 1, 1, 1);
    renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
    ssaoPass.render(renderer);
    blurPass.setUniform('textureSize', [
        width / 2,
        height / 2
    ]);
    blurPass.setUniform('projection', camera.projectionMatrix.array);
    this._framebuffer.attach(blurTexture);
    blurPass.setUniform('direction', 0);
    blurPass.setUniform('ssaoTexture', ssaoTexture);
    blurPass.render(renderer);
    this._framebuffer.attach(blurTexture2);
    blurPass.setUniform('textureSize', [
        width,
        height
    ]);
    blurPass.setUniform('direction', 1);
    blurPass.setUniform('ssaoTexture', blurTexture);
    blurPass.render(renderer);
    this._framebuffer.unbind(renderer); // Restore clear
    var clearColor = renderer.clearColor;
    renderer.gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
};
SSAOPass.prototype.getTargetTexture = function() {
    return this._blurTexture2;
};
SSAOPass.prototype.setParameter = function(name, val) {
    if (name === 'noiseTexSize') {
        this.setNoiseSize(val);
    } else if (name === 'kernelSize') {
        this.setKernelSize(val);
    } else if (name === 'intensity') {
        this._ssaoPass.material.set('intensity', val);
    } else {
        this._ssaoPass.setUniform(name, val);
    }
};
SSAOPass.prototype.setKernelSize = function(size) {
    this._kernelSize = size;
    this._ssaoPass.material.define('fragment', 'KERNEL_SIZE', size);
    this._kernels = this._kernels || [];
    for(var i = 0; i < 30; i++){
        this._kernels[i] = generateKernel(size, i * size, !!this._normalTex);
    }
};
SSAOPass.prototype.setNoiseSize = function(size) {
    var texture = this._ssaoPass.getUniform('noiseTex');
    if (!texture) {
        texture = generateNoiseTexture(size);
        this._ssaoPass.setUniform('noiseTex', generateNoiseTexture(size));
    } else {
        texture.data = generateNoiseData(size);
        texture.width = texture.height = size;
        texture.dirty();
    }
    this._ssaoPass.setUniform('noiseTexSize', [
        size,
        size
    ]);
};
SSAOPass.prototype.dispose = function(renderer) {
    this._blurTexture.dispose(renderer);
    this._ssaoTexture.dispose(renderer);
    this._blurTexture2.dispose(renderer);
};
const __TURBOPACK__default__export__ = SSAOPass;
}}),
"[project]/node_modules/echarts-gl/lib/effect/SSR.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.ssr.main\n\n#define SHADER_NAME SSR\n#define MAX_ITERATION 20;\n#define SAMPLE_PER_FRAME 5;\n#define TOTAL_SAMPLES 128;\n\nuniform sampler2D sourceTexture;\nuniform sampler2D gBufferTexture1;\nuniform sampler2D gBufferTexture2;\nuniform sampler2D gBufferTexture3;\nuniform samplerCube specularCubemap;\nuniform float specularIntensity: 1;\n\nuniform mat4 projection;\nuniform mat4 projectionInv;\nuniform mat4 toViewSpace;\nuniform mat4 toWorldSpace;\n\nuniform float maxRayDistance: 200;\n\nuniform float pixelStride: 16;\nuniform float pixelStrideZCutoff: 50; \nuniform float screenEdgeFadeStart: 0.9; \nuniform float eyeFadeStart : 0.2; uniform float eyeFadeEnd: 0.8; \nuniform float minGlossiness: 0.2; uniform float zThicknessThreshold: 1;\n\nuniform float nearZ;\nuniform vec2 viewportSize : VIEWPORT_SIZE;\n\nuniform float jitterOffset: 0;\n\nvarying vec2 v_Texcoord;\n\n#ifdef DEPTH_DECODE\n@import clay.util.decode_float\n#endif\n\n#ifdef PHYSICALLY_CORRECT\nuniform sampler2D normalDistribution;\nuniform float sampleOffset: 0;\nuniform vec2 normalDistributionSize;\n\nvec3 transformNormal(vec3 H, vec3 N) {\n vec3 upVector = N.y > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n vec3 tangentX = normalize(cross(N, upVector));\n vec3 tangentZ = cross(N, tangentX);\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\n}\nvec3 importanceSampleNormalGGX(float i, float roughness, vec3 N) {\n float p = fract((i + sampleOffset) / float(TOTAL_SAMPLES));\n vec3 H = texture2D(normalDistribution,vec2(roughness, p)).rgb;\n return transformNormal(H, N);\n}\nfloat G_Smith(float g, float ndv, float ndl) {\n float roughness = 1.0 - g;\n float k = roughness * roughness / 2.0;\n float G1V = ndv / (ndv * (1.0 - k) + k);\n float G1L = ndl / (ndl * (1.0 - k) + k);\n return G1L * G1V;\n}\nvec3 F_Schlick(float ndv, vec3 spec) {\n return spec + (1.0 - spec) * pow(1.0 - ndv, 5.0);\n}\n#endif\n\nfloat fetchDepth(sampler2D depthTexture, vec2 uv)\n{\n vec4 depthTexel = texture2D(depthTexture, uv);\n return depthTexel.r * 2.0 - 1.0;\n}\n\nfloat linearDepth(float depth)\n{\n if (projection[3][3] == 0.0) {\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n }\n else {\n return (depth - projection[3][2]) / projection[2][2];\n }\n}\n\nbool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel)\n{\n if (rayZFar > rayZNear)\n {\n float t = rayZFar; rayZFar = rayZNear; rayZNear = t;\n }\n float cameraZ = linearDepth(fetchDepth(gBufferTexture2, hitPixel));\n return rayZFar <= cameraZ && rayZNear >= cameraZ - zThicknessThreshold;\n}\n\n\nbool traceScreenSpaceRay(\n vec3 rayOrigin, vec3 rayDir, float jitter,\n out vec2 hitPixel, out vec3 hitPoint, out float iterationCount\n)\n{\n float rayLength = ((rayOrigin.z + rayDir.z * maxRayDistance) > -nearZ)\n ? (-nearZ - rayOrigin.z) / rayDir.z : maxRayDistance;\n\n vec3 rayEnd = rayOrigin + rayDir * rayLength;\n\n vec4 H0 = projection * vec4(rayOrigin, 1.0);\n vec4 H1 = projection * vec4(rayEnd, 1.0);\n\n float k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\n\n vec3 Q0 = rayOrigin * k0, Q1 = rayEnd * k1;\n\n vec2 P0 = (H0.xy * k0 * 0.5 + 0.5) * viewportSize;\n vec2 P1 = (H1.xy * k1 * 0.5 + 0.5) * viewportSize;\n\n P1 += dot(P1 - P0, P1 - P0) < 0.0001 ? 0.01 : 0.0;\n vec2 delta = P1 - P0;\n\n bool permute = false;\n if (abs(delta.x) < abs(delta.y)) {\n permute = true;\n delta = delta.yx;\n P0 = P0.yx;\n P1 = P1.yx;\n }\n float stepDir = sign(delta.x);\n float invdx = stepDir / delta.x;\n\n vec3 dQ = (Q1 - Q0) * invdx;\n float dk = (k1 - k0) * invdx;\n\n vec2 dP = vec2(stepDir, delta.y * invdx);\n\n float strideScaler = 1.0 - min(1.0, -rayOrigin.z / pixelStrideZCutoff);\n float pixStride = 1.0 + strideScaler * pixelStride;\n\n dP *= pixStride; dQ *= pixStride; dk *= pixStride;\n\n vec4 pqk = vec4(P0, Q0.z, k0);\n vec4 dPQK = vec4(dP, dQ.z, dk);\n\n pqk += dPQK * jitter;\n float rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n float rayZNear;\n\n bool intersect = false;\n\n vec2 texelSize = 1.0 / viewportSize;\n\n iterationCount = 0.0;\n\n for (int i = 0; i < MAX_ITERATION; i++)\n {\n pqk += dPQK;\n\n rayZNear = rayZFar;\n rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\n hitPixel = permute ? pqk.yx : pqk.xy;\n hitPixel *= texelSize;\n\n intersect = rayIntersectDepth(rayZNear, rayZFar, hitPixel);\n\n iterationCount += 1.0;\n\n dPQK *= 1.2;\n\n if (intersect) {\n break;\n }\n }\n\n Q0.xy += dQ.xy * iterationCount;\n Q0.z = pqk.z;\n hitPoint = Q0 / pqk.w;\n\n return intersect;\n}\n\nfloat calculateAlpha(\n float iterationCount, float reflectivity,\n vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir\n)\n{\n float alpha = clamp(reflectivity, 0.0, 1.0);\n alpha *= 1.0 - (iterationCount / float(MAX_ITERATION));\n vec2 hitPixelNDC = hitPixel * 2.0 - 1.0;\n float maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));\n alpha *= 1.0 - max(0.0, maxDimension - screenEdgeFadeStart) / (1.0 - screenEdgeFadeStart);\n\n float _eyeFadeStart = eyeFadeStart;\n float _eyeFadeEnd = eyeFadeEnd;\n if (_eyeFadeStart > _eyeFadeEnd) {\n float tmp = _eyeFadeEnd;\n _eyeFadeEnd = _eyeFadeStart;\n _eyeFadeStart = tmp;\n }\n\n float eyeDir = clamp(rayDir.z, _eyeFadeStart, _eyeFadeEnd);\n alpha *= 1.0 - (eyeDir - _eyeFadeStart) / (_eyeFadeEnd - _eyeFadeStart);\n\n alpha *= 1.0 - clamp(dist / maxRayDistance, 0.0, 1.0);\n\n return alpha;\n}\n\n@import clay.util.rand\n\n@import clay.util.rgbm\n\nvoid main()\n{\n vec4 normalAndGloss = texture2D(gBufferTexture1, v_Texcoord);\n\n if (dot(normalAndGloss.rgb, vec3(1.0)) == 0.0) {\n discard;\n }\n\n float g = normalAndGloss.a;\n#if !defined(PHYSICALLY_CORRECT)\n if (g <= minGlossiness) {\n discard;\n }\n#endif\n\n float reflectivity = (g - minGlossiness) / (1.0 - minGlossiness);\n\n vec3 N = normalize(normalAndGloss.rgb * 2.0 - 1.0);\n N = normalize((toViewSpace * vec4(N, 0.0)).xyz);\n\n vec4 projectedPos = vec4(v_Texcoord * 2.0 - 1.0, fetchDepth(gBufferTexture2, v_Texcoord), 1.0);\n vec4 pos = projectionInv * projectedPos;\n vec3 rayOrigin = pos.xyz / pos.w;\n vec3 V = -normalize(rayOrigin);\n\n float ndv = clamp(dot(N, V), 0.0, 1.0);\n float iterationCount;\n float jitter = rand(fract(v_Texcoord + jitterOffset));\n\n#ifdef PHYSICALLY_CORRECT\n vec4 color = vec4(vec3(0.0), 1.0);\n vec4 albedoMetalness = texture2D(gBufferTexture3, v_Texcoord);\n vec3 albedo = albedoMetalness.rgb;\n float m = albedoMetalness.a;\n vec3 diffuseColor = albedo * (1.0 - m);\n vec3 spec = mix(vec3(0.04), albedo, m);\n\n float jitter2 = rand(fract(v_Texcoord)) * float(TOTAL_SAMPLES);\n\n for (int i = 0; i < SAMPLE_PER_FRAME; i++) {\n vec3 H = importanceSampleNormalGGX(float(i) + jitter2, 1.0 - g, N);\n vec3 rayDir = normalize(reflect(-V, H));\n#else\n vec3 rayDir = normalize(reflect(-V, N));\n#endif\n vec2 hitPixel;\n vec3 hitPoint;\n\n bool intersect = traceScreenSpaceRay(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);\n\n float dist = distance(rayOrigin, hitPoint);\n\n vec3 hitNormal = texture2D(gBufferTexture1, hitPixel).rgb * 2.0 - 1.0;\n hitNormal = normalize((toViewSpace * vec4(hitNormal, 0.0)).xyz);\n#ifdef PHYSICALLY_CORRECT\n float ndl = clamp(dot(N, rayDir), 0.0, 1.0);\n float vdh = clamp(dot(V, H), 0.0, 1.0);\n float ndh = clamp(dot(N, H), 0.0, 1.0);\n vec3 litTexel = vec3(0.0);\n if (dot(hitNormal, rayDir) < 0.0 && intersect) {\n litTexel = texture2D(sourceTexture, hitPixel).rgb;\n litTexel *= pow(clamp(1.0 - dist / 200.0, 0.0, 1.0), 3.0);\n\n }\n else {\n #ifdef SPECULARCUBEMAP_ENABLED\n vec3 rayDirW = normalize(toWorldSpace * vec4(rayDir, 0.0)).rgb;\n litTexel = RGBMDecode(textureCubeLodEXT(specularCubemap, rayDirW, 0.0), 8.12).rgb * specularIntensity;\n#endif\n }\n color.rgb += ndl * litTexel * (\n F_Schlick(ndl, spec) * G_Smith(g, ndv, ndl) * vdh / (ndh * ndv + 0.001)\n );\n }\n color.rgb /= float(SAMPLE_PER_FRAME);\n#else\n #if !defined(SPECULARCUBEMAP_ENABLED)\n if (dot(hitNormal, rayDir) >= 0.0) {\n discard;\n }\n if (!intersect) {\n discard;\n }\n#endif\n float alpha = clamp(calculateAlpha(iterationCount, reflectivity, hitPixel, hitPoint, dist, rayDir), 0.0, 1.0);\n vec4 color = texture2D(sourceTexture, hitPixel);\n color.rgb *= alpha;\n\n#ifdef SPECULARCUBEMAP_ENABLED\n vec3 rayDirW = normalize(toWorldSpace * vec4(rayDir, 0.0)).rgb;\n alpha = alpha * (intersect ? 1.0 : 0.0);\n float bias = (1.0 -g) * 5.0;\n color.rgb += (1.0 - alpha)\n * RGBMDecode(textureCubeLodEXT(specularCubemap, rayDirW, bias), 8.12).rgb\n * specularIntensity;\n#endif\n\n#endif\n\n gl_FragColor = encodeHDR(color);\n}\n@end\n\n@export ecgl.ssr.blur\n\nuniform sampler2D texture;\nuniform sampler2D gBufferTexture1;\nuniform sampler2D gBufferTexture2;\nuniform mat4 projection;\nuniform float depthRange : 0.05;\n\nvarying vec2 v_Texcoord;\n\nuniform vec2 textureSize;\nuniform float blurSize : 1.0;\n\n#ifdef BLEND\n #ifdef SSAOTEX_ENABLED\nuniform sampler2D ssaoTex;\n #endif\nuniform sampler2D sourceTexture;\n#endif\n\nfloat getLinearDepth(vec2 coord)\n{\n float depth = texture2D(gBufferTexture2, coord).r * 2.0 - 1.0;\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n}\n\n@import clay.util.rgbm\n\n\nvoid main()\n{\n @import clay.compositor.kernel.gaussian_9\n\n vec4 centerNTexel = texture2D(gBufferTexture1, v_Texcoord);\n float g = centerNTexel.a;\n float maxBlurSize = clamp(1.0 - g, 0.0, 1.0) * blurSize;\n#ifdef VERTICAL\n vec2 off = vec2(0.0, maxBlurSize / textureSize.y);\n#else\n vec2 off = vec2(maxBlurSize / textureSize.x, 0.0);\n#endif\n\n vec2 coord = v_Texcoord;\n\n vec4 sum = vec4(0.0);\n float weightAll = 0.0;\n\n vec3 cN = centerNTexel.rgb * 2.0 - 1.0;\n float cD = getLinearDepth(v_Texcoord);\n for (int i = 0; i < 9; i++) {\n vec2 coord = clamp((float(i) - 4.0) * off + v_Texcoord, vec2(0.0), vec2(1.0));\n float w = gaussianKernel[i]\n * clamp(dot(cN, texture2D(gBufferTexture1, coord).rgb * 2.0 - 1.0), 0.0, 1.0);\n float d = getLinearDepth(coord);\n w *= (1.0 - smoothstep(abs(cD - d) / depthRange, 0.0, 1.0));\n\n weightAll += w;\n sum += decodeHDR(texture2D(texture, coord)) * w;\n }\n\n#ifdef BLEND\n float aoFactor = 1.0;\n #ifdef SSAOTEX_ENABLED\n aoFactor = texture2D(ssaoTex, v_Texcoord).r;\n #endif\n gl_FragColor = encodeHDR(\n sum / weightAll * aoFactor + decodeHDR(texture2D(sourceTexture, v_Texcoord))\n );\n#else\n gl_FragColor = encodeHDR(sum / weightAll);\n#endif\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/effect/SSRPass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$cubemap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/util/cubemap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSR$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/SSR.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSR$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function SSRPass(opt) {
    opt = opt || {};
    this._ssrPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.ssr.main'),
        clearColor: [
            0,
            0,
            0,
            0
        ]
    });
    this._blurPass1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.ssr.blur'),
        clearColor: [
            0,
            0,
            0,
            0
        ]
    });
    this._blurPass2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.ssr.blur'),
        clearColor: [
            0,
            0,
            0,
            0
        ]
    });
    this._blendPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('clay.compositor.blend')
    });
    this._blendPass.material.disableTexturesAll();
    this._blendPass.material.enableTexture([
        'texture1',
        'texture2'
    ]);
    this._ssrPass.setUniform('gBufferTexture1', opt.normalTexture);
    this._ssrPass.setUniform('gBufferTexture2', opt.depthTexture); // this._ssrPass.setUniform('gBufferTexture3', opt.albedoTexture);
    this._blurPass1.setUniform('gBufferTexture1', opt.normalTexture);
    this._blurPass1.setUniform('gBufferTexture2', opt.depthTexture);
    this._blurPass2.setUniform('gBufferTexture1', opt.normalTexture);
    this._blurPass2.setUniform('gBufferTexture2', opt.depthTexture);
    this._blurPass2.material.define('fragment', 'VERTICAL');
    this._blurPass2.material.define('fragment', 'BLEND');
    this._ssrTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._texture2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._texture3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._prevTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._currentTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._frameBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        depthBuffer: false
    });
    this._normalDistribution = null;
    this._totalSamples = 256;
    this._samplePerFrame = 4;
    this._ssrPass.material.define('fragment', 'SAMPLE_PER_FRAME', this._samplePerFrame);
    this._ssrPass.material.define('fragment', 'TOTAL_SAMPLES', this._totalSamples);
    this._downScale = 1;
}
SSRPass.prototype.setAmbientCubemap = function(specularCubemap, specularIntensity) {
    this._ssrPass.material.set('specularCubemap', specularCubemap);
    this._ssrPass.material.set('specularIntensity', specularIntensity);
    var enableSpecularMap = specularCubemap && specularIntensity;
    this._ssrPass.material[enableSpecularMap ? 'enableTexture' : 'disableTexture']('specularCubemap');
};
SSRPass.prototype.update = function(renderer, camera, sourceTexture, frame) {
    var width = renderer.getWidth();
    var height = renderer.getHeight();
    var ssrTexture = this._ssrTexture;
    var texture2 = this._texture2;
    var texture3 = this._texture3;
    ssrTexture.width = this._prevTexture.width = this._currentTexture.width = width / this._downScale;
    ssrTexture.height = this._prevTexture.height = this._currentTexture.height = height / this._downScale;
    texture2.width = texture3.width = width;
    texture2.height = texture3.height = height;
    var frameBuffer = this._frameBuffer;
    var ssrPass = this._ssrPass;
    var blurPass1 = this._blurPass1;
    var blurPass2 = this._blurPass2;
    var blendPass = this._blendPass;
    var toViewSpace = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    var toWorldSpace = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(toViewSpace, camera.worldTransform);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transpose(toWorldSpace, camera.viewMatrix);
    ssrPass.setUniform('sourceTexture', sourceTexture);
    ssrPass.setUniform('projection', camera.projectionMatrix.array);
    ssrPass.setUniform('projectionInv', camera.invProjectionMatrix.array);
    ssrPass.setUniform('toViewSpace', toViewSpace.array);
    ssrPass.setUniform('toWorldSpace', toWorldSpace.array);
    ssrPass.setUniform('nearZ', camera.near);
    var percent = frame / this._totalSamples * this._samplePerFrame;
    ssrPass.setUniform('jitterOffset', percent);
    ssrPass.setUniform('sampleOffset', frame * this._samplePerFrame);
    blurPass1.setUniform('textureSize', [
        ssrTexture.width,
        ssrTexture.height
    ]);
    blurPass2.setUniform('textureSize', [
        width,
        height
    ]);
    blurPass2.setUniform('sourceTexture', sourceTexture);
    blurPass1.setUniform('projection', camera.projectionMatrix.array);
    blurPass2.setUniform('projection', camera.projectionMatrix.array);
    frameBuffer.attach(ssrTexture);
    frameBuffer.bind(renderer);
    ssrPass.render(renderer);
    if (this._physicallyCorrect) {
        frameBuffer.attach(this._currentTexture);
        blendPass.setUniform('texture1', this._prevTexture);
        blendPass.setUniform('texture2', ssrTexture);
        blendPass.material.set({
            'weight1': frame >= 1 ? 0.95 : 0,
            'weight2': frame >= 1 ? 0.05 : 1 // weight1: frame >= 1 ? 1 : 0,
        });
        blendPass.render(renderer);
    }
    frameBuffer.attach(texture2);
    blurPass1.setUniform('texture', this._physicallyCorrect ? this._currentTexture : ssrTexture);
    blurPass1.render(renderer);
    frameBuffer.attach(texture3);
    blurPass2.setUniform('texture', texture2);
    blurPass2.render(renderer);
    frameBuffer.unbind(renderer);
    if (this._physicallyCorrect) {
        var tmp = this._prevTexture;
        this._prevTexture = this._currentTexture;
        this._currentTexture = tmp;
    }
};
SSRPass.prototype.getTargetTexture = function() {
    return this._texture3;
};
SSRPass.prototype.setParameter = function(name, val) {
    if (name === 'maxIteration') {
        this._ssrPass.material.define('fragment', 'MAX_ITERATION', val);
    } else {
        this._ssrPass.setUniform(name, val);
    }
};
SSRPass.prototype.setPhysicallyCorrect = function(isPhysicallyCorrect) {
    if (isPhysicallyCorrect) {
        if (!this._normalDistribution) {
            this._normalDistribution = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$cubemap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].generateNormalDistribution(64, this._totalSamples);
        }
        this._ssrPass.material.define('fragment', 'PHYSICALLY_CORRECT');
        this._ssrPass.material.set('normalDistribution', this._normalDistribution);
        this._ssrPass.material.set('normalDistributionSize', [
            64,
            this._totalSamples
        ]);
    } else {
        this._ssrPass.material.undefine('fragment', 'PHYSICALLY_CORRECT');
    }
    this._physicallyCorrect = isPhysicallyCorrect;
};
SSRPass.prototype.setSSAOTexture = function(texture) {
    var blendPass = this._blurPass2;
    if (texture) {
        blendPass.material.enableTexture('ssaoTex');
        blendPass.material.set('ssaoTex', texture);
    } else {
        blendPass.material.disableTexture('ssaoTex');
    }
};
SSRPass.prototype.isFinished = function(frame) {
    if (this._physicallyCorrect) {
        return frame > this._totalSamples / this._samplePerFrame;
    } else {
        return true;
    }
};
SSRPass.prototype.dispose = function(renderer) {
    this._ssrTexture.dispose(renderer);
    this._texture2.dispose(renderer);
    this._texture3.dispose(renderer);
    this._prevTexture.dispose(renderer);
    this._currentTexture.dispose(renderer);
    this._frameBuffer.dispose(renderer);
};
const __TURBOPACK__default__export__ = SSRPass;
}}),
"[project]/node_modules/echarts-gl/lib/effect/poissonKernel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Based on https://bl.ocks.org/mbostock/19168c663618b707158
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = [
    0.0,
    0.0,
    -0.321585265978,
    -0.154972575841,
    0.458126042375,
    0.188473391593,
    0.842080129861,
    0.527766490688,
    0.147304551086,
    -0.659453822776,
    -0.331943915203,
    -0.940619700594,
    0.0479226680259,
    0.54812163202,
    0.701581552186,
    -0.709825561388,
    -0.295436780218,
    0.940589268233,
    -0.901489676764,
    0.237713156085,
    0.973570876096,
    -0.109899459384,
    -0.866792314779,
    -0.451805525005,
    0.330975007087,
    0.800048655954,
    -0.344275183665,
    0.381779221166,
    -0.386139432542,
    -0.437418421534,
    -0.576478634965,
    -0.0148463392551,
    0.385798197415,
    -0.262426961053,
    -0.666302061145,
    0.682427250835,
    -0.628010632582,
    -0.732836215494,
    0.10163141741,
    -0.987658134403,
    0.711995289051,
    -0.320024291314,
    0.0296005138058,
    0.950296523438,
    0.0130612307608,
    -0.351024443122,
    -0.879596633704,
    -0.10478487883,
    0.435712737232,
    0.504254490347,
    0.779203817497,
    0.206477676721,
    0.388264289969,
    -0.896736162545,
    -0.153106280781,
    -0.629203242522,
    -0.245517550697,
    0.657969239148,
    0.126830499058,
    0.26862328493,
    -0.634888119007,
    -0.302301223431,
    0.617074219636,
    0.779817204925
];
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/normal.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.normal.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\n@import ecgl.common.normalMap.vertexHeader\n\n@import ecgl.common.vertexAnimation.header\n\nvoid main()\n{\n\n @import ecgl.common.vertexAnimation.main\n\n @import ecgl.common.uv.main\n\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n @import ecgl.common.normalMap.vertexMain\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n}\n\n\n@end\n\n\n@export ecgl.normal.fragment\n\n#define ROUGHNESS_CHANEL 0\n\nuniform bool useBumpMap;\nuniform bool useRoughnessMap;\nuniform bool doubleSide;\nuniform float roughness;\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n@import ecgl.common.normalMap.fragmentHeader\n@import ecgl.common.bumpMap.header\n\nuniform sampler2D roughnessMap;\n\nvoid main()\n{\n vec3 N = v_Normal;\n \n bool flipNormal = false;\n if (doubleSide) {\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n flipNormal = true;\n }\n }\n\n @import ecgl.common.normalMap.fragmentMain\n\n if (useBumpMap) {\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n }\n\n float g = 1.0 - roughness;\n\n if (useRoughnessMap) {\n float g2 = 1.0 - texture2D(roughnessMap, v_DetailTexcoord)[ROUGHNESS_CHANEL];\n g = clamp(g2 + (g - 0.5) * 2.0, 0.0, 1.0);\n }\n\n if (flipNormal) {\n N = -N;\n }\n\n gl_FragColor.rgb = (N.xyz + 1.0) * 0.5;\n gl_FragColor.a = g;\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/effect/NormalPass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// NormalPass will generate normal and depth data.
// TODO Animation
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/util/texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$normal$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/normal.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$normal$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function attachTextureToSlot(renderer, program, symbol, texture, slot) {
    var gl = renderer.gl;
    program.setUniform(gl, '1i', symbol, slot);
    gl.activeTexture(gl.TEXTURE0 + slot); // Maybe texture is not loaded yet;
    if (texture.isRenderable()) {
        texture.bind(renderer);
    } else {
        // Bind texture to null
        texture.unbind(renderer);
    }
} // TODO Use globalShader insteadof globalMaterial?
function getBeforeRenderHook(renderer, defaultNormalMap, defaultBumpMap, defaultRoughnessMap, normalMaterial) {
    var previousNormalMap;
    var previousBumpMap;
    var previousRoughnessMap;
    var previousRenderable;
    var gl = renderer.gl;
    return function(renderable, normalMaterial, prevNormalMaterial) {
        // Material not change
        if (previousRenderable && previousRenderable.material === renderable.material) {
            return;
        }
        var material = renderable.material;
        var program = renderable.__program;
        var roughness = material.get('roughness');
        if (roughness == null) {
            roughness = 1;
        }
        var normalMap = material.get('normalMap') || defaultNormalMap;
        var roughnessMap = material.get('roughnessMap');
        var bumpMap = material.get('bumpMap');
        var uvRepeat = material.get('uvRepeat');
        var uvOffset = material.get('uvOffset');
        var detailUvRepeat = material.get('detailUvRepeat');
        var detailUvOffset = material.get('detailUvOffset');
        var useBumpMap = !!bumpMap && material.isTextureEnabled('bumpMap');
        var useRoughnessMap = !!roughnessMap && material.isTextureEnabled('roughnessMap');
        var doubleSide = material.isDefined('fragment', 'DOUBLE_SIDED');
        bumpMap = bumpMap || defaultBumpMap;
        roughnessMap = roughnessMap || defaultRoughnessMap;
        if (prevNormalMaterial !== normalMaterial) {
            normalMaterial.set('normalMap', normalMap);
            normalMaterial.set('bumpMap', bumpMap);
            normalMaterial.set('roughnessMap', roughnessMap);
            normalMaterial.set('useBumpMap', useBumpMap);
            normalMaterial.set('useRoughnessMap', useRoughnessMap);
            normalMaterial.set('doubleSide', doubleSide);
            uvRepeat != null && normalMaterial.set('uvRepeat', uvRepeat);
            uvOffset != null && normalMaterial.set('uvOffset', uvOffset);
            detailUvRepeat != null && normalMaterial.set('detailUvRepeat', detailUvRepeat);
            detailUvOffset != null && normalMaterial.set('detailUvOffset', detailUvOffset);
            normalMaterial.set('roughness', roughness);
        } else {
            program.setUniform(gl, '1f', 'roughness', roughness);
            if (previousNormalMap !== normalMap) {
                attachTextureToSlot(renderer, program, 'normalMap', normalMap, 0);
            }
            if (previousBumpMap !== bumpMap && bumpMap) {
                attachTextureToSlot(renderer, program, 'bumpMap', bumpMap, 1);
            }
            if (previousRoughnessMap !== roughnessMap && roughnessMap) {
                attachTextureToSlot(renderer, program, 'roughnessMap', roughnessMap, 2);
            }
            if (uvRepeat != null) {
                program.setUniform(gl, '2f', 'uvRepeat', uvRepeat);
            }
            if (uvOffset != null) {
                program.setUniform(gl, '2f', 'uvOffset', uvOffset);
            }
            if (detailUvRepeat != null) {
                program.setUniform(gl, '2f', 'detailUvRepeat', detailUvRepeat);
            }
            if (detailUvOffset != null) {
                program.setUniform(gl, '2f', 'detailUvOffset', detailUvOffset);
            }
            program.setUniform(gl, '1i', 'useBumpMap', +useBumpMap);
            program.setUniform(gl, '1i', 'useRoughnessMap', +useRoughnessMap);
            program.setUniform(gl, '1i', 'doubleSide', +doubleSide);
        }
        previousNormalMap = normalMap;
        previousBumpMap = bumpMap;
        previousRoughnessMap = roughnessMap;
        previousRenderable = renderable;
    };
}
function NormalPass(opt) {
    opt = opt || {};
    this._depthTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT,
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT
    });
    this._normalTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._framebuffer.attach(this._normalTex);
    this._framebuffer.attach(this._depthTex, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_ATTACHMENT);
    this._normalMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.normal.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.normal.fragment'))
    });
    this._normalMaterial.enableTexture([
        'normalMap',
        'bumpMap',
        'roughnessMap'
    ]);
    this._defaultNormalMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlank('#000');
    this._defaultBumpMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlank('#000');
    this._defaultRoughessMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$util$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlank('#000');
    this._debugPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('clay.compositor.output')
    });
    this._debugPass.setUniform('texture', this._normalTex);
    this._debugPass.material.undefine('fragment', 'OUTPUT_ALPHA');
}
NormalPass.prototype.getDepthTexture = function() {
    return this._depthTex;
};
NormalPass.prototype.getNormalTexture = function() {
    return this._normalTex;
};
NormalPass.prototype.update = function(renderer, scene, camera) {
    var width = renderer.getWidth();
    var height = renderer.getHeight();
    var depthTexture = this._depthTex;
    var normalTexture = this._normalTex;
    var normalMaterial = this._normalMaterial;
    depthTexture.width = width;
    depthTexture.height = height;
    normalTexture.width = width;
    normalTexture.height = height;
    var opaqueList = scene.getRenderList(camera).opaque;
    this._framebuffer.bind(renderer);
    renderer.gl.clearColor(0, 0, 0, 0);
    renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT | renderer.gl.DEPTH_BUFFER_BIT);
    renderer.gl.disable(renderer.gl.BLEND);
    renderer.renderPass(opaqueList, camera, {
        getMaterial: function() {
            return normalMaterial;
        },
        ifRender: function(object) {
            return object.renderNormal;
        },
        beforeRender: getBeforeRenderHook(renderer, this._defaultNormalMap, this._defaultBumpMap, this._defaultRoughessMap, this._normalMaterial),
        sort: renderer.opaqueSortCompare
    });
    this._framebuffer.unbind(renderer);
};
NormalPass.prototype.renderDebug = function(renderer) {
    this._debugPass.render(renderer);
};
NormalPass.prototype.dispose = function(renderer) {
    this._depthTex.dispose(renderer);
    this._normalTex.dispose(renderer);
};
const __TURBOPACK__default__export__ = NormalPass;
}}),
"[project]/node_modules/echarts-gl/lib/effect/EdgePass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function EdgePass(opt) {
    opt = opt || {};
    this._edgePass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.edge')
    });
    this._edgePass.setUniform('normalTexture', opt.normalTexture);
    this._edgePass.setUniform('depthTexture', opt.depthTexture);
    this._targetTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._frameBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._frameBuffer.attach(this._targetTexture);
}
EdgePass.prototype.update = function(renderer, camera, sourceTexture, frame) {
    var width = renderer.getWidth();
    var height = renderer.getHeight();
    var texture = this._targetTexture;
    texture.width = width;
    texture.height = height;
    var frameBuffer = this._frameBuffer;
    frameBuffer.bind(renderer);
    this._edgePass.setUniform('projectionInv', camera.invProjectionMatrix.array);
    this._edgePass.setUniform('textureSize', [
        width,
        height
    ]);
    this._edgePass.setUniform('texture', sourceTexture);
    this._edgePass.render(renderer);
    frameBuffer.unbind(renderer);
};
EdgePass.prototype.getTargetTexture = function() {
    return this._targetTexture;
};
EdgePass.prototype.setParameter = function(name, val) {
    this._edgePass.setUniform(name, val);
};
EdgePass.prototype.dispose = function(renderer) {
    this._targetTexture.dispose(renderer);
    this._frameBuffer.dispose(renderer);
};
const __TURBOPACK__default__export__ = EdgePass;
}}),
"[project]/node_modules/echarts-gl/lib/effect/composite.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    'type': 'compositor',
    'nodes': [
        {
            'name': 'source',
            'type': 'texture',
            'outputs': {
                'color': {}
            }
        },
        {
            'name': 'source_half',
            'shader': '#source(clay.compositor.downsample)',
            'inputs': {
                'texture': 'source'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 2)',
                        'height': 'expr(height * 1.0 / 2)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0, height * 1.0] )'
            }
        },
        {
            'name': 'bright',
            'shader': '#source(clay.compositor.bright)',
            'inputs': {
                'texture': 'source_half'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 2)',
                        'height': 'expr(height * 1.0 / 2)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'threshold': 2,
                'scale': 4,
                'textureSize': 'expr([width * 1.0 / 2, height / 2])'
            }
        },
        {
            'name': 'bright_downsample_4',
            'shader': '#source(clay.compositor.downsample)',
            'inputs': {
                'texture': 'bright'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 4)',
                        'height': 'expr(height * 1.0 / 4)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0 / 2, height / 2] )'
            }
        },
        {
            'name': 'bright_downsample_8',
            'shader': '#source(clay.compositor.downsample)',
            'inputs': {
                'texture': 'bright_downsample_4'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 8)',
                        'height': 'expr(height * 1.0 / 8)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0 / 4, height / 4] )'
            }
        },
        {
            'name': 'bright_downsample_16',
            'shader': '#source(clay.compositor.downsample)',
            'inputs': {
                'texture': 'bright_downsample_8'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 16)',
                        'height': 'expr(height * 1.0 / 16)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0 / 8, height / 8] )'
            }
        },
        {
            'name': 'bright_downsample_32',
            'shader': '#source(clay.compositor.downsample)',
            'inputs': {
                'texture': 'bright_downsample_16'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 32)',
                        'height': 'expr(height * 1.0 / 32)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0 / 16, height / 16] )'
            }
        },
        {
            'name': 'bright_upsample_16_blur_h',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_downsample_32'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 16)',
                        'height': 'expr(height * 1.0 / 16)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 0.0,
                'textureSize': 'expr( [width * 1.0 / 32, height / 32] )'
            }
        },
        {
            'name': 'bright_upsample_16_blur_v',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_upsample_16_blur_h'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 16)',
                        'height': 'expr(height * 1.0 / 16)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 1.0,
                'textureSize': 'expr( [width * 1.0 / 16, height * 1.0 / 16] )'
            }
        },
        {
            'name': 'bright_upsample_8_blur_h',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_downsample_16'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 8)',
                        'height': 'expr(height * 1.0 / 8)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 0.0,
                'textureSize': 'expr( [width * 1.0 / 16, height * 1.0 / 16] )'
            }
        },
        {
            'name': 'bright_upsample_8_blur_v',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_upsample_8_blur_h'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 8)',
                        'height': 'expr(height * 1.0 / 8)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 1.0,
                'textureSize': 'expr( [width * 1.0 / 8, height * 1.0 / 8] )'
            }
        },
        {
            'name': 'bright_upsample_8_blend',
            'shader': '#source(clay.compositor.blend)',
            'inputs': {
                'texture1': 'bright_upsample_8_blur_v',
                'texture2': 'bright_upsample_16_blur_v'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 8)',
                        'height': 'expr(height * 1.0 / 8)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'weight1': 0.3,
                'weight2': 0.7
            }
        },
        {
            'name': 'bright_upsample_4_blur_h',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_downsample_8'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 4)',
                        'height': 'expr(height * 1.0 / 4)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 0.0,
                'textureSize': 'expr( [width * 1.0 / 8, height * 1.0 / 8] )'
            }
        },
        {
            'name': 'bright_upsample_4_blur_v',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_upsample_4_blur_h'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 4)',
                        'height': 'expr(height * 1.0 / 4)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 1.0,
                'textureSize': 'expr( [width * 1.0 / 4, height * 1.0 / 4] )'
            }
        },
        {
            'name': 'bright_upsample_4_blend',
            'shader': '#source(clay.compositor.blend)',
            'inputs': {
                'texture1': 'bright_upsample_4_blur_v',
                'texture2': 'bright_upsample_8_blend'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 4)',
                        'height': 'expr(height * 1.0 / 4)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'weight1': 0.3,
                'weight2': 0.7
            }
        },
        {
            'name': 'bright_upsample_2_blur_h',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_downsample_4'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 2)',
                        'height': 'expr(height * 1.0 / 2)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 0.0,
                'textureSize': 'expr( [width * 1.0 / 4, height * 1.0 / 4] )'
            }
        },
        {
            'name': 'bright_upsample_2_blur_v',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_upsample_2_blur_h'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 2)',
                        'height': 'expr(height * 1.0 / 2)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 1.0,
                'textureSize': 'expr( [width * 1.0 / 2, height * 1.0 / 2] )'
            }
        },
        {
            'name': 'bright_upsample_2_blend',
            'shader': '#source(clay.compositor.blend)',
            'inputs': {
                'texture1': 'bright_upsample_2_blur_v',
                'texture2': 'bright_upsample_4_blend'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0 / 2)',
                        'height': 'expr(height * 1.0 / 2)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'weight1': 0.3,
                'weight2': 0.7
            }
        },
        {
            'name': 'bright_upsample_full_blur_h',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 0.0,
                'textureSize': 'expr( [width * 1.0 / 2, height * 1.0 / 2] )'
            }
        },
        {
            'name': 'bright_upsample_full_blur_v',
            'shader': '#source(clay.compositor.gaussian_blur)',
            'inputs': {
                'texture': 'bright_upsample_full_blur_h'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'blurSize': 1,
                'blurDir': 1.0,
                'textureSize': 'expr( [width * 1.0, height * 1.0] )'
            }
        },
        {
            'name': 'bloom_composite',
            'shader': '#source(clay.compositor.blend)',
            'inputs': {
                'texture1': 'bright_upsample_full_blur_v',
                'texture2': 'bright_upsample_2_blend'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'weight1': 0.3,
                'weight2': 0.7
            }
        },
        {
            'name': 'coc',
            'shader': '#source(ecgl.dof.coc)',
            'outputs': {
                'color': {
                    'parameters': {
                        'minFilter': 'NEAREST',
                        'magFilter': 'NEAREST',
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)'
                    }
                }
            },
            'parameters': {
                'focalDist': 50,
                'focalRange': 30
            }
        },
        {
            'name': 'dof_far_blur',
            'shader': '#source(ecgl.dof.diskBlur)',
            'inputs': {
                'texture': 'source',
                'coc': 'coc'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0, height * 1.0] )'
            }
        },
        {
            'name': 'dof_near_blur',
            'shader': '#source(ecgl.dof.diskBlur)',
            'inputs': {
                'texture': 'source',
                'coc': 'coc'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0, height * 1.0] )'
            },
            'defines': {
                'BLUR_NEARFIELD': null
            }
        },
        {
            'name': 'dof_coc_blur',
            'shader': '#source(ecgl.dof.diskBlur)',
            'inputs': {
                'texture': 'coc'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'minFilter': 'NEAREST',
                        'magFilter': 'NEAREST',
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)'
                    }
                }
            },
            'parameters': {
                'textureSize': 'expr( [width * 1.0, height * 1.0] )'
            },
            'defines': {
                'BLUR_COC': null
            }
        },
        {
            'name': 'dof_composite',
            'shader': '#source(ecgl.dof.composite)',
            'inputs': {
                'original': 'source',
                'blurred': 'dof_far_blur',
                'nearfield': 'dof_near_blur',
                'coc': 'coc',
                'nearcoc': 'dof_coc_blur'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)',
                        'type': 'HALF_FLOAT'
                    }
                }
            }
        },
        {
            'name': 'composite',
            'shader': '#source(clay.compositor.hdr.composite)',
            'inputs': {
                'texture': 'source',
                'bloom': 'bloom_composite'
            },
            'outputs': {
                'color': {
                    'parameters': {
                        'width': 'expr(width * 1.0)',
                        'height': 'expr(height * 1.0)'
                    }
                }
            },
            'defines': {
            }
        },
        {
            'name': 'FXAA',
            'shader': '#source(clay.compositor.fxaa)',
            'inputs': {
                'texture': 'composite'
            }
        }
    ]
};
}}),
"[project]/node_modules/echarts-gl/lib/effect/DOF.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.dof.coc\n\nuniform sampler2D depth;\n\nuniform float zNear: 0.1;\nuniform float zFar: 2000;\n\nuniform float focalDistance: 3;\nuniform float focalRange: 1;\nuniform float focalLength: 30;\nuniform float fstop: 2.8;\n\nvarying vec2 v_Texcoord;\n\n@import clay.util.encode_float\n\nvoid main()\n{\n float z = texture2D(depth, v_Texcoord).r * 2.0 - 1.0;\n\n float dist = 2.0 * zNear * zFar / (zFar + zNear - z * (zFar - zNear));\n\n float aperture = focalLength / fstop;\n\n float coc;\n\n float uppper = focalDistance + focalRange;\n float lower = focalDistance - focalRange;\n if (dist <= uppper && dist >= lower) {\n coc = 0.5;\n }\n else {\n float focalAdjusted = dist > uppper ? uppper : lower;\n\n coc = abs(aperture * (focalLength * (dist - focalAdjusted)) / (dist * (focalAdjusted - focalLength)));\n coc = clamp(coc, 0.0, 2.0) / 2.00001;\n\n if (dist < lower) {\n coc = -coc;\n }\n coc = coc * 0.5 + 0.5;\n }\n\n gl_FragColor = encodeFloat(coc);\n}\n@end\n\n\n@export ecgl.dof.composite\n\n#define DEBUG 0\n\nuniform sampler2D original;\nuniform sampler2D blurred;\nuniform sampler2D nearfield;\nuniform sampler2D coc;\nuniform sampler2D nearcoc;\nvarying vec2 v_Texcoord;\n\n@import clay.util.rgbm\n@import clay.util.float\n\nvoid main()\n{\n vec4 blurredColor = texture2D(blurred, v_Texcoord);\n vec4 originalColor = texture2D(original, v_Texcoord);\n\n float fCoc = decodeFloat(texture2D(coc, v_Texcoord));\n\n fCoc = abs(fCoc * 2.0 - 1.0);\n\n float weight = smoothstep(0.0, 1.0, fCoc);\n \n#ifdef NEARFIELD_ENABLED\n vec4 nearfieldColor = texture2D(nearfield, v_Texcoord);\n float fNearCoc = decodeFloat(texture2D(nearcoc, v_Texcoord));\n fNearCoc = abs(fNearCoc * 2.0 - 1.0);\n\n gl_FragColor = encodeHDR(\n mix(\n nearfieldColor, mix(originalColor, blurredColor, weight),\n pow(1.0 - fNearCoc, 4.0)\n )\n );\n#else\n gl_FragColor = encodeHDR(mix(originalColor, blurredColor, weight));\n#endif\n\n}\n\n@end\n\n\n\n@export ecgl.dof.diskBlur\n\n#define POISSON_KERNEL_SIZE 16;\n\nuniform sampler2D texture;\nuniform sampler2D coc;\nvarying vec2 v_Texcoord;\n\nuniform float blurRadius : 10.0;\nuniform vec2 textureSize : [512.0, 512.0];\n\nuniform vec2 poissonKernel[POISSON_KERNEL_SIZE];\n\nuniform float percent;\n\nfloat nrand(const in vec2 n) {\n return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n@import clay.util.rgbm\n@import clay.util.float\n\n\nvoid main()\n{\n vec2 offset = blurRadius / textureSize;\n\n float rnd = 6.28318 * nrand(v_Texcoord + 0.07 * percent );\n float cosa = cos(rnd);\n float sina = sin(rnd);\n vec4 basis = vec4(cosa, -sina, sina, cosa);\n\n#if !defined(BLUR_NEARFIELD) && !defined(BLUR_COC)\n offset *= abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0);\n#endif\n\n#ifdef BLUR_COC\n float cocSum = 0.0;\n#else\n vec4 color = vec4(0.0);\n#endif\n\n\n float weightSum = 0.0;\n\n for (int i = 0; i < POISSON_KERNEL_SIZE; i++) {\n vec2 ofs = poissonKernel[i];\n\n ofs = vec2(dot(ofs, basis.xy), dot(ofs, basis.zw));\n\n vec2 uv = v_Texcoord + ofs * offset;\n vec4 texel = texture2D(texture, uv);\n\n float w = 1.0;\n#ifdef BLUR_COC\n float fCoc = decodeFloat(texel) * 2.0 - 1.0;\n cocSum += clamp(fCoc, -1.0, 0.0) * w;\n#else\n texel = texel;\n #if !defined(BLUR_NEARFIELD)\n float fCoc = decodeFloat(texture2D(coc, uv)) * 2.0 - 1.0;\n w *= abs(fCoc);\n #endif\n texel.rgb *= texel.a;\n color += texel * w;\n#endif\n\n weightSum += w;\n }\n\n#ifdef BLUR_COC\n gl_FragColor = encodeFloat(clamp(cocSum / weightSum, -1.0, 0.0) * 0.5 + 0.5);\n#else\n color /= weightSum;\n color.rgb /= (color.a + 0.0001);\n gl_FragColor = color;\n#endif\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/effect/edge.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.edge\n\nuniform sampler2D texture;\n\nuniform sampler2D normalTexture;\nuniform sampler2D depthTexture;\n\nuniform mat4 projectionInv;\n\nuniform vec2 textureSize;\n\nuniform vec4 edgeColor: [0,0,0,0.8];\n\nvarying vec2 v_Texcoord;\n\nvec3 packColor(vec2 coord) {\n float z = texture2D(depthTexture, coord).r * 2.0 - 1.0;\n vec4 p = vec4(v_Texcoord * 2.0 - 1.0, z, 1.0);\n vec4 p4 = projectionInv * p;\n\n return vec3(\n texture2D(normalTexture, coord).rg,\n -p4.z / p4.w / 5.0\n );\n}\n\nvoid main() {\n vec2 cc = v_Texcoord;\n vec3 center = packColor(cc);\n\n float size = clamp(1.0 - (center.z - 10.0) / 100.0, 0.0, 1.0) * 0.5;\n float dx = size / textureSize.x;\n float dy = size / textureSize.y;\n\n vec2 coord;\n vec3 topLeft = packColor(cc+vec2(-dx, -dy));\n vec3 top = packColor(cc+vec2(0.0, -dy));\n vec3 topRight = packColor(cc+vec2(dx, -dy));\n vec3 left = packColor(cc+vec2(-dx, 0.0));\n vec3 right = packColor(cc+vec2(dx, 0.0));\n vec3 bottomLeft = packColor(cc+vec2(-dx, dy));\n vec3 bottom = packColor(cc+vec2(0.0, dy));\n vec3 bottomRight = packColor(cc+vec2(dx, dy));\n\n vec3 v = -topLeft-2.0*top-topRight+bottomLeft+2.0*bottom+bottomRight;\n vec3 h = -bottomLeft-2.0*left-topLeft+bottomRight+2.0*right+topRight;\n\n float edge = sqrt(dot(h, h) + dot(v, v));\n\n edge = smoothstep(0.8, 1.0, edge);\n\n gl_FragColor = mix(texture2D(texture, v_Texcoord), vec4(edgeColor.rgb, 1.0), edgeColor.a * edge);\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/effect/EffectCompositor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$createCompositor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/createCompositor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSAOPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/SSAOPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSRPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/SSRPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$poissonKernel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/poissonKernel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$NormalPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/NormalPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$EdgePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/EdgePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$composite$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/composite.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$blur$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/blur.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$lut$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/lut.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$output$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/output.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$bright$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/bright.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$downsample$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/downsample.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$upsample$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/upsample.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$hdr$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/hdr.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$blend$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/blend.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$fxaa$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/compositor/fxaa.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$DOF$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/DOF.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$edge$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/edge.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$blur$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$lut$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$output$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$bright$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$downsample$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$upsample$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$hdr$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$blend$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$compositor$2f$fxaa$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$DOF$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$edge$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function makeCommonOutputs(getWidth, getHeight) {
    return {
        color: {
            parameters: {
                width: getWidth,
                height: getHeight
            }
        }
    };
}
var FINAL_NODES_CHAIN = [
    'composite',
    'FXAA'
];
function EffectCompositor() {
    this._width;
    this._height;
    this._dpr;
    this._sourceTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HALF_FLOAT
    });
    this._depthTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_COMPONENT,
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNSIGNED_INT
    });
    this._framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._framebuffer.attach(this._sourceTexture);
    this._framebuffer.attach(this._depthTexture, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DEPTH_ATTACHMENT);
    this._normalPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$NormalPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._compositor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$createCompositor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$composite$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    var sourceNode = this._compositor.getNodeByName('source');
    sourceNode.texture = this._sourceTexture;
    var cocNode = this._compositor.getNodeByName('coc');
    this._sourceNode = sourceNode;
    this._cocNode = cocNode;
    this._compositeNode = this._compositor.getNodeByName('composite');
    this._fxaaNode = this._compositor.getNodeByName('FXAA');
    this._dofBlurNodes = [
        'dof_far_blur',
        'dof_near_blur',
        'dof_coc_blur'
    ].map(function(name) {
        return this._compositor.getNodeByName(name);
    }, this);
    this._dofBlurKernel = 0;
    this._dofBlurKernelSize = new Float32Array(0);
    this._finalNodesChain = FINAL_NODES_CHAIN.map(function(name) {
        return this._compositor.getNodeByName(name);
    }, this);
    var gBufferObj = {
        normalTexture: this._normalPass.getNormalTexture(),
        depthTexture: this._normalPass.getDepthTexture()
    };
    this._ssaoPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSAOPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](gBufferObj);
    this._ssrPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$SSRPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](gBufferObj);
    this._edgePass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$EdgePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](gBufferObj);
}
EffectCompositor.prototype.resize = function(width, height, dpr) {
    dpr = dpr || 1;
    var width = width * dpr;
    var height = height * dpr;
    var sourceTexture = this._sourceTexture;
    var depthTexture = this._depthTexture;
    sourceTexture.width = width;
    sourceTexture.height = height;
    depthTexture.width = width;
    depthTexture.height = height;
    var rendererMock = {
        getWidth: function() {
            return width;
        },
        getHeight: function() {
            return height;
        },
        getDevicePixelRatio: function() {
            return dpr;
        }
    };
    function wrapCallback(obj, key) {
        if (typeof obj[key] === 'function') {
            var oldFunc = obj[key].__original || obj[key]; // Use viewport width/height instead of renderer width/height
            obj[key] = function(renderer) {
                return oldFunc.call(this, rendererMock);
            };
            obj[key].__original = oldFunc;
        }
    }
    this._compositor.nodes.forEach(function(node) {
        for(var outKey in node.outputs){
            var parameters = node.outputs[outKey].parameters;
            if (parameters) {
                wrapCallback(parameters, 'width');
                wrapCallback(parameters, 'height');
            }
        }
        for(var paramKey in node.parameters){
            wrapCallback(node.parameters, paramKey);
        }
    });
    this._width = width;
    this._height = height;
    this._dpr = dpr;
};
EffectCompositor.prototype.getWidth = function() {
    return this._width;
};
EffectCompositor.prototype.getHeight = function() {
    return this._height;
};
EffectCompositor.prototype._ifRenderNormalPass = function() {
    return this._enableSSAO || this._enableEdge || this._enableSSR;
};
EffectCompositor.prototype._getPrevNode = function(node) {
    var idx = FINAL_NODES_CHAIN.indexOf(node.name) - 1;
    var prevNode = this._finalNodesChain[idx];
    while(prevNode && !this._compositor.getNodeByName(prevNode.name)){
        idx -= 1;
        prevNode = this._finalNodesChain[idx];
    }
    return prevNode;
};
EffectCompositor.prototype._getNextNode = function(node) {
    var idx = FINAL_NODES_CHAIN.indexOf(node.name) + 1;
    var nextNode = this._finalNodesChain[idx];
    while(nextNode && !this._compositor.getNodeByName(nextNode.name)){
        idx += 1;
        nextNode = this._finalNodesChain[idx];
    }
    return nextNode;
};
EffectCompositor.prototype._addChainNode = function(node) {
    var prevNode = this._getPrevNode(node);
    var nextNode = this._getNextNode(node);
    if (!prevNode) {
        return;
    }
    node.inputs.texture = prevNode.name;
    if (nextNode) {
        node.outputs = makeCommonOutputs(this.getWidth.bind(this), this.getHeight.bind(this));
        nextNode.inputs.texture = node.name;
    } else {
        node.outputs = null;
    }
    this._compositor.addNode(node);
};
EffectCompositor.prototype._removeChainNode = function(node) {
    var prevNode = this._getPrevNode(node);
    var nextNode = this._getNextNode(node);
    if (!prevNode) {
        return;
    }
    if (nextNode) {
        prevNode.outputs = makeCommonOutputs(this.getWidth.bind(this), this.getHeight.bind(this));
        nextNode.inputs.texture = prevNode.name;
    } else {
        prevNode.outputs = null;
    }
    this._compositor.removeNode(node);
};
/**
 * Update normal
 */ EffectCompositor.prototype.updateNormal = function(renderer, scene, camera, frame) {
    if (this._ifRenderNormalPass()) {
        this._normalPass.update(renderer, scene, camera);
    }
};
/**
 * Render SSAO after render the scene, before compositing
 */ EffectCompositor.prototype.updateSSAO = function(renderer, scene, camera, frame) {
    this._ssaoPass.update(renderer, camera, frame);
};
/**
 * Enable SSAO effect
 */ EffectCompositor.prototype.enableSSAO = function() {
    this._enableSSAO = true;
};
/**
 * Disable SSAO effect
 */ EffectCompositor.prototype.disableSSAO = function() {
    this._enableSSAO = false;
};
/**
 * Enable SSR effect
 */ EffectCompositor.prototype.enableSSR = function() {
    this._enableSSR = true; // this._normalPass.enableTargetTexture3 = true;
};
/**
 * Disable SSR effect
 */ EffectCompositor.prototype.disableSSR = function() {
    this._enableSSR = false; // this._normalPass.enableTargetTexture3 = false;
};
/**
 * Render SSAO after render the scene, before compositing
 */ EffectCompositor.prototype.getSSAOTexture = function() {
    return this._ssaoPass.getTargetTexture();
};
/**
 * @return {clay.FrameBuffer}
 */ EffectCompositor.prototype.getSourceFrameBuffer = function() {
    return this._framebuffer;
};
/**
 * @return {clay.Texture2D}
 */ EffectCompositor.prototype.getSourceTexture = function() {
    return this._sourceTexture;
};
/**
 * Disable fxaa effect
 */ EffectCompositor.prototype.disableFXAA = function() {
    this._removeChainNode(this._fxaaNode);
};
/**
 * Enable fxaa effect
 */ EffectCompositor.prototype.enableFXAA = function() {
    this._addChainNode(this._fxaaNode);
};
/**
 * Enable bloom effect
 */ EffectCompositor.prototype.enableBloom = function() {
    this._compositeNode.inputs.bloom = 'bloom_composite';
    this._compositor.dirty();
};
/**
 * Disable bloom effect
 */ EffectCompositor.prototype.disableBloom = function() {
    this._compositeNode.inputs.bloom = null;
    this._compositor.dirty();
};
/**
 * Enable depth of field effect
 */ EffectCompositor.prototype.enableDOF = function() {
    this._compositeNode.inputs.texture = 'dof_composite';
    this._compositor.dirty();
};
/**
 * Disable depth of field effect
 */ EffectCompositor.prototype.disableDOF = function() {
    this._compositeNode.inputs.texture = 'source';
    this._compositor.dirty();
};
/**
 * Enable color correction
 */ EffectCompositor.prototype.enableColorCorrection = function() {
    this._compositeNode.define('COLOR_CORRECTION');
    this._enableColorCorrection = true;
};
/**
 * Disable color correction
 */ EffectCompositor.prototype.disableColorCorrection = function() {
    this._compositeNode.undefine('COLOR_CORRECTION');
    this._enableColorCorrection = false;
};
/**
 * Enable edge detection
 */ EffectCompositor.prototype.enableEdge = function() {
    this._enableEdge = true;
};
/**
 * Disable edge detection
 */ EffectCompositor.prototype.disableEdge = function() {
    this._enableEdge = false;
};
/**
 * Set bloom intensity
 * @param {number} value
 */ EffectCompositor.prototype.setBloomIntensity = function(value) {
    this._compositeNode.setParameter('bloomIntensity', value);
};
EffectCompositor.prototype.setSSAOParameter = function(name, value) {
    switch(name){
        case 'quality':
            // PENDING
            var kernelSize = {
                low: 6,
                medium: 12,
                high: 32,
                ultra: 62
            }[value] || 12;
            this._ssaoPass.setParameter('kernelSize', kernelSize);
            break;
        case 'radius':
            this._ssaoPass.setParameter(name, value);
            this._ssaoPass.setParameter('bias', value / 200);
            break;
        case 'intensity':
            this._ssaoPass.setParameter(name, value);
            break;
        default:
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Unkown SSAO parameter ' + name);
            }
    }
};
EffectCompositor.prototype.setDOFParameter = function(name, value) {
    switch(name){
        case 'focalDistance':
        case 'focalRange':
        case 'fstop':
            this._cocNode.setParameter(name, value);
            break;
        case 'blurRadius':
            for(var i = 0; i < this._dofBlurNodes.length; i++){
                this._dofBlurNodes[i].setParameter('blurRadius', value);
            }
            break;
        case 'quality':
            var kernelSize = {
                low: 4,
                medium: 8,
                high: 16,
                ultra: 32
            }[value] || 8;
            this._dofBlurKernelSize = kernelSize;
            for(var i = 0; i < this._dofBlurNodes.length; i++){
                this._dofBlurNodes[i].pass.material.define('POISSON_KERNEL_SIZE', kernelSize);
            }
            this._dofBlurKernel = new Float32Array(kernelSize * 2);
            break;
        default:
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Unkown DOF parameter ' + name);
            }
    }
};
EffectCompositor.prototype.setSSRParameter = function(name, value) {
    if (value == null) {
        return;
    }
    switch(name){
        case 'quality':
            // PENDING
            var maxIteration = {
                low: 10,
                medium: 15,
                high: 30,
                ultra: 80
            }[value] || 20;
            var pixelStride = {
                low: 32,
                medium: 16,
                high: 8,
                ultra: 4
            }[value] || 16;
            this._ssrPass.setParameter('maxIteration', maxIteration);
            this._ssrPass.setParameter('pixelStride', pixelStride);
            break;
        case 'maxRoughness':
            this._ssrPass.setParameter('minGlossiness', Math.max(Math.min(1.0 - value, 1.0), 0.0));
            break;
        case 'physical':
            this.setPhysicallyCorrectSSR(value);
            break;
        default:
            console.warn('Unkown SSR parameter ' + name);
    }
};
EffectCompositor.prototype.setPhysicallyCorrectSSR = function(physical) {
    this._ssrPass.setPhysicallyCorrect(physical);
};
/**
 * Set color of edge
 */ EffectCompositor.prototype.setEdgeColor = function(value) {
    var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(value);
    this._edgePass.setParameter('edgeColor', color);
};
EffectCompositor.prototype.setExposure = function(value) {
    this._compositeNode.setParameter('exposure', Math.pow(2, value));
};
EffectCompositor.prototype.setColorLookupTexture = function(image, api) {
    this._compositeNode.pass.material.setTextureImage('lut', this._enableColorCorrection ? image : 'none', api, {
        minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture.NEAREST,
        magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture.NEAREST,
        flipY: false
    });
};
EffectCompositor.prototype.setColorCorrection = function(type, value) {
    this._compositeNode.setParameter(type, value);
};
EffectCompositor.prototype.isSSREnabled = function() {
    return this._enableSSR;
};
EffectCompositor.prototype.composite = function(renderer, scene, camera, framebuffer, frame) {
    var sourceTexture = this._sourceTexture;
    var targetTexture = sourceTexture;
    if (this._enableEdge) {
        this._edgePass.update(renderer, camera, sourceTexture, frame);
        sourceTexture = targetTexture = this._edgePass.getTargetTexture();
    }
    if (this._enableSSR) {
        this._ssrPass.update(renderer, camera, sourceTexture, frame);
        targetTexture = this._ssrPass.getTargetTexture();
        this._ssrPass.setSSAOTexture(this._enableSSAO ? this._ssaoPass.getTargetTexture() : null); // var lights = scene.getLights();
    // for (var i = 0; i < lights.length; i++) {
    //     if (lights[i].cubemap) {
    //         this._ssrPass.setAmbientCubemap(lights[i].cubemap, lights[i].intensity);
    //     }
    // }
    }
    this._sourceNode.texture = targetTexture;
    this._cocNode.setParameter('depth', this._depthTexture);
    var blurKernel = this._dofBlurKernel;
    var blurKernelSize = this._dofBlurKernelSize;
    var frameAll = Math.floor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$poissonKernel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].length / 2 / blurKernelSize);
    var kernelOffset = frame % frameAll;
    for(var i = 0; i < blurKernelSize * 2; i++){
        blurKernel[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$poissonKernel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][i + kernelOffset * blurKernelSize * 2];
    }
    for(var i = 0; i < this._dofBlurNodes.length; i++){
        this._dofBlurNodes[i].setParameter('percent', frame / 30.0);
        this._dofBlurNodes[i].setParameter('poissonKernel', blurKernel);
    }
    this._cocNode.setParameter('zNear', camera.near);
    this._cocNode.setParameter('zFar', camera.far);
    this._compositor.render(renderer, framebuffer);
};
EffectCompositor.prototype.dispose = function(renderer) {
    this._sourceTexture.dispose(renderer);
    this._depthTexture.dispose(renderer);
    this._framebuffer.dispose(renderer);
    this._compositor.dispose(renderer);
    this._normalPass.dispose(renderer);
    this._ssaoPass.dispose(renderer);
};
const __TURBOPACK__default__export__ = EffectCompositor;
}}),
"[project]/node_modules/echarts-gl/lib/effect/TemporalSuperSampling.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Temporal Super Sample for static Scene
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/halton.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
;
;
;
;
;
;
function TemporalSuperSampling(frames) {
    var haltonSequence = [];
    for(var i = 0; i < 30; i++){
        haltonSequence.push([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i, 2),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(i, 3)
        ]);
    }
    this._haltonSequence = haltonSequence;
    this._frame = 0;
    this._sourceTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sourceFb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._sourceFb.attach(this._sourceTex); // Frame texture before temporal supersampling
    this._prevFrameTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._outputTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    var blendPass = this._blendPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('clay.compositor.blend')
    });
    blendPass.material.disableTexturesAll();
    blendPass.material.enableTexture([
        'texture1',
        'texture2'
    ]);
    this._blendFb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        depthBuffer: false
    });
    this._outputPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('clay.compositor.output'),
        // TODO, alpha is premultiplied?
        blendWithPrevious: true
    });
    this._outputPass.material.define('fragment', 'OUTPUT_ALPHA');
    this._outputPass.material.blend = function(_gl) {
        // FIXME.
        // Output is premultiplied alpha when BLEND is enabled ?
        // http://stackoverflow.com/questions/2171085/opengl-blending-with-previous-contents-of-framebuffer
        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
        _gl.blendFuncSeparate(_gl.ONE, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
    };
}
TemporalSuperSampling.prototype = {
    constructor: TemporalSuperSampling,
    /**
   * Jitter camera projectionMatrix
   * @parma {clay.Renderer} renderer
   * @param {clay.Camera} camera
   */ jitterProjection: function(renderer, camera) {
        var viewport = renderer.viewport;
        var dpr = viewport.devicePixelRatio || renderer.getDevicePixelRatio();
        var width = viewport.width * dpr;
        var height = viewport.height * dpr;
        var offset = this._haltonSequence[this._frame % this._haltonSequence.length];
        var translationMat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        translationMat.array[12] = (offset[0] * 2.0 - 1.0) / width;
        translationMat.array[13] = (offset[1] * 2.0 - 1.0) / height;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mul(camera.projectionMatrix, translationMat, camera.projectionMatrix);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].invert(camera.invProjectionMatrix, camera.projectionMatrix);
    },
    /**
   * Reset accumulating frame
   */ resetFrame: function() {
        this._frame = 0;
    },
    /**
   * Return current frame
   */ getFrame: function() {
        return this._frame;
    },
    /**
   * Get source framebuffer for usage
   */ getSourceFrameBuffer: function() {
        return this._sourceFb;
    },
    getOutputTexture: function() {
        return this._outputTex;
    },
    resize: function(width, height) {
        this._prevFrameTex.width = width;
        this._prevFrameTex.height = height;
        this._outputTex.width = width;
        this._outputTex.height = height;
        this._sourceTex.width = width;
        this._sourceTex.height = height;
        this._prevFrameTex.dirty();
        this._outputTex.dirty();
        this._sourceTex.dirty();
    },
    isFinished: function() {
        return this._frame >= this._haltonSequence.length;
    },
    render: function(renderer, sourceTex, notOutput) {
        var blendPass = this._blendPass;
        if (this._frame === 0) {
            // Direct output
            blendPass.setUniform('weight1', 0);
            blendPass.setUniform('weight2', 1);
        } else {
            blendPass.setUniform('weight1', 0.9);
            blendPass.setUniform('weight2', 0.1);
        }
        blendPass.setUniform('texture1', this._prevFrameTex);
        blendPass.setUniform('texture2', sourceTex || this._sourceTex);
        this._blendFb.attach(this._outputTex);
        this._blendFb.bind(renderer);
        blendPass.render(renderer);
        this._blendFb.unbind(renderer);
        if (!notOutput) {
            this._outputPass.setUniform('texture', this._outputTex);
            this._outputPass.render(renderer);
        } // Swap texture
        var tmp = this._prevFrameTex;
        this._prevFrameTex = this._outputTex;
        this._outputTex = tmp;
        this._frame++;
    },
    dispose: function(renderer) {
        this._sourceFb.dispose(renderer);
        this._blendFb.dispose(renderer);
        this._prevFrameTex.dispose(renderer);
        this._outputTex.dispose(renderer);
        this._sourceTex.dispose(renderer);
        this._outputPass.dispose(renderer);
        this._blendPass.dispose(renderer);
    }
};
const __TURBOPACK__default__export__ = TemporalSuperSampling;
}}),
"[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * @module echarts-gl/core/ViewGL
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Scene.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$prePass$2f$ShadowMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/prePass/ShadowMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/camera/Perspective.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/camera/Orthographic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$mixin$2f$notifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/core/mixin/notifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$EffectCompositor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/EffectCompositor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$TemporalSuperSampling$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/TemporalSuperSampling.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/effect/halton.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @constructor
 * @alias module:echarts-gl/core/ViewGL
 * @param {string} [projection='perspective']
 */ function ViewGL(projection) {
    projection = projection || 'perspective';
    /**
   * @type {module:echarts-gl/core/LayerGL}
   */ this.layer = null;
    /**
   * @type {clay.Scene}
   */ this.scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    /**
   * @type {clay.Node}
   */ this.rootNode = this.scene;
    this.viewport = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    this.setProjection(projection);
    this._compositor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$EffectCompositor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._temporalSS = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$TemporalSuperSampling$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._shadowMapPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$prePass$2f$ShadowMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    var pcfKernels = [];
    var off = 0;
    for(var i = 0; i < 30; i++){
        var pcfKernel = [];
        for(var k = 0; k < 6; k++){
            pcfKernel.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(off, 2) * 4.0 - 2.0);
            pcfKernel.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$effect$2f$halton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(off, 3) * 4.0 - 2.0);
            off++;
        }
        pcfKernels.push(pcfKernel);
    }
    this._pcfKernels = pcfKernels;
    this.scene.on('beforerender', function(renderer, scene, camera) {
        if (this.needsTemporalSS()) {
            this._temporalSS.jitterProjection(renderer, camera);
        }
    }, this);
}
/**
 * Set camera type of group
 * @param {string} cameraType 'perspective' | 'orthographic'
 */ ViewGL.prototype.setProjection = function(projection) {
    var oldCamera = this.camera;
    oldCamera && oldCamera.update();
    if (projection === 'perspective') {
        if (!(this.camera instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
            this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            if (oldCamera) {
                this.camera.setLocalTransform(oldCamera.localTransform);
            }
        }
    } else {
        if (!(this.camera instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
            this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            if (oldCamera) {
                this.camera.setLocalTransform(oldCamera.localTransform);
            }
        }
    } // PENDING
    this.camera.near = 0.1;
    this.camera.far = 2000;
};
/**
 * Set viewport of group
 * @param {number} x Viewport left bottom x
 * @param {number} y Viewport left bottom y
 * @param {number} width Viewport height
 * @param {number} height Viewport height
 * @param {number} [dpr=1]
 */ ViewGL.prototype.setViewport = function(x, y, width, height, dpr) {
    if (this.camera instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Perspective$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        this.camera.aspect = width / height;
    }
    dpr = dpr || 1;
    this.viewport.x = x;
    this.viewport.y = y;
    this.viewport.width = width;
    this.viewport.height = height;
    this.viewport.devicePixelRatio = dpr; // Source and output of compositor use high dpr texture.
    // But the intermediate texture of bloom, dof effects use fixed 1.0 dpr
    this._compositor.resize(width * dpr, height * dpr);
    this._temporalSS.resize(width * dpr, height * dpr);
};
/**
 * If contain screen point x, y
 * @param {number} x offsetX
 * @param {number} y offsetY
 * @return {boolean}
 */ ViewGL.prototype.containPoint = function(x, y) {
    var viewport = this.viewport;
    var height = this.layer.renderer.getHeight(); // Flip y;
    y = height - y;
    return x >= viewport.x && y >= viewport.y && x <= viewport.x + viewport.width && y <= viewport.y + viewport.height;
};
/**
 * Cast a ray
 * @param {number} x offsetX
 * @param {number} y offsetY
 * @param {clay.math.Ray} out
 * @return {clay.math.Ray}
 */ var ndc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
ViewGL.prototype.castRay = function(x, y, out) {
    var renderer = this.layer.renderer;
    var oldViewport = renderer.viewport;
    renderer.viewport = this.viewport;
    renderer.screenToNDC(x, y, ndc);
    this.camera.castRay(ndc, out);
    renderer.viewport = oldViewport;
    return out;
};
/**
 * Prepare and update scene before render
 */ ViewGL.prototype.prepareRender = function() {
    this.scene.update();
    this.camera.update();
    this.scene.updateLights();
    var renderList = this.scene.updateRenderList(this.camera);
    this._needsSortProgressively = false; // If has any transparent mesh needs sort triangles progressively.
    for(var i = 0; i < renderList.transparent.length; i++){
        var renderable = renderList.transparent[i];
        var geometry = renderable.geometry;
        if (geometry.needsSortVerticesProgressively && geometry.needsSortVerticesProgressively()) {
            this._needsSortProgressively = true;
        }
        if (geometry.needsSortTrianglesProgressively && geometry.needsSortTrianglesProgressively()) {
            this._needsSortProgressively = true;
        }
    }
    this._frame = 0;
    this._temporalSS.resetFrame(); // var lights = this.scene.getLights();
// for (var i = 0; i < lights.length; i++) {
//     if (lights[i].cubemap) {
//         if (this._compositor && this._compositor.isSSREnabled()) {
//             lights[i].invisible = true;
//         }
//         else {
//             lights[i].invisible = false;
//         }
//     }
// }
};
ViewGL.prototype.render = function(renderer, accumulating) {
    this._doRender(renderer, accumulating, this._frame);
    this._frame++;
};
ViewGL.prototype.needsAccumulate = function() {
    return this.needsTemporalSS() || this._needsSortProgressively;
};
ViewGL.prototype.needsTemporalSS = function() {
    var enableTemporalSS = this._enableTemporalSS;
    if (enableTemporalSS === 'auto') {
        enableTemporalSS = this._enablePostEffect;
    }
    return enableTemporalSS;
};
ViewGL.prototype.hasDOF = function() {
    return this._enableDOF;
};
ViewGL.prototype.isAccumulateFinished = function() {
    return this.needsTemporalSS() ? this._temporalSS.isFinished() : this._frame > 30;
};
ViewGL.prototype._doRender = function(renderer, accumulating, accumFrame) {
    var scene = this.scene;
    var camera = this.camera;
    accumFrame = accumFrame || 0;
    this._updateTransparent(renderer, scene, camera, accumFrame);
    if (!accumulating) {
        this._shadowMapPass.kernelPCF = this._pcfKernels[0]; // Not render shadowmap pass in accumulating frame.
        this._shadowMapPass.render(renderer, scene, camera, true);
    }
    this._updateShadowPCFKernel(accumFrame); // Shadowmap will set clear color.
    var bgColor = renderer.clearColor;
    renderer.gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
    if (this._enablePostEffect) {
        // normal render also needs to be jittered when have edge pass.
        if (this.needsTemporalSS()) {
            this._temporalSS.jitterProjection(renderer, camera);
        }
        this._compositor.updateNormal(renderer, scene, camera, this._temporalSS.getFrame());
    } // Always update SSAO to make sure have correct ssaoMap status
    this._updateSSAO(renderer, scene, camera, this._temporalSS.getFrame());
    if (this._enablePostEffect) {
        var frameBuffer = this._compositor.getSourceFrameBuffer();
        frameBuffer.bind(renderer);
        renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
        renderer.render(scene, camera, true, true);
        frameBuffer.unbind(renderer);
        if (this.needsTemporalSS() && accumulating) {
            this._compositor.composite(renderer, scene, camera, this._temporalSS.getSourceFrameBuffer(), this._temporalSS.getFrame());
            renderer.setViewport(this.viewport);
            this._temporalSS.render(renderer);
        } else {
            renderer.setViewport(this.viewport);
            this._compositor.composite(renderer, scene, camera, null, 0);
        }
    } else {
        if (this.needsTemporalSS() && accumulating) {
            var frameBuffer = this._temporalSS.getSourceFrameBuffer();
            frameBuffer.bind(renderer);
            renderer.saveClear();
            renderer.clearBit = renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT;
            renderer.render(scene, camera, true, true);
            renderer.restoreClear();
            frameBuffer.unbind(renderer);
            renderer.setViewport(this.viewport);
            this._temporalSS.render(renderer);
        } else {
            renderer.setViewport(this.viewport);
            renderer.render(scene, camera, true, true);
        }
    } // this._shadowMapPass.renderDebug(renderer);
// this._compositor._normalPass.renderDebug(renderer);
};
ViewGL.prototype._updateTransparent = function(renderer, scene, camera, frame) {
    var v3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    var invWorldTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    var cameraWorldPosition = camera.getWorldPosition();
    var transparentList = scene.getRenderList(camera).transparent; // Sort transparent object.
    for(var i = 0; i < transparentList.length; i++){
        var renderable = transparentList[i];
        var geometry = renderable.geometry;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].invert(invWorldTransform, renderable.worldTransform);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformMat4(v3, cameraWorldPosition, invWorldTransform);
        if (geometry.needsSortTriangles && geometry.needsSortTriangles()) {
            geometry.doSortTriangles(v3, frame);
        }
        if (geometry.needsSortVertices && geometry.needsSortVertices()) {
            geometry.doSortVertices(v3, frame);
        }
    }
};
ViewGL.prototype._updateSSAO = function(renderer, scene, camera) {
    var ifEnableSSAO = this._enableSSAO && this._enablePostEffect;
    if (ifEnableSSAO) {
        this._compositor.updateSSAO(renderer, scene, camera, this._temporalSS.getFrame());
    }
    var renderList = scene.getRenderList(camera);
    for(var i = 0; i < renderList.opaque.length; i++){
        var renderable = renderList.opaque[i]; // PENDING
        if (renderable.renderNormal) {
            renderable.material[ifEnableSSAO ? 'enableTexture' : 'disableTexture']('ssaoMap');
        }
        if (ifEnableSSAO) {
            renderable.material.set('ssaoMap', this._compositor.getSSAOTexture());
        }
    }
};
ViewGL.prototype._updateShadowPCFKernel = function(frame) {
    var pcfKernel = this._pcfKernels[frame % this._pcfKernels.length];
    var renderList = this.scene.getRenderList(this.camera);
    var opaqueList = renderList.opaque;
    for(var i = 0; i < opaqueList.length; i++){
        if (opaqueList[i].receiveShadow) {
            opaqueList[i].material.set('pcfKernel', pcfKernel);
            opaqueList[i].material.define('fragment', 'PCF_KERNEL_SIZE', pcfKernel.length / 2);
        }
    }
};
ViewGL.prototype.dispose = function(renderer) {
    this._compositor.dispose(renderer.gl);
    this._temporalSS.dispose(renderer.gl);
    this._shadowMapPass.dispose(renderer);
};
/**
 * @param {module:echarts/Model} Post effect model
 */ ViewGL.prototype.setPostEffect = function(postEffectModel, api) {
    var compositor = this._compositor;
    this._enablePostEffect = postEffectModel.get('enable');
    var bloomModel = postEffectModel.getModel('bloom');
    var edgeModel = postEffectModel.getModel('edge');
    var dofModel = postEffectModel.getModel('DOF', postEffectModel.getModel('depthOfField'));
    var ssaoModel = postEffectModel.getModel('SSAO', postEffectModel.getModel('screenSpaceAmbientOcclusion'));
    var ssrModel = postEffectModel.getModel('SSR', postEffectModel.getModel('screenSpaceReflection'));
    var fxaaModel = postEffectModel.getModel('FXAA');
    var colorCorrModel = postEffectModel.getModel('colorCorrection');
    bloomModel.get('enable') ? compositor.enableBloom() : compositor.disableBloom();
    dofModel.get('enable') ? compositor.enableDOF() : compositor.disableDOF();
    ssrModel.get('enable') ? compositor.enableSSR() : compositor.disableSSR();
    colorCorrModel.get('enable') ? compositor.enableColorCorrection() : compositor.disableColorCorrection();
    edgeModel.get('enable') ? compositor.enableEdge() : compositor.disableEdge();
    fxaaModel.get('enable') ? compositor.enableFXAA() : compositor.disableFXAA();
    this._enableDOF = dofModel.get('enable');
    this._enableSSAO = ssaoModel.get('enable');
    this._enableSSAO ? compositor.enableSSAO() : compositor.disableSSAO();
    compositor.setBloomIntensity(bloomModel.get('intensity'));
    compositor.setEdgeColor(edgeModel.get('color'));
    compositor.setColorLookupTexture(colorCorrModel.get('lookupTexture'), api);
    compositor.setExposure(colorCorrModel.get('exposure'));
    [
        'radius',
        'quality',
        'intensity'
    ].forEach(function(name) {
        compositor.setSSAOParameter(name, ssaoModel.get(name));
    });
    [
        'quality',
        'maxRoughness',
        'physical'
    ].forEach(function(name) {
        compositor.setSSRParameter(name, ssrModel.get(name));
    });
    [
        'quality',
        'focalDistance',
        'focalRange',
        'blurRadius',
        'fstop'
    ].forEach(function(name) {
        compositor.setDOFParameter(name, dofModel.get(name));
    });
    [
        'brightness',
        'contrast',
        'saturation'
    ].forEach(function(name) {
        compositor.setColorCorrection(name, colorCorrModel.get(name));
    });
};
ViewGL.prototype.setDOFFocusOnPoint = function(depth) {
    if (this._enablePostEffect) {
        if (depth > this.camera.far || depth < this.camera.near) {
            return;
        }
        this._compositor.setDOFParameter('focalDistance', depth);
        return true;
    }
};
ViewGL.prototype.setTemporalSuperSampling = function(temporalSuperSamplingModel) {
    this._enableTemporalSS = temporalSuperSamplingModel.get('enable');
};
ViewGL.prototype.isLinearSpace = function() {
    return this._enablePostEffect;
};
ViewGL.prototype.setRootNode = function(rootNode) {
    if (this.rootNode === rootNode) {
        return;
    }
    var children = this.rootNode.children();
    for(var i = 0; i < children.length; i++){
        rootNode.add(children[i]);
    }
    if (rootNode !== this.scene) {
        this.scene.add(rootNode);
    }
    this.rootNode = rootNode;
}; // Proxies
ViewGL.prototype.add = function(node3D) {
    this.rootNode.add(node3D);
};
ViewGL.prototype.remove = function(node3D) {
    this.rootNode.remove(node3D);
};
ViewGL.prototype.removeAll = function(node3D) {
    this.rootNode.removeAll(node3D);
};
Object.assign(ViewGL.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$mixin$2f$notifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = ViewGL;
}}),
"[project]/node_modules/echarts-gl/lib/coord/grid3DCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3D$2f$Cartesian3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/grid3D/Cartesian3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3D$2f$Axis3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/grid3D/Axis3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/util/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
;
;
;
;
;
;
function resizeCartesian3D(grid3DModel, api) {
    // Use left/top/width/height
    var boxLayoutOption = grid3DModel.getBoxLayoutParams();
    var viewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutRect"])(boxLayoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
    }); // Flip Y
    viewport.y = api.getHeight() - viewport.y - viewport.height;
    this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
    var boxWidth = grid3DModel.get('boxWidth');
    var boxHeight = grid3DModel.get('boxHeight');
    var boxDepth = grid3DModel.get('boxDepth');
    if ("TURBOPACK compile-time truthy", 1) {
        [
            'x',
            'y',
            'z'
        ].forEach(function(dim) {
            if (!this.getAxis(dim)) {
                throw new Error('Grid' + grid3DModel.id + ' don\'t have ' + dim + 'Axis');
            }
        }, this);
    }
    this.getAxis('x').setExtent(-boxWidth / 2, boxWidth / 2); // From near to far
    this.getAxis('y').setExtent(boxDepth / 2, -boxDepth / 2);
    this.getAxis('z').setExtent(-boxHeight / 2, boxHeight / 2);
    this.size = [
        boxWidth,
        boxHeight,
        boxDepth
    ];
}
function updateCartesian3D(ecModel, api) {
    var dataExtents = {};
    function unionDataExtents(dim, extent) {
        dataExtents[dim] = dataExtents[dim] || [
            Infinity,
            -Infinity
        ];
        dataExtents[dim][0] = Math.min(extent[0], dataExtents[dim][0]);
        dataExtents[dim][1] = Math.max(extent[1], dataExtents[dim][1]);
    } // Get data extents for scale.
    ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem !== this) {
            return;
        }
        var data = seriesModel.getData();
        [
            'x',
            'y',
            'z'
        ].forEach(function(coordDim) {
            data.mapDimensionsAll(coordDim, true).forEach(function(dataDim) {
                unionDataExtents(coordDim, data.getDataExtent(dataDim, true));
            });
        });
    }, this);
    [
        'xAxis3D',
        'yAxis3D',
        'zAxis3D'
    ].forEach(function(axisType) {
        ecModel.eachComponent(axisType, function(axisModel) {
            var dim = axisType.charAt(0);
            var grid3DModel = axisModel.getReferringComponents('grid3D').models[0];
            var cartesian3D = grid3DModel.coordinateSystem;
            if (cartesian3D !== this) {
                return;
            }
            var axis = cartesian3D.getAxis(dim);
            if (axis) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn('Can\'t have two %s in one grid3D', axisType);
                }
                return;
            }
            var scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createScale(dataExtents[dim] || [
                Infinity,
                -Infinity
            ], axisModel);
            axis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3D$2f$Axis3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dim, scale);
            axis.type = axisModel.get('type');
            var isCategory = axis.type === 'category';
            axis.onBand = isCategory && axisModel.get('boundaryGap');
            axis.inverse = axisModel.get('inverse');
            axisModel.axis = axis;
            axis.model = axisModel; // override `echarts/coord/Axis#getLabelModel`
            axis.getLabelModel = function() {
                return axisModel.getModel('axisLabel', grid3DModel.getModel('axisLabel'));
            }; // override `echarts/coord/Axis#getTickModel`
            axis.getTickModel = function() {
                return axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));
            };
            cartesian3D.addAxis(axis);
        }, this);
    }, this);
    this.resize(this.model, api);
}
var grid3DCreator = {
    dimensions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3D$2f$Cartesian3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.dimensions,
    create: function(ecModel, api) {
        var cartesian3DList = [];
        ecModel.eachComponent('grid3D', function(grid3DModel) {
            // FIXME
            grid3DModel.__viewGL = grid3DModel.__viewGL || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            var cartesian3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3D$2f$Cartesian3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            cartesian3D.model = grid3DModel;
            cartesian3D.viewGL = grid3DModel.__viewGL;
            grid3DModel.coordinateSystem = cartesian3D;
            cartesian3DList.push(cartesian3D); // Inject resize and update
            cartesian3D.resize = resizeCartesian3D;
            cartesian3D.update = updateCartesian3D;
        });
        var axesTypes = [
            'xAxis3D',
            'yAxis3D',
            'zAxis3D'
        ];
        function findAxesModels(seriesModel, ecModel) {
            return axesTypes.map(function(axisType) {
                var axisModel = seriesModel.getReferringComponents(axisType).models[0];
                if (axisModel == null) {
                    axisModel = ecModel.getComponent(axisType);
                }
                if ("TURBOPACK compile-time truthy", 1) {
                    if (!axisModel) {
                        throw new Error(axisType + ' "' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found');
                    }
                }
                return axisModel;
            });
        }
        ecModel.eachSeries(function(seriesModel) {
            if (seriesModel.get('coordinateSystem') !== 'cartesian3D') {
                return;
            }
            var firstGridModel = seriesModel.getReferringComponents('grid3D').models[0];
            if (firstGridModel == null) {
                var axesModels = findAxesModels(seriesModel, ecModel);
                var firstGridModel = axesModels[0].getCoordSysModel();
                axesModels.forEach(function(axisModel) {
                    var grid3DModel = axisModel.getCoordSysModel();
                    if ("TURBOPACK compile-time truthy", 1) {
                        if (!grid3DModel) {
                            throw new Error('grid3D "' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(axisModel.get('gridIndex'), axisModel.get('gridId'), 0) + '" not found');
                        }
                        if (grid3DModel !== firstGridModel) {
                            throw new Error('xAxis3D, yAxis3D, zAxis3D must use the same grid');
                        }
                    }
                });
            }
            var coordSys = firstGridModel.coordinateSystem;
            seriesModel.coordinateSystem = coordSys;
        });
        return cartesian3DList;
    }
};
const __TURBOPACK__default__export__ = grid3DCreator;
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/Axis3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
;
var Axis3DModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'cartesian3DAxis',
    axis: null,
    /**
   * @override
   */ getCoordSysModel: function() {
        return this.ecModel.queryComponents({
            mainType: 'grid3D',
            index: this.option.gridIndex,
            id: this.option.gridId
        })[0];
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].mixinAxisModelCommonMethods(Axis3DModel);
const __TURBOPACK__default__export__ = Axis3DModel;
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/axis3DDefault.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
;
var defaultOption = {
    show: true,
    grid3DIndex: 0,
    // 反向坐标轴
    inverse: false,
    // 坐标轴名字
    name: '',
    // 坐标轴名字位置
    nameLocation: 'middle',
    nameTextStyle: {
        fontSize: 16
    },
    // 文字与轴线距离
    nameGap: 20,
    axisPointer: {},
    axisLine: {},
    // 坐标轴小标记
    axisTick: {},
    axisLabel: {},
    // 分隔区域
    splitArea: {}
};
var categoryAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge({
    // 类目起始和结束两端空白策略
    boundaryGap: true,
    // splitArea: {
    // show: false
    // },
    // 坐标轴小标记
    axisTick: {
        // If tick is align with label when boundaryGap is true
        // Default with axisTick
        alignWithLabel: false,
        interval: 'auto'
    },
    // 坐标轴文本标签，详见axis.axisLabel
    axisLabel: {
        interval: 'auto'
    },
    axisPointer: {
        label: {
            show: false
        }
    }
}, defaultOption);
var valueAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge({
    // 数值起始和结束两端空白策略
    boundaryGap: [
        0,
        0
    ],
    // 最小值, 设置成 'dataMin' 则从数据中计算最小值
    // min: null,
    // 最大值，设置成 'dataMax' 则从数据中计算最大值
    // max: null,
    // 脱离0值比例，放大聚焦到最终_min，_max区间
    // scale: false,
    // 分割段数，默认为5
    splitNumber: 5,
    // Minimum interval
    // minInterval: null
    axisPointer: {
        label: {}
    }
}, defaultOption); // FIXME
var timeAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults({
    scale: true,
    min: 'dataMin',
    max: 'dataMax'
}, valueAxis);
var logAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults({
    logBase: 10
}, valueAxis);
logAxis.scale = true;
const __TURBOPACK__default__export__ = {
    categoryAxis3D: categoryAxis,
    valueAxis3D: valueAxis,
    timeAxis3D: timeAxis,
    logAxis3D: logAxis
};
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/createAxis3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$axis3DDefault$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/axis3DDefault.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$OrdinalMeta$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/OrdinalMeta.js [app-client] (ecmascript)");
;
;
;
var AXIS_TYPES = [
    'value',
    'category',
    'time',
    'log'
];
function __TURBOPACK__default__export__(registers, dim, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
    AXIS_TYPES.forEach(function(axisType) {
        var AxisModel = BaseAxisModelClass.extend({
            type: dim + 'Axis3D.' + axisType,
            /**
       * @type readOnly
       */ __ordinalMeta: null,
            mergeDefaultAndTheme: function(option, ecModel) {
                var themeModel = ecModel.getTheme();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(option, themeModel.get(axisType + 'Axis3D'));
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(option, this.getDefaultOption());
                option.type = axisTypeDefaulter(dim, option);
            },
            /**
       * @override
       */ optionUpdated: function() {
                var thisOption = this.option;
                if (thisOption.type === 'category') {
                    this.__ordinalMeta = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$OrdinalMeta$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createByAxisModel(this);
                }
            },
            getCategories: function() {
                if (this.option.type === 'category') {
                    return this.__ordinalMeta.categories;
                }
            },
            getOrdinalMeta: function() {
                return this.__ordinalMeta;
            },
            defaultOption: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$axis3DDefault$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][axisType + 'Axis3D']), extraDefaultOption || {}, true)
        });
        registers.registerComponentModel(AxisModel);
    }); // TODO
    registers.registerSubTypeDefaulter(dim + 'Axis3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].curry(axisTypeDefaulter, dim));
}
;
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/Grid3DView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/grid3DCreator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Axis3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/Axis3DModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$createAxis3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/createAxis3DModel.js [app-client] (ecmascript)");
;
;
;
;
;
;
function getAxisType(axisDim, option) {
    // Default axis with data is category axis
    return option.type || (option.data ? 'category' : 'value');
}
function install(registers) {
    registers.registerComponentModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerComponentView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Grid3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerCoordinateSystem('grid3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$grid3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    [
        'x',
        'y',
        'z'
    ].forEach(function(dim) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$createAxis3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(registers, dim, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$Axis3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], getAxisType, {
            name: dim.toUpperCase()
        });
        const AxisView = registers.ComponentView.extend({
            type: dim + 'Axis3D'
        });
        registers.registerComponentView(AxisView);
    });
    registers.registerAction({
        type: 'grid3DChangeCamera',
        event: 'grid3dcamerachanged',
        update: 'series:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'grid3D',
            query: payload
        }, function(componentModel) {
            componentModel.setView(payload);
        });
    });
    registers.registerAction({
        type: 'grid3DShowAxisPointer',
        event: 'grid3dshowaxispointer',
        update: 'grid3D:showAxisPointer'
    }, function(payload, ecModel) {});
    registers.registerAction({
        type: 'grid3DHideAxisPointer',
        event: 'grid3dhideaxispointer',
        update: 'grid3D:hideAxisPointer'
    }, function(payload, ecModel) {});
}
}}),
"[project]/node_modules/echarts-gl/lib/component/grid3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = {
    defaultOption: {
        shading: null,
        realisticMaterial: {
            textureTiling: 1,
            textureOffset: 0,
            detailTexture: null
        },
        lambertMaterial: {
            textureTiling: 1,
            textureOffset: 0,
            detailTexture: null
        },
        colorMaterial: {
            textureTiling: 1,
            textureOffset: 0,
            detailTexture: null
        },
        hatchingMaterial: {
            textureTiling: 1,
            textureOffset: 0,
            paperColor: '#fff'
        }
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/coord/geo3D/geo3DModelMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/core/echarts.js [app-client] (ecmascript) <locals>");
;
const __TURBOPACK__default__export__ = {
    getFilledRegions: function(regions, mapData) {
        var regionsArr = (regions || []).slice();
        var geoJson;
        if (typeof mapData === 'string') {
            mapData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getMap"])(mapData);
            geoJson = mapData && mapData.geoJson;
        } else {
            if (mapData && mapData.features) {
                geoJson = mapData;
            }
        }
        if (!geoJson) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.error('Map ' + mapData + ' not exists. You can download map file on http://echarts.baidu.com/download-map.html');
                if (!geoJson.features) {
                    console.error('Invalid GeoJSON for map3D');
                }
            }
            return [];
        }
        var dataNameMap = {};
        var features = geoJson.features;
        for(var i = 0; i < regionsArr.length; i++){
            dataNameMap[regionsArr[i].name] = regionsArr[i];
        }
        for(var i = 0; i < features.length; i++){
            var name = features[i].properties.name;
            if (!dataNameMap[name]) {
                regionsArr.push({
                    name: name
                });
            }
        }
        return regionsArr;
    },
    defaultOption: {
        show: true,
        zlevel: -10,
        // geoJson used by geo3D
        map: '',
        // Layout used for viewport
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        boxWidth: 100,
        boxHeight: 10,
        boxDepth: 'auto',
        regionHeight: 3,
        environment: 'auto',
        groundPlane: {
            show: false,
            color: '#aaa'
        },
        shading: 'lambert',
        light: {
            main: {
                alpha: 40,
                beta: 30
            }
        },
        viewControl: {
            alpha: 40,
            beta: 0,
            distance: 100,
            orthographicSize: 60,
            minAlpha: 5,
            minBeta: -80,
            maxBeta: 80
        },
        label: {
            show: false,
            // Distance in 3d space.
            distance: 2,
            textStyle: {
                fontSize: 20,
                color: '#000',
                backgroundColor: 'rgba(255,255,255,0.7)',
                padding: 3,
                borderRadius: 4
            }
        },
        // TODO
        // altitude: {
        //     min: 'auto',
        //     max: 'auto',
        //     height: []
        // },
        // labelLine
        // light
        // postEffect
        // temporalSuperSampling
        itemStyle: {
            color: '#fff',
            borderWidth: 0,
            borderColor: '#333'
        },
        emphasis: {
            itemStyle: {
                // color: '#f94b59'
                color: '#639fc0'
            },
            label: {
                show: true
            }
        }
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/component/geo3D/Geo3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Model.js [app-client] (ecmascript) <export default as Model>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentViewControlMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$geo3DModelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/geo3D/geo3DModelMixin.js [app-client] (ecmascript)");
;
;
;
;
;
;
var Geo3DModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'geo3D',
    layoutMode: 'box',
    coordinateSystem: null,
    optionUpdated: function() {
        var option = this.option;
        option.regions = this.getFilledRegions(option.regions, option.map);
        var dimensions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createDimensions(option.data || [], {
            coordDimensions: [
                'value'
            ],
            encodeDefine: this.get('encode'),
            dimensionsDefine: this.get('dimensions')
        });
        var list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"](dimensions, this);
        list.initData(option.regions);
        var regionModelMap = {};
        list.each(function(idx) {
            var name = list.getName(idx);
            var itemModel = list.getItemModel(idx);
            regionModelMap[name] = itemModel;
        });
        this._regionModelMap = regionModelMap;
        this._data = list;
    },
    getData: function() {
        return this._data;
    },
    getRegionModel: function(idx) {
        var name = this.getData().getName(idx);
        return this._regionModelMap[name] || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__["Model"](null, this);
    },
    getRegionPolygonCoords: function(idx) {
        var name = this.getData().getName(idx);
        var region = this.coordinateSystem.getRegion(name);
        return region ? region.geometries : [];
    },
    /**
   * Format label
   * @param {string} name Region name
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @return {string}
   */ getFormattedLabel: function(dataIndex, status) {
        var name = this._data.getName(dataIndex);
        var regionModel = this.getRegionModel(dataIndex);
        var formatter = regionModel.get(status === 'normal' ? [
            'label',
            'formatter'
        ] : [
            'emphasis',
            'label',
            'formatter'
        ]);
        if (formatter == null) {
            formatter = regionModel.get([
                'label',
                'formatter'
            ]);
        }
        var params = {
            name: name
        };
        if (typeof formatter === 'function') {
            params.status = status;
            return formatter(params);
        } else if (typeof formatter === 'string') {
            var serName = params.seriesName;
            return formatter.replace('{a}', serName != null ? serName : '');
        } else {
            return name;
        }
    },
    defaultOption: {
        // itemStyle: {},
        // height,
        // label: {}
        // realisticMaterial
        regions: []
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Geo3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$geo3DModelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Geo3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Geo3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Geo3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Geo3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Geo3DModel;
}}),
"[project]/node_modules/echarts-gl/lib/util/earcut.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// https://github.com/mapbox/earcut/blob/master/src/earcut.js
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode) return triangles;
    var minX, minY, maxX, maxY, x, y, size;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        } // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, size);
    return triangles;
} // create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
} // eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return; // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);
    var stop = ear, prev, next; // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear); // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next; // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1); // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2); // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }
            break;
        }
    }
} // check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size); // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;
    while(p && p.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    } // then look for points in decreasing z-order
    p = ear.prevZ;
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    return true;
} // go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim); // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return p;
} // try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b); // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next); // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
} // link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX); // process holes from left to right
    for(i = 0; i < queue.length; i++){
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m; // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m.next;
    while(p !== stop){
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }
    return m;
} // interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
} // z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
} // find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
} // check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
} // signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
} // check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
} // check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i; // vertex coordinates
    this.x = x;
    this.y = y; // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null; // z-order curve value
    this.z = null; // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null; // indicates whether this is a steiner point
    this.steiner = false;
} // return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
}}),
"[project]/node_modules/echarts-gl/lib/util/ProgressiveQuickSort.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function swap(arr, a, b) {
    var tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}
function partition(arr, pivot, left, right, compare) {
    var storeIndex = left;
    var pivotValue = arr[pivot]; // put the pivot on the right
    swap(arr, pivot, right); // go through the rest
    for(var v = left; v < right; v++){
        if (compare(arr[v], pivotValue) < 0) {
            swap(arr, v, storeIndex);
            storeIndex++;
        }
    } // finally put the pivot in the correct place
    swap(arr, right, storeIndex);
    return storeIndex;
}
function quickSort(array, compare, left, right) {
    if (left < right) {
        var pivot = Math.floor((left + right) / 2);
        var newPivot = partition(array, pivot, left, right, compare);
        quickSort(array, compare, left, newPivot - 1);
        quickSort(array, compare, newPivot + 1, right);
    }
} // TODO Test.
function ProgressiveQuickSort() {
    // this._pivotList = new LinkedList();
    this._parts = [];
}
ProgressiveQuickSort.prototype.step = function(arr, compare, frame) {
    var len = arr.length;
    if (frame === 0) {
        this._parts = [];
        this._sorted = false; // Pick a start pivot;
        var pivot = Math.floor(len / 2);
        this._parts.push({
            pivot: pivot,
            left: 0,
            right: len - 1
        });
        this._currentSortPartIdx = 0;
    }
    if (this._sorted) {
        return;
    }
    var parts = this._parts;
    if (parts.length === 0) {
        this._sorted = true; // Already finished.
        return true;
    } else if (parts.length < 512) {
        // Sort large parts in about 10 frames.
        for(var i = 0; i < parts.length; i++){
            // Partition and Modify the pivot index.
            parts[i].pivot = partition(arr, parts[i].pivot, parts[i].left, parts[i].right, compare);
        }
        var subdividedParts = [];
        for(var i = 0; i < parts.length; i++){
            // Subdivide left
            var left = parts[i].left;
            var right = parts[i].pivot - 1;
            if (right > left) {
                subdividedParts.push({
                    pivot: Math.floor((right + left) / 2),
                    left: left,
                    right: right
                });
            } // Subdivide right
            var left = parts[i].pivot + 1;
            var right = parts[i].right;
            if (right > left) {
                subdividedParts.push({
                    pivot: Math.floor((right + left) / 2),
                    left: left,
                    right: right
                });
            }
        }
        parts = this._parts = subdividedParts;
    } else {
        // console.time('sort');
        // Finally quick sort each parts in 10 frames.
        for(var i = 0; i < Math.floor(parts.length / 10); i++){
            // Sort near parts first.
            var idx = parts.length - 1 - this._currentSortPartIdx;
            quickSort(arr, compare, parts[idx].left, parts[idx].right);
            this._currentSortPartIdx++; // Finish sort
            if (this._currentSortPartIdx === parts.length) {
                this._sorted = true;
                return true;
            }
        } // console.timeEnd('sort');
    }
    return false;
};
ProgressiveQuickSort.sort = quickSort;
const __TURBOPACK__default__export__ = ProgressiveQuickSort;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/trianglesSortMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/ProgressiveQuickSort.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var p0 = vec3.create();
var p1 = vec3.create();
var p2 = vec3.create(); // var cp = vec3.create();
const __TURBOPACK__default__export__ = {
    needsSortTriangles: function() {
        return this.indices && this.sortTriangles;
    },
    needsSortTrianglesProgressively: function() {
        return this.needsSortTriangles() && this.triangleCount >= 2e4;
    },
    doSortTriangles: function(cameraPos, frame) {
        var indices = this.indices; // Do progressive quick sort.
        if (frame === 0) {
            var posAttr = this.attributes.position;
            var cameraPos = cameraPos.array;
            if (!this._triangleZList || this._triangleZList.length !== this.triangleCount) {
                this._triangleZList = new Float32Array(this.triangleCount);
                this._sortedTriangleIndices = new Uint32Array(this.triangleCount);
                this._indicesTmp = new indices.constructor(indices.length);
                this._triangleZListTmp = new Float32Array(this.triangleCount);
            }
            var cursor = 0;
            var firstZ;
            for(var i = 0; i < indices.length;){
                posAttr.get(indices[i++], p0);
                posAttr.get(indices[i++], p1);
                posAttr.get(indices[i++], p2); // FIXME If use center ?
                // cp[0] = (p0[0] + p1[0] + p2[0]) / 3;
                // cp[1] = (p0[1] + p1[1] + p2[1]) / 3;
                // cp[2] = (p0[2] + p1[2] + p2[2]) / 3;
                // Camera position is in object space
                // Use max of three points, PENDING
                var z0 = vec3.sqrDist(p0, cameraPos);
                var z1 = vec3.sqrDist(p1, cameraPos);
                var z2 = vec3.sqrDist(p2, cameraPos);
                var zMax = Math.min(z0, z1);
                zMax = Math.min(zMax, z2);
                if (i === 3) {
                    firstZ = zMax;
                    zMax = 0;
                } else {
                    // Only store the difference to avoid the precision issue.
                    zMax = zMax - firstZ;
                }
                this._triangleZList[cursor++] = zMax;
            }
        }
        var sortedTriangleIndices = this._sortedTriangleIndices;
        for(var i = 0; i < sortedTriangleIndices.length; i++){
            sortedTriangleIndices[i] = i;
        }
        if (this.triangleCount < 2e4) {
            // Use simple timsort for simple geometries.
            if (frame === 0) {
                // Use native sort temporary.
                this._simpleSort(true);
            }
        } else {
            for(var i = 0; i < 3; i++){
                this._progressiveQuickSort(frame * 3 + i);
            }
        }
        var targetIndices = this._indicesTmp;
        var targetTriangleZList = this._triangleZListTmp;
        var faceZList = this._triangleZList;
        for(var i = 0; i < this.triangleCount; i++){
            var fromIdx3 = sortedTriangleIndices[i] * 3;
            var toIdx3 = i * 3;
            targetIndices[toIdx3++] = indices[fromIdx3++];
            targetIndices[toIdx3++] = indices[fromIdx3++];
            targetIndices[toIdx3] = indices[fromIdx3];
            targetTriangleZList[i] = faceZList[sortedTriangleIndices[i]];
        } // Swap indices.
        var tmp = this._indicesTmp;
        this._indicesTmp = this.indices;
        this.indices = tmp;
        var tmp = this._triangleZListTmp;
        this._triangleZListTmp = this._triangleZList;
        this._triangleZList = tmp;
        this.dirtyIndices();
    },
    _simpleSort: function(useNativeQuickSort) {
        var faceZList = this._triangleZList;
        var sortedTriangleIndices = this._sortedTriangleIndices;
        function compare(a, b) {
            // Sort from far to near. which is descending order
            return faceZList[b] - faceZList[a];
        }
        if (useNativeQuickSort) {
            Array.prototype.sort.call(sortedTriangleIndices, compare);
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].sort(sortedTriangleIndices, compare, 0, sortedTriangleIndices.length - 1);
        }
    },
    _progressiveQuickSort: function(frame) {
        var faceZList = this._triangleZList;
        var sortedTriangleIndices = this._sortedTriangleIndices;
        this._quickSort = this._quickSort || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._quickSort.step(sortedTriangleIndices, function(a, b) {
            return faceZList[b] - faceZList[a];
        }, frame);
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getItemVisualColor": (()=>getItemVisualColor),
    "getItemVisualOpacity": (()=>getItemVisualOpacity),
    "getVisualColor": (()=>getVisualColor),
    "getVisualOpacity": (()=>getVisualOpacity)
});
function getVisualColor(data) {
    const style = data.getVisual('style');
    if (style) {
        const drawType = data.getVisual('drawType');
        return style[drawType];
    }
}
function getVisualOpacity(data) {
    const style = data.getVisual('style');
    return style.opacity;
}
function getItemVisualColor(data, idx) {
    const style = data.getItemVisual(idx, 'style');
    if (style) {
        const drawType = data.getVisual('drawType');
        return style[drawType];
    }
}
function getItemVisualOpacity(data, idx) {
    const style = data.getItemVisual(idx, 'style');
    return style && style.opacity;
}
}}),
"[project]/node_modules/echarts-gl/lib/component/common/LabelsBuilder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ZRTextureAtlasSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/ZRTextureAtlasSurface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/mesh/LabelsMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/label/labelStyle.js [app-client] (ecmascript)");
;
;
;
;
;
;
var LABEL_NORMAL_SHOW_BIT = 1;
var LABEL_EMPHASIS_SHOW_BIT = 2;
function LabelsBuilder(width, height, api) {
    this._labelsMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$mesh$2f$LabelsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    this._labelTextureSurface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ZRTextureAtlasSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        width: 512,
        height: 512,
        devicePixelRatio: api.getDevicePixelRatio(),
        onupdate: function() {
            api.getZr().refresh();
        }
    });
    this._api = api;
    this._labelsMesh.material.set('textureAtlas', this._labelTextureSurface.getTexture());
}
LabelsBuilder.prototype.getLabelPosition = function(dataIndex, positionDesc, distance) {
    return [
        0,
        0,
        0
    ];
};
LabelsBuilder.prototype.getLabelDistance = function(dataIndex, positionDesc, distance) {
    return 0;
};
LabelsBuilder.prototype.getMesh = function() {
    return this._labelsMesh;
};
LabelsBuilder.prototype.updateData = function(data, start, end) {
    if (start == null) {
        start = 0;
    }
    if (end == null) {
        end = data.count();
    }
    if (!this._labelsVisibilitiesBits || this._labelsVisibilitiesBits.length !== end - start) {
        this._labelsVisibilitiesBits = new Uint8Array(end - start);
    }
    var normalLabelVisibilityQuery = [
        'label',
        'show'
    ];
    var emphasisLabelVisibilityQuery = [
        'emphasis',
        'label',
        'show'
    ];
    for(var idx = start; idx < end; idx++){
        var itemModel = data.getItemModel(idx);
        var normalVisibility = itemModel.get(normalLabelVisibilityQuery);
        var emphasisVisibility = itemModel.get(emphasisLabelVisibilityQuery);
        if (emphasisVisibility == null) {
            emphasisVisibility = normalVisibility;
        }
        var bit = (normalVisibility ? LABEL_NORMAL_SHOW_BIT : 0) | (emphasisVisibility ? LABEL_EMPHASIS_SHOW_BIT : 0);
        this._labelsVisibilitiesBits[idx - start] = bit;
    }
    this._start = start;
    this._end = end;
    this._data = data;
};
LabelsBuilder.prototype.updateLabels = function(highlightDataIndices) {
    if (!this._data) {
        return;
    }
    highlightDataIndices = highlightDataIndices || [];
    var hasHighlightData = highlightDataIndices.length > 0;
    var highlightDataIndicesMap = {};
    for(var i = 0; i < highlightDataIndices.length; i++){
        highlightDataIndicesMap[highlightDataIndices[i]] = true;
    }
    this._labelsMesh.geometry.convertToDynamicArray(true);
    this._labelTextureSurface.clear();
    var normalLabelQuery = [
        'label'
    ];
    var emphasisLabelQuery = [
        'emphasis',
        'label'
    ];
    var seriesModel = this._data.hostModel;
    var data = this._data;
    var seriesLabelModel = seriesModel.getModel(normalLabelQuery);
    var seriesLabelEmphasisModel = seriesModel.getModel(emphasisLabelQuery, seriesLabelModel);
    var textAlignMap = {
        left: 'right',
        right: 'left',
        top: 'center',
        bottom: 'center'
    };
    var textVerticalAlignMap = {
        left: 'middle',
        right: 'middle',
        top: 'bottom',
        bottom: 'top'
    };
    for(var dataIndex = this._start; dataIndex < this._end; dataIndex++){
        var isEmphasis = false;
        if (hasHighlightData && highlightDataIndicesMap[dataIndex]) {
            isEmphasis = true;
        }
        var ifShow = this._labelsVisibilitiesBits[dataIndex - this._start] & (isEmphasis ? LABEL_EMPHASIS_SHOW_BIT : LABEL_NORMAL_SHOW_BIT);
        if (!ifShow) {
            continue;
        }
        var itemModel = data.getItemModel(dataIndex);
        var labelModel = itemModel.getModel(isEmphasis ? emphasisLabelQuery : normalLabelQuery, isEmphasis ? seriesLabelEmphasisModel : seriesLabelModel);
        var distance = labelModel.get('distance') || 0;
        var position = labelModel.get('position');
        var dpr = this._api.getDevicePixelRatio();
        var text = seriesModel.getFormattedLabel(dataIndex, isEmphasis ? 'emphasis' : 'normal');
        if (text == null || text === '') {
            return;
        } // TODO Background.
        var textEl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].Text({
            style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$label$2f$labelStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextStyle"])(labelModel, {
                text: text,
                fill: labelModel.get('color') || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex) || '#000',
                align: 'left',
                verticalAlign: 'top',
                opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(labelModel.get('opacity'), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex), 1)
            })
        });
        var rect = textEl.getBoundingRect();
        var lineHeight = 1.2;
        rect.height *= lineHeight;
        var coords = this._labelTextureSurface.add(textEl);
        var textAlign = textAlignMap[position] || 'center';
        var textVerticalAlign = textVerticalAlignMap[position] || 'bottom';
        this._labelsMesh.geometry.addSprite(this.getLabelPosition(dataIndex, position, distance), [
            rect.width * dpr,
            rect.height * dpr
        ], coords, textAlign, textVerticalAlign, this.getLabelDistance(dataIndex, position, distance) * dpr);
    }
    this._labelsMesh.material.set('uvScale', this._labelTextureSurface.getCoordsScale()); // var canvas = this._labelTextureSurface.getTexture().image;
    // document.body.appendChild(canvas);
    // canvas.style.cssText = 'position:absolute;z-index: 1000';
    // Update image.
    this._labelTextureSurface.getZr().refreshImmediately();
    this._labelsMesh.geometry.convertToTypedArray();
    this._labelsMesh.geometry.dirty();
};
LabelsBuilder.prototype.dispose = function() {
    this._labelTextureSurface.dispose();
};
const __TURBOPACK__default__export__ = LabelsBuilder;
}}),
"[project]/node_modules/echarts-gl/lib/component/common/Geo3DBuilder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/tool/color.js [app-client] (ecmascript) <export * as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/earcut.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/trianglesSortMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/LabelsBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lines3D.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function Geo3DBuilder(api) {
    this.rootNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node(); // Cache triangulation result
    this._triangulationResults = {};
    this._shadersMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COMMON_SHADERS.filter(function(shaderName) {
        return shaderName !== 'shadow';
    }).reduce(function(obj, shaderName) {
        obj[shaderName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.' + shaderName);
        return obj;
    }, {});
    this._linesShader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines3D');
    var groundMaterials = {};
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].COMMON_SHADERS.forEach(function(shading) {
        groundMaterials[shading] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.' + shading)
        });
    });
    this._groundMaterials = groundMaterials;
    this._groundMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PlaneGeometry({
            dynamic: true
        }),
        castShadow: false,
        renderNormal: true,
        $ignorePicking: true
    });
    this._groundMesh.rotation.rotateX(-Math.PI / 2);
    this._labelsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](512, 512, api); // Give a large render order.
    this._labelsBuilder.getMesh().renderOrder = 100;
    this._labelsBuilder.getMesh().material.depthTest = false;
    this.rootNode.add(this._labelsBuilder.getMesh());
    this._initMeshes();
    this._api = api;
}
Geo3DBuilder.prototype = {
    constructor: Geo3DBuilder,
    // Which dimension to extrude. Y or Z
    extrudeY: true,
    update: function(componentModel, ecModel, api, start, end) {
        var data = componentModel.getData();
        if (start == null) {
            start = 0;
        }
        if (end == null) {
            end = data.count();
        }
        this._startIndex = start;
        this._endIndex = end - 1;
        this._triangulation(componentModel, start, end);
        var shader = this._getShader(componentModel.get('shading'));
        this._prepareMesh(componentModel, shader, api, start, end);
        this.rootNode.updateWorldTransform();
        this._updateRegionMesh(componentModel, api, start, end);
        var coordSys = componentModel.coordinateSystem; // PENDING
        if (coordSys.type === 'geo3D') {
            this._updateGroundPlane(componentModel, coordSys, api);
        }
        var self = this;
        this._labelsBuilder.updateData(data, start, end);
        this._labelsBuilder.getLabelPosition = function(dataIndex, positionDesc, distance) {
            var name = data.getName(dataIndex);
            var center;
            var height = distance;
            if (coordSys.type === 'geo3D') {
                var region = coordSys.getRegion(name);
                if (!region) {
                    return [
                        NaN,
                        NaN,
                        NaN
                    ];
                }
                center = region.getCenter();
                var pos = coordSys.dataToPoint([
                    center[0],
                    center[1],
                    height
                ]);
                return pos;
            } else {
                var tmp = self._triangulationResults[dataIndex - self._startIndex];
                var center = self.extrudeY ? [
                    (tmp.max[0] + tmp.min[0]) / 2,
                    tmp.max[1] + height,
                    (tmp.max[2] + tmp.min[2]) / 2
                ] : [
                    (tmp.max[0] + tmp.min[0]) / 2,
                    (tmp.max[1] + tmp.min[1]) / 2,
                    tmp.max[2] + height
                ];
            }
        };
        this._data = data;
        this._labelsBuilder.updateLabels();
        this._updateDebugWireframe(componentModel); // Reset some state.
        this._lastHoverDataIndex = 0;
    },
    _initMeshes: function() {
        var self = this;
        function createPolygonMesh() {
            var mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
                name: 'Polygon',
                material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                    shader: self._shadersMap.lambert
                }),
                geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
                    sortTriangles: true,
                    dynamic: true
                }),
                // TODO Disable culling
                culling: false,
                ignorePicking: true,
                // Render normal in normal pass
                renderNormal: true
            });
            Object.assign(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
            return mesh;
        }
        var polygonMesh = createPolygonMesh();
        var linesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: this._linesShader
            }),
            castShadow: false,
            ignorePicking: true,
            $ignorePicking: true,
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                useNativeLine: false
            })
        });
        this.rootNode.add(polygonMesh);
        this.rootNode.add(linesMesh);
        polygonMesh.material.define('both', 'VERTEX_COLOR');
        polygonMesh.material.define('fragment', 'DOUBLE_SIDED');
        this._polygonMesh = polygonMesh;
        this._linesMesh = linesMesh;
        this.rootNode.add(this._groundMesh);
    },
    _getShader: function(shading) {
        var shader = this._shadersMap[shading];
        if (!shader) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Unkown shading ' + shading);
            } // Default use lambert shader.
            shader = this._shadersMap.lambert;
        }
        shader.__shading = shading;
        return shader;
    },
    _prepareMesh: function(componentModel, shader, api, start, end) {
        var polygonVertexCount = 0;
        var polygonTriangleCount = 0;
        var linesVertexCount = 0;
        var linesTriangleCount = 0; // TODO Lines
        for(var idx = start; idx < end; idx++){
            var polyInfo = this._getRegionPolygonInfo(idx);
            var lineInfo = this._getRegionLinesInfo(idx, componentModel, this._linesMesh.geometry);
            polygonVertexCount += polyInfo.vertexCount;
            polygonTriangleCount += polyInfo.triangleCount;
            linesVertexCount += lineInfo.vertexCount;
            linesTriangleCount += lineInfo.triangleCount;
        }
        var polygonMesh = this._polygonMesh;
        var polygonGeo = polygonMesh.geometry;
        [
            'position',
            'normal',
            'texcoord0',
            'color'
        ].forEach(function(attrName) {
            polygonGeo.attributes[attrName].init(polygonVertexCount);
        });
        polygonGeo.indices = polygonVertexCount > 0xffff ? new Uint32Array(polygonTriangleCount * 3) : new Uint16Array(polygonTriangleCount * 3);
        if (polygonMesh.material.shader !== shader) {
            polygonMesh.material.attachShader(shader, true);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setMaterialFromModel(shader.__shading, polygonMesh.material, componentModel, api);
        if (linesVertexCount > 0) {
            this._linesMesh.geometry.resetOffset();
            this._linesMesh.geometry.setVertexCount(linesVertexCount);
            this._linesMesh.geometry.setTriangleCount(linesTriangleCount);
        } // Indexing data index from vertex index.
        this._dataIndexOfVertex = new Uint32Array(polygonVertexCount); // Indexing vertex index range from data index
        this._vertexRangeOfDataIndex = new Uint32Array((end - start) * 2);
    },
    _updateRegionMesh: function(componentModel, api, start, end) {
        var data = componentModel.getData();
        var vertexOffset = 0;
        var triangleOffset = 0; // Materials configurations.
        var hasTranparentRegion = false;
        var polygonMesh = this._polygonMesh;
        var linesMesh = this._linesMesh;
        for(var dataIndex = start; dataIndex < end; dataIndex++){
            // Get bunch of visual properties.
            var regionModel = componentModel.getRegionModel(dataIndex);
            var itemStyleModel = regionModel.getModel('itemStyle');
            var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex), itemStyleModel.get('color'), '#fff');
            var opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex), itemStyleModel.get('opacity'), 1);
            var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
            var borderColorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(itemStyleModel.get('borderColor'));
            colorArr[3] *= opacity;
            borderColorArr[3] *= opacity;
            var isTransparent = colorArr[3] < 0.99;
            polygonMesh.material.set('color', [
                1,
                1,
                1,
                1
            ]);
            hasTranparentRegion = hasTranparentRegion || isTransparent;
            var regionHeight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(regionModel.get('height', true), componentModel.get('regionHeight'));
            var newOffsets = this._updatePolygonGeometry(componentModel, polygonMesh.geometry, dataIndex, regionHeight, vertexOffset, triangleOffset, colorArr);
            for(var i = vertexOffset; i < newOffsets.vertexOffset; i++){
                this._dataIndexOfVertex[i] = dataIndex;
            }
            this._vertexRangeOfDataIndex[(dataIndex - start) * 2] = vertexOffset;
            this._vertexRangeOfDataIndex[(dataIndex - start) * 2 + 1] = newOffsets.vertexOffset;
            vertexOffset = newOffsets.vertexOffset;
            triangleOffset = newOffsets.triangleOffset; // Update lines.
            var lineWidth = itemStyleModel.get('borderWidth');
            var hasLine = lineWidth > 0;
            if (hasLine) {
                lineWidth *= api.getDevicePixelRatio();
                this._updateLinesGeometry(linesMesh.geometry, componentModel, dataIndex, regionHeight, lineWidth, componentModel.coordinateSystem.transform);
            }
            linesMesh.invisible = !hasLine;
            linesMesh.material.set({
                color: borderColorArr
            });
        }
        var polygonMesh = this._polygonMesh;
        polygonMesh.material.transparent = hasTranparentRegion;
        polygonMesh.material.depthMask = !hasTranparentRegion;
        polygonMesh.geometry.updateBoundingBox();
        polygonMesh.frontFace = this.extrudeY ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.CCW : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.CW; // Update tangents
        if (polygonMesh.material.get('normalMap')) {
            polygonMesh.geometry.generateTangents();
        }
        polygonMesh.seriesIndex = componentModel.seriesIndex;
        polygonMesh.on('mousemove', this._onmousemove, this);
        polygonMesh.on('mouseout', this._onmouseout, this);
    },
    _updateDebugWireframe: function(componentModel) {
        var debugWireframeModel = componentModel.getModel('debug.wireframe'); // TODO Unshow
        if (debugWireframeModel.get('show')) {
            var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(debugWireframeModel.get('lineStyle.color') || 'rgba(0,0,0,0.5)');
            var width = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(debugWireframeModel.get('lineStyle.width'), 1); // TODO  Will cause highlight wrong
            var mesh = this._polygonMesh;
            mesh.geometry.generateBarycentric();
            mesh.material.define('both', 'WIREFRAME_TRIANGLE');
            mesh.material.set('wireframeLineColor', color);
            mesh.material.set('wireframeLineWidth', width);
        }
    },
    _onmousemove: function(e) {
        var dataIndex = this._dataIndexOfVertex[e.triangle[0]];
        if (dataIndex == null) {
            dataIndex = -1;
        }
        if (dataIndex !== this._lastHoverDataIndex) {
            this.downplay(this._lastHoverDataIndex);
            this.highlight(dataIndex);
            this._labelsBuilder.updateLabels([
                dataIndex
            ]);
        }
        this._lastHoverDataIndex = dataIndex;
        this._polygonMesh.dataIndex = dataIndex;
    },
    _onmouseout: function(e) {
        if (e.target) {
            this.downplay(this._lastHoverDataIndex);
            this._lastHoverDataIndex = -1;
            this._polygonMesh.dataIndex = -1;
        }
        this._labelsBuilder.updateLabels([]);
    },
    _updateGroundPlane: function(componentModel, geo3D, api) {
        var groundModel = componentModel.getModel('groundPlane', componentModel);
        this._groundMesh.invisible = !groundModel.get('show', true);
        if (this._groundMesh.invisible) {
            return;
        }
        var shading = componentModel.get('shading');
        var material = this._groundMaterials[shading];
        if (!material) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Unkown shading ' + shading);
            }
            material = this._groundMaterials.lambert;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setMaterialFromModel(shading, material, groundModel, api);
        if (material.get('normalMap')) {
            this._groundMesh.geometry.generateTangents();
        }
        this._groundMesh.material = material;
        this._groundMesh.material.set('color', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(groundModel.get('color')));
        this._groundMesh.scale.set(geo3D.size[0], geo3D.size[2], 1);
    },
    _triangulation: function(componentModel, start, end) {
        this._triangulationResults = [];
        var minAll = [
            Infinity,
            Infinity,
            Infinity
        ];
        var maxAll = [
            -Infinity,
            -Infinity,
            -Infinity
        ];
        var coordSys = componentModel.coordinateSystem;
        for(var idx = start; idx < end; idx++){
            var polygons = [];
            var polygonCoords = componentModel.getRegionPolygonCoords(idx);
            for(var i = 0; i < polygonCoords.length; i++){
                var exterior = polygonCoords[i].exterior;
                var interiors = polygonCoords[i].interiors;
                var points = [];
                var holes = [];
                if (exterior.length < 3) {
                    continue;
                }
                var offset = 0;
                for(var j = 0; j < exterior.length; j++){
                    var p = exterior[j];
                    points[offset++] = p[0];
                    points[offset++] = p[1];
                }
                for(var j = 0; j < interiors.length; j++){
                    if (interiors[j].length < 3) {
                        continue;
                    }
                    var startIdx = points.length / 2;
                    for(var k = 0; k < interiors[j].length; k++){
                        var p = interiors[j][k];
                        points.push(p[0]);
                        points.push(p[1]);
                    }
                    holes.push(startIdx);
                }
                var triangles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(points, holes);
                var points3 = new Float64Array(points.length / 2 * 3);
                var pos = [];
                var min = [
                    Infinity,
                    Infinity,
                    Infinity
                ];
                var max = [
                    -Infinity,
                    -Infinity,
                    -Infinity
                ];
                var off3 = 0;
                for(var j = 0; j < points.length;){
                    vec3.set(pos, points[j++], 0, points[j++]);
                    if (coordSys && coordSys.transform) {
                        vec3.transformMat4(pos, pos, coordSys.transform);
                    }
                    vec3.min(min, min, pos);
                    vec3.max(max, max, pos);
                    points3[off3++] = pos[0];
                    points3[off3++] = pos[1];
                    points3[off3++] = pos[2];
                }
                vec3.min(minAll, minAll, min);
                vec3.max(maxAll, maxAll, max);
                polygons.push({
                    points: points3,
                    indices: triangles,
                    min: min,
                    max: max
                });
            }
            this._triangulationResults.push(polygons);
        }
        this._geoBoundingBox = [
            minAll,
            maxAll
        ];
    },
    /**
   * Get region vertex and triangle count
   */ _getRegionPolygonInfo: function(idx) {
        var polygons = this._triangulationResults[idx - this._startIndex];
        var sideVertexCount = 0;
        var sideTriangleCount = 0;
        for(var i = 0; i < polygons.length; i++){
            sideVertexCount += polygons[i].points.length / 3;
            sideTriangleCount += polygons[i].indices.length / 3;
        }
        var vertexCount = sideVertexCount * 2 + sideVertexCount * 4;
        var triangleCount = sideTriangleCount * 2 + sideVertexCount * 2;
        return {
            vertexCount: vertexCount,
            triangleCount: triangleCount
        };
    },
    _updatePolygonGeometry: function(componentModel, geometry, dataIndex, regionHeight, vertexOffset, triangleOffset, color) {
        // FIXME
        var projectUVOnGround = componentModel.get('projectUVOnGround');
        var positionAttr = geometry.attributes.position;
        var normalAttr = geometry.attributes.normal;
        var texcoordAttr = geometry.attributes.texcoord0;
        var colorAttr = geometry.attributes.color;
        var polygons = this._triangulationResults[dataIndex - this._startIndex];
        var hasColor = colorAttr.value && color;
        var indices = geometry.indices;
        var extrudeCoordIndex = this.extrudeY ? 1 : 2;
        var sideCoordIndex = this.extrudeY ? 2 : 1;
        var scale = [
            this.rootNode.worldTransform.x.len(),
            this.rootNode.worldTransform.y.len(),
            this.rootNode.worldTransform.z.len()
        ];
        var min = vec3.mul([], this._geoBoundingBox[0], scale);
        var max = vec3.mul([], this._geoBoundingBox[1], scale);
        var maxDimSize = Math.max(max[0] - min[0], max[2] - min[2]);
        function addVertices(polygon, y, insideOffset) {
            var points = polygon.points;
            var pointsLen = points.length;
            var currentPosition = [];
            var uv = [];
            for(var k = 0; k < pointsLen; k += 3){
                currentPosition[0] = points[k];
                currentPosition[extrudeCoordIndex] = y;
                currentPosition[sideCoordIndex] = points[k + 2];
                uv[0] = (points[k] * scale[0] - min[0]) / maxDimSize;
                uv[1] = (points[k + 2] * scale[sideCoordIndex] - min[2]) / maxDimSize;
                positionAttr.set(vertexOffset, currentPosition);
                if (hasColor) {
                    colorAttr.set(vertexOffset, color);
                }
                texcoordAttr.set(vertexOffset++, uv);
            }
        }
        function buildTopBottom(polygon, y, insideOffset) {
            var startVertexOffset = vertexOffset;
            addVertices(polygon, y, insideOffset);
            var len = polygon.indices.length;
            for(var k = 0; k < len; k++){
                indices[triangleOffset * 3 + k] = polygon.indices[k] + startVertexOffset;
            }
            triangleOffset += polygon.indices.length / 3;
        }
        var normalTop = this.extrudeY ? [
            0,
            1,
            0
        ] : [
            0,
            0,
            1
        ];
        var normalBottom = vec3.negate([], normalTop);
        for(var p = 0; p < polygons.length; p++){
            var startVertexOffset = vertexOffset;
            var polygon = polygons[p]; // BOTTOM
            buildTopBottom(polygon, 0, 0); // TOP
            buildTopBottom(polygon, regionHeight, 0);
            var ringVertexCount = polygon.points.length / 3;
            for(var v = 0; v < ringVertexCount; v++){
                normalAttr.set(startVertexOffset + v, normalBottom);
                normalAttr.set(startVertexOffset + v + ringVertexCount, normalTop);
            }
            var quadToTriangle = [
                0,
                3,
                1,
                1,
                3,
                2
            ];
            var quadPos = [
                [],
                [],
                [],
                []
            ];
            var a = [];
            var b = [];
            var normal = [];
            var uv = [];
            var len = 0;
            for(var v = 0; v < ringVertexCount; v++){
                var next = (v + 1) % ringVertexCount;
                var dx = (polygon.points[next * 3] - polygon.points[v * 3]) * scale[0];
                var dy = (polygon.points[next * 3 + 2] - polygon.points[v * 3 + 2]) * scale[sideCoordIndex];
                var sideLen = Math.sqrt(dx * dx + dy * dy); // 0----1
                // 3----2
                for(var k = 0; k < 4; k++){
                    var isCurrent = k === 0 || k === 3;
                    var idx3 = (isCurrent ? v : next) * 3;
                    quadPos[k][0] = polygon.points[idx3];
                    quadPos[k][extrudeCoordIndex] = k > 1 ? regionHeight : 0;
                    quadPos[k][sideCoordIndex] = polygon.points[idx3 + 2];
                    positionAttr.set(vertexOffset + k, quadPos[k]);
                    if (projectUVOnGround) {
                        uv[0] = (polygon.points[idx3] * scale[0] - min[0]) / maxDimSize;
                        uv[1] = (polygon.points[idx3 + 2] * scale[sideCoordIndex] - min[sideCoordIndex]) / maxDimSize;
                    } else {
                        uv[0] = (isCurrent ? len : len + sideLen) / maxDimSize;
                        uv[1] = (quadPos[k][extrudeCoordIndex] * scale[extrudeCoordIndex] - min[extrudeCoordIndex]) / maxDimSize;
                    }
                    texcoordAttr.set(vertexOffset + k, uv);
                }
                vec3.sub(a, quadPos[1], quadPos[0]);
                vec3.sub(b, quadPos[3], quadPos[0]);
                vec3.cross(normal, a, b);
                vec3.normalize(normal, normal);
                for(var k = 0; k < 4; k++){
                    normalAttr.set(vertexOffset + k, normal);
                    if (hasColor) {
                        colorAttr.set(vertexOffset + k, color);
                    }
                }
                for(var k = 0; k < 6; k++){
                    indices[triangleOffset * 3 + k] = quadToTriangle[k] + vertexOffset;
                }
                vertexOffset += 4;
                triangleOffset += 2;
                len += sideLen;
            }
        }
        geometry.dirty();
        return {
            vertexOffset: vertexOffset,
            triangleOffset: triangleOffset
        };
    },
    _getRegionLinesInfo: function(idx, componentModel, geometry) {
        var vertexCount = 0;
        var triangleCount = 0;
        var regionModel = componentModel.getRegionModel(idx);
        var itemStyleModel = regionModel.getModel('itemStyle');
        var lineWidth = itemStyleModel.get('borderWidth');
        if (lineWidth > 0) {
            var polygonCoords = componentModel.getRegionPolygonCoords(idx);
            polygonCoords.forEach(function(coords) {
                var exterior = coords.exterior;
                var interiors = coords.interiors;
                vertexCount += geometry.getPolylineVertexCount(exterior);
                triangleCount += geometry.getPolylineTriangleCount(exterior);
                for(var i = 0; i < interiors.length; i++){
                    vertexCount += geometry.getPolylineVertexCount(interiors[i]);
                    triangleCount += geometry.getPolylineTriangleCount(interiors[i]);
                }
            }, this);
        }
        return {
            vertexCount: vertexCount,
            triangleCount: triangleCount
        };
    },
    _updateLinesGeometry: function(geometry, componentModel, dataIndex, regionHeight, lineWidth, transform) {
        function convertToPoints3(polygon) {
            var points = new Float64Array(polygon.length * 3);
            var offset = 0;
            var pos = [];
            for(var i = 0; i < polygon.length; i++){
                pos[0] = polygon[i][0]; // Add a offset to avoid z-fighting
                pos[1] = regionHeight + 0.1;
                pos[2] = polygon[i][1];
                if (transform) {
                    vec3.transformMat4(pos, pos, transform);
                }
                points[offset++] = pos[0];
                points[offset++] = pos[1];
                points[offset++] = pos[2];
            }
            return points;
        }
        var whiteColor = [
            1,
            1,
            1,
            1
        ];
        var coords = componentModel.getRegionPolygonCoords(dataIndex);
        coords.forEach(function(geo) {
            var exterior = geo.exterior;
            var interiors = geo.interiors;
            geometry.addPolyline(convertToPoints3(exterior), whiteColor, lineWidth);
            for(var i = 0; i < interiors.length; i++){
                geometry.addPolyline(convertToPoints3(interiors[i]), whiteColor, lineWidth);
            }
        });
    },
    highlight: function(dataIndex) {
        var data = this._data;
        if (!data) {
            return;
        }
        var itemModel = data.getItemModel(dataIndex);
        var emphasisItemStyleModel = itemModel.getModel([
            'emphasis',
            'itemStyle'
        ]);
        var emphasisColor = emphasisItemStyleModel.get('color');
        var emphasisOpacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(emphasisItemStyleModel.get('opacity'), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex), 1);
        if (emphasisColor == null) {
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
            emphasisColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__["color"].lift(color, -0.4);
        }
        if (emphasisOpacity == null) {
            emphasisOpacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex);
        }
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(emphasisColor);
        colorArr[3] *= emphasisOpacity;
        this._setColorOfDataIndex(data, dataIndex, colorArr);
    },
    downplay: function(dataIndex) {
        var data = this._data;
        if (!data) {
            return;
        }
        var itemStyleModel = data.getItemModel(dataIndex);
        var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex), itemStyleModel.get([
            'itemStyle',
            'color'
        ]), '#fff');
        var opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex), itemStyleModel.get([
            'itemStyle',
            'opacity'
        ]), 1);
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
        colorArr[3] *= opacity;
        this._setColorOfDataIndex(data, dataIndex, colorArr);
    },
    dispose: function() {
        this._labelsBuilder.dispose();
    },
    _setColorOfDataIndex: function(data, dataIndex, colorArr) {
        if (dataIndex < this._startIndex && dataIndex > this._endIndex) {
            return;
        }
        dataIndex -= this._startIndex;
        for(var i = this._vertexRangeOfDataIndex[dataIndex * 2]; i < this._vertexRangeOfDataIndex[dataIndex * 2 + 1]; i++){
            this._polygonMesh.geometry.attributes.color.set(i, colorArr);
        }
        this._polygonMesh.geometry.dirty();
        this._api.getZr().refresh();
    }
};
const __TURBOPACK__default__export__ = Geo3DBuilder;
}}),
"[project]/node_modules/echarts-gl/lib/component/geo3D/Geo3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/Geo3DBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Component.js [app-client] (ecmascript) <export default as ComponentView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/OrbitControl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__["ComponentView"].extend({
    type: 'geo3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this._geo3DBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](api);
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._lightRoot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this._lightRoot);
        this._sceneHelper.initLight(this._lightRoot);
        this._control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            zr: api.getZr()
        });
        this._control.init();
    },
    render: function(geo3DModel, ecModel, api) {
        this.groupGL.add(this._geo3DBuilder.rootNode);
        var geo3D = geo3DModel.coordinateSystem;
        if (!geo3D || !geo3D.viewGL) {
            return;
        } // Always have light.
        geo3D.viewGL.add(this._lightRoot);
        if (geo3DModel.get('show')) {
            geo3D.viewGL.add(this.groupGL);
        } else {
            geo3D.viewGL.remove(this.groupGL);
        }
        var control = this._control;
        control.setViewGL(geo3D.viewGL);
        var viewControlModel = geo3DModel.getModel('viewControl');
        control.setFromViewControlModel(viewControlModel, 0);
        this._sceneHelper.setScene(geo3D.viewGL.scene);
        this._sceneHelper.updateLight(geo3DModel); // Set post effect
        geo3D.viewGL.setPostEffect(geo3DModel.getModel('postEffect'), api);
        geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel('temporalSuperSampling')); // Must update after geo3D.viewGL.setPostEffect
        this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());
        var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? 'define' : 'undefine';
        this._geo3DBuilder.rootNode.traverse(function(mesh) {
            if (mesh.material) {
                mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');
            }
        });
        control.off('update');
        control.on('update', function() {
            api.dispatchAction({
                type: 'geo3DChangeCamera',
                alpha: control.getAlpha(),
                beta: control.getBeta(),
                distance: control.getDistance(),
                center: control.getCenter(),
                from: this.uid,
                geo3DId: geo3DModel.id
            });
        });
        control.update();
    },
    afterRender: function(geo3DModel, ecModel, api, layerGL) {
        var renderer = layerGL.renderer;
        this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);
        this._sceneHelper.updateSkybox(renderer, geo3DModel, api);
    },
    dispose: function() {
        this._control.dispose();
        this._geo3DBuilder.dispose();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/coord/geo3D/Geo3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$parseGeoJson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__parseGeoJSON$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/geo/parseGeoJson.js [app-client] (ecmascript) <export default as parseGeoJSON>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$parseGeoJson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__parseGeoJson$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/geo/parseGeoJson.js [app-client] (ecmascript) <export default as parseGeoJson>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/graphic.js [app-client] (ecmascript) <export * as graphic>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$fix$2f$textCoord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/geo/fix/textCoord.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$fix$2f$geoCoord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/geo/fix/geoCoord.js [app-client] (ecmascript)"); // Geo fix functions
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var mat4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mat4;
;
;
var geoFixFuncs = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$fix$2f$textCoord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$fix$2f$geoCoord$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
];
function Geo3D(name, map, geoJson, specialAreas, nameMap) {
    this.name = name;
    this.map = map;
    this.regionHeight = 0;
    this.regions = [];
    this._nameCoordMap = {};
    this.loadGeoJson(geoJson, specialAreas, nameMap);
    this.transform = mat4.identity(new Float64Array(16));
    this.invTransform = mat4.identity(new Float64Array(16)); // Which dimension to extrude. Y or Z
    this.extrudeY = true;
    this.altitudeAxis;
}
Geo3D.prototype = {
    constructor: Geo3D,
    type: 'geo3D',
    dimensions: [
        'lng',
        'lat',
        'alt'
    ],
    containPoint: function() {},
    loadGeoJson: function(geoJson, specialAreas, nameMap) {
        var parseGeoJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$parseGeoJson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__parseGeoJSON$3e$__["parseGeoJSON"] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$geo$2f$parseGeoJson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__parseGeoJson$3e$__["parseGeoJson"];
        try {
            this.regions = geoJson ? parseGeoJSON(geoJson) : [];
        } catch (e) {
            throw 'Invalid geoJson format\n' + e;
        }
        specialAreas = specialAreas || {};
        nameMap = nameMap || {};
        var regions = this.regions;
        var regionsMap = {};
        for(var i = 0; i < regions.length; i++){
            var regionName = regions[i].name; // Try use the alias in nameMap
            regionName = nameMap[regionName] || regionName;
            regions[i].name = regionName;
            regionsMap[regionName] = regions[i]; // Add geoJson
            this.addGeoCoord(regionName, regions[i].getCenter()); // Some area like Alaska in USA map needs to be tansformed
            // to look better
            var specialArea = specialAreas[regionName];
            if (specialArea) {
                regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
            }
        }
        this._regionsMap = regionsMap;
        this._geoRect = null;
        geoFixFuncs.forEach(function(fixFunc) {
            fixFunc(this);
        }, this);
    },
    getGeoBoundingRect: function() {
        if (this._geoRect) {
            return this._geoRect;
        }
        var rect;
        var regions = this.regions;
        for(var i = 0; i < regions.length; i++){
            var regionRect = regions[i].getBoundingRect();
            rect = rect || regionRect.clone();
            rect.union(regionRect);
        } // FIXME Always return new ?
        return this._geoRect = rect || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__graphic$3e$__["graphic"].BoundingRect(0, 0, 0, 0);
    },
    /**
   * Add geoCoord for indexing by name
   * @param {string} name
   * @param {Array.<number>} geoCoord
   */ addGeoCoord: function(name, geoCoord) {
        this._nameCoordMap[name] = geoCoord;
    },
    /**
   * @param {string} name
   * @return {module:echarts/coord/geo/Region}
   */ getRegion: function(name) {
        return this._regionsMap[name];
    },
    getRegionByCoord: function(coord) {
        var regions = this.regions;
        for(var i = 0; i < regions.length; i++){
            if (regions[i].contain(coord)) {
                return regions[i];
            }
        }
    },
    setSize: function(width, height, depth) {
        this.size = [
            width,
            height,
            depth
        ];
        var rect = this.getGeoBoundingRect();
        var scaleX = width / rect.width;
        var scaleZ = -depth / rect.height;
        var translateX = -width / 2 - rect.x * scaleX;
        var translateZ = depth / 2 - rect.y * scaleZ;
        var position = this.extrudeY ? [
            translateX,
            0,
            translateZ
        ] : [
            translateX,
            translateZ,
            0
        ];
        var scale = this.extrudeY ? [
            scaleX,
            1,
            scaleZ
        ] : [
            scaleX,
            scaleZ,
            1
        ];
        var m = this.transform;
        mat4.identity(m);
        mat4.translate(m, m, position);
        mat4.scale(m, m, scale);
        mat4.invert(this.invTransform, m);
    },
    dataToPoint: function(data, out) {
        out = out || [];
        var extrudeCoordIndex = this.extrudeY ? 1 : 2;
        var sideCoordIndex = this.extrudeY ? 2 : 1;
        var altitudeVal = data[2]; // PENDING.
        if (isNaN(altitudeVal)) {
            altitudeVal = 0;
        } // lng
        out[0] = data[0]; // lat
        out[sideCoordIndex] = data[1];
        if (this.altitudeAxis) {
            out[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);
        } else {
            out[extrudeCoordIndex] = 0;
        } // PENDING different region height.
        out[extrudeCoordIndex] += this.regionHeight;
        vec3.transformMat4(out, out, this.transform);
        return out;
    },
    pointToData: function(point, out) {}
};
const __TURBOPACK__default__export__ = Geo3D;
}}),
"[project]/node_modules/echarts-gl/lib/coord/geo3DCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$Geo3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/geo3D/Geo3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/core/echarts.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/Axis.js [app-client] (ecmascript) <export default as Axis>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/util/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
;
;
;
;
;
function resizeGeo3D(geo3DModel, api) {
    // Use left/top/width/height
    var boxLayoutOption = geo3DModel.getBoxLayoutParams();
    var viewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutRect"])(boxLayoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
    }); // Flip Y
    viewport.y = api.getHeight() - viewport.y - viewport.height;
    this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
    var geoRect = this.getGeoBoundingRect();
    var aspect = geoRect.width / geoRect.height * (geo3DModel.get('aspectScale') || 0.75);
    var width = geo3DModel.get('boxWidth');
    var depth = geo3DModel.get('boxDepth');
    var height = geo3DModel.get('boxHeight');
    if (height == null) {
        height = 5;
    }
    if (isNaN(width) && isNaN(depth)) {
        // Default to have 100 width
        width = 100;
    }
    if (isNaN(depth)) {
        depth = width / aspect;
    } else if (isNaN(width)) {
        width = depth / aspect;
    }
    this.setSize(width, height, depth);
    this.regionHeight = geo3DModel.get('regionHeight');
    if (this.altitudeAxis) {
        this.altitudeAxis.setExtent(0, Math.max(height - this.regionHeight, 0));
    }
}
function updateGeo3D(ecModel, api) {
    var altitudeDataExtent = [
        Infinity,
        -Infinity
    ];
    ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem !== this) {
            return;
        }
        if (seriesModel.type === 'series.map3D') {
            return;
        } // Get altitude data extent.
        var data = seriesModel.getData();
        var altDims = seriesModel.coordDimToDataDim('alt');
        var altDim = altDims && altDims[0];
        if (altDim) {
            // TODO altitiude is in coords of lines.
            var dataExtent = data.getDataExtent(altDim, true);
            altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
            altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
        }
    }, this); // Create altitude axis
    if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
        var scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createScale(altitudeDataExtent, {
            type: 'value',
            // PENDING
            min: 'dataMin',
            max: 'dataMax'
        });
        this.altitudeAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__["Axis"]('altitude', scale); // Resize again
        this.resize(this.model, api);
    }
}
if ("TURBOPACK compile-time truthy", 1) {
    var mapNotExistsError = function(name) {
        console.error('Map ' + name + ' not exists. You can download map file on http://echarts.baidu.com/download-map.html');
    };
}
var idStart = 0;
var geo3DCreator = {
    dimensions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$Geo3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.dimensions,
    create: function(ecModel, api) {
        var geo3DList = [];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getMap"]) {
            throw new Error('geo3D component depends on geo component');
        }
        function createGeo3D(componentModel, idx) {
            var geo3D = geo3DCreator.createGeo3D(componentModel); // FIXME
            componentModel.__viewGL = componentModel.__viewGL || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            geo3D.viewGL = componentModel.__viewGL;
            componentModel.coordinateSystem = geo3D;
            geo3D.model = componentModel;
            geo3DList.push(geo3D); // Inject resize
            geo3D.resize = resizeGeo3D;
            geo3D.resize(componentModel, api);
            geo3D.update = updateGeo3D;
        }
        ecModel.eachComponent('geo3D', function(geo3DModel, idx) {
            createGeo3D(geo3DModel, idx);
        });
        ecModel.eachSeriesByType('map3D', function(map3DModel, idx) {
            var coordSys = map3DModel.get('coordinateSystem');
            if (coordSys == null) {
                coordSys = 'geo3D';
            }
            if (coordSys === 'geo3D') {
                createGeo3D(map3DModel, idx);
            }
        });
        ecModel.eachSeries(function(seriesModel) {
            if (seriesModel.get('coordinateSystem') === 'geo3D') {
                if (seriesModel.type === 'series.map3D') {
                    return;
                }
                var geo3DModel = seriesModel.getReferringComponents('geo3D').models[0];
                if (!geo3DModel) {
                    geo3DModel = ecModel.getComponent('geo3D');
                }
                if (!geo3DModel) {
                    throw new Error('geo "' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('geo3DIndex'), seriesModel.get('geo3DId'), 0) + '" not found');
                }
                seriesModel.coordinateSystem = geo3DModel.coordinateSystem;
            }
        });
        return geo3DList;
    },
    createGeo3D: function(componentModel) {
        var mapData = componentModel.get('map');
        var name;
        if (typeof mapData === 'string') {
            name = mapData;
            mapData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getMap"])(mapData);
        } else {
            if (mapData && mapData.features) {
                mapData = {
                    geoJson: mapData
                };
            }
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!mapData) {
                mapNotExistsError(mapData);
            }
            if (!mapData.geoJson.features) {
                throw new Error('Invalid GeoJSON for map3D');
            }
        }
        if (name == null) {
            name = 'GEO_ANONYMOUS_' + idStart++;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$Geo3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](name + idStart++, name, mapData && mapData.geoJson, mapData && mapData.specialAreas, componentModel.get('nameMap'));
    }
};
const __TURBOPACK__default__export__ = geo3DCreator;
}}),
"[project]/node_modules/echarts-gl/lib/component/geo3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$Geo3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/geo3D/Geo3DModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$Geo3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/geo3D/Geo3DView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/geo3DCreator.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerComponentModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$Geo3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerComponentView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$Geo3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'geo3DChangeCamera',
        event: 'geo3dcamerachanged',
        update: 'series:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'geo3D',
            query: payload
        }, function(componentModel) {
            componentModel.setView(payload);
        });
    });
    registers.registerCoordinateSystem('geo3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
}
}}),
"[project]/node_modules/echarts-gl/lib/component/geo3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/geo3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/component/globe/GlobeModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentViewControlMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
;
;
;
;
;
function defaultId(option, idx) {
    option.id = option.id || option.name || idx + '';
}
var GlobeModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'globe',
    layoutMode: 'box',
    coordinateSystem: null,
    init: function() {
        GlobeModel.superApply(this, 'init', arguments);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(this.option.layers, function(layerOption, idx) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(layerOption, this.defaultLayerOption);
            defaultId(layerOption, idx);
        }, this);
    },
    mergeOption: function(option) {
        // TODO test
        var oldLayers = this.option.layers;
        this.option.layers = null;
        GlobeModel.superApply(this, 'mergeOption', arguments);
        function createLayerMap(layers) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].reduce(layers, function(obj, layerOption, idx) {
                defaultId(layerOption, idx);
                obj[layerOption.id] = layerOption;
                return obj;
            }, {});
        }
        if (oldLayers && oldLayers.length) {
            var newLayerMap = createLayerMap(option.layers);
            var oldLayerMap = createLayerMap(oldLayers);
            for(var id in newLayerMap){
                if (oldLayerMap[id]) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(oldLayerMap[id], newLayerMap[id], true);
                } else {
                    oldLayers.push(option.layers[id]);
                }
            } // Copy back
            this.option.layers = oldLayers;
        } // else overwrite
        // Set default
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(this.option.layers, function(layerOption) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(layerOption, this.defaultLayerOption);
        }, this);
    },
    optionUpdated: function() {
        this.updateDisplacementHash();
    },
    defaultLayerOption: {
        show: true,
        type: 'overlay'
    },
    defaultOption: {
        show: true,
        zlevel: -10,
        // Layout used for viewport
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        environment: 'auto',
        baseColor: '#fff',
        // Base albedo texture
        baseTexture: '',
        // Height texture for bump mapping and vertex displacement
        heightTexture: '',
        // Texture for vertex displacement, default use heightTexture
        displacementTexture: '',
        // Scale of vertex displacement, available only if displacementTexture is set.
        displacementScale: 0,
        // Detail of displacement. 'low', 'medium', 'high', 'ultra'
        displacementQuality: 'medium',
        // Globe radius
        globeRadius: 100,
        // Globe outer radius. Which is max of altitude.
        globeOuterRadius: 150,
        // Shading of globe
        shading: 'lambert',
        // Extend light
        light: {
            // Main sun light
            main: {
                // Time, default it will use system time
                time: ''
            }
        },
        // atmosphere
        atmosphere: {
            show: false,
            offset: 5,
            color: '#ffffff',
            glowPower: 6.0,
            innerGlowPower: 2.0
        },
        // light
        // postEffect
        // temporalSuperSampling
        viewControl: {
            autoRotate: true,
            panSensitivity: 0,
            targetCoord: null
        },
        // {
        //     show: true,
        //     name: 'cloud',
        //     type: 'overlay',
        //     shading: 'lambert',
        //     distance: 10,
        //     texture: ''
        // }
        // {
        //     type: 'blend',
        //     blendTo: 'albedo'
        //     blendType: 'source-over'
        // }
        layers: []
    },
    setDisplacementData: function(data, width, height) {
        this.displacementData = data;
        this.displacementWidth = width;
        this.displacementHeight = height;
    },
    getDisplacementTexture: function() {
        return this.get('displacementTexture') || this.get('heightTexture');
    },
    getDisplacemenScale: function() {
        var displacementTexture = this.getDisplacementTexture();
        var displacementScale = this.get('displacementScale');
        if (!displacementTexture || displacementTexture === 'none') {
            displacementScale = 0;
        }
        return displacementScale;
    },
    hasDisplacement: function() {
        return this.getDisplacemenScale() > 0;
    },
    _displacementChanged: true,
    _displacementScale: 0,
    updateDisplacementHash: function() {
        var displacementTexture = this.getDisplacementTexture();
        var displacementScale = this.getDisplacemenScale();
        this._displacementChanged = this._displacementTexture !== displacementTexture || this._displacementScale !== displacementScale;
        this._displacementTexture = displacementTexture;
        this._displacementScale = displacementScale;
    },
    isDisplacementChanged: function() {
        return this._displacementChanged;
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(GlobeModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(GlobeModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(GlobeModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(GlobeModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = GlobeModel;
}}),
"[project]/node_modules/echarts-gl/lib/util/sunCalc.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 (c) 2011-2014, Vladimir Agafonkin
 SunCalc is a JavaScript library for calculating sun/mooon position and light phases.
 https://github.com/mourner/suncalc
*/ // shortcuts for easier to read formulas
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var PI = Math.PI, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan = Math.atan2, rad = PI / 180; // sun calculations are based on http://aa.quae.nl/en/reken/zonpositie.html formulas
// date/time constants and conversions
var dayMs = 1000 * 60 * 60 * 24, J1970 = 2440588, J2000 = 2451545;
function toJulian(date) {
    return date.valueOf() / dayMs - 0.5 + J1970;
}
function toDays(date) {
    return toJulian(date) - J2000;
} // general calculations for position
var e = rad * 23.4397; // obliquity of the Earth
function rightAscension(l, b) {
    return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
}
function declination(l, b) {
    return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
}
function azimuth(H, phi, dec) {
    return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
}
function altitude(H, phi, dec) {
    return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
}
function siderealTime(d, lw) {
    return rad * (280.16 + 360.9856235 * d) - lw;
} // general sun calculations
function solarMeanAnomaly(d) {
    return rad * (357.5291 + 0.98560028 * d);
}
function eclipticLongitude(M) {
    var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M)), // equation of center
    P = rad * 102.9372; // perihelion of the Earth
    return M + C + P + PI;
}
function sunCoords(d) {
    var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
    return {
        dec: declination(L, 0),
        ra: rightAscension(L, 0)
    };
}
var SunCalc = {}; // calculates sun position for a given date and latitude/longitude
SunCalc.getPosition = function(date, lat, lng) {
    var lw = rad * -lng, phi = rad * lat, d = toDays(date), c = sunCoords(d), H = siderealTime(d, lw) - c.ra;
    return {
        azimuth: azimuth(H, phi, c.dec),
        altitude: altitude(H, phi, c.dec)
    };
};
const __TURBOPACK__default__export__ = SunCalc;
}}),
"[project]/node_modules/echarts-gl/lib/component/globe/atmosphere.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.atmosphere.vertex\nattribute vec3 position: POSITION;\nattribute vec3 normal : NORMAL;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 normalMatrix : WORLDINVERSETRANSPOSE;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n v_Normal = normalize((normalMatrix * vec4(normal, 0.0)).xyz);\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n@end\n\n\n@export ecgl.atmosphere.fragment\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform float glowPower;\nuniform vec3 glowColor;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n float intensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor = vec4(glowColor, intensity * intensity);\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/component/globe/GlobeView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Component.js [app-client] (ecmascript) <export default as ComponentView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Model.js [app-client] (ecmascript) <export default as Model>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/number.js [app-client] (ecmascript) <export * as number>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/OrbitControl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$sunCalc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/sunCalc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$util$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/shader/source/util.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$atmosphere$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/globe/atmosphere.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$shader$2f$source$2f$util$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$atmosphere$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__["ComponentView"].extend({
    type: 'globe',
    __ecgl__: true,
    _displacementScale: 0,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        /**
     * @type {clay.geometry.Sphere}
     * @private
     */ this._sphereGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SphereGeometry({
            widthSegments: 200,
            heightSegments: 100,
            dynamic: true
        });
        this._overlayGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SphereGeometry({
            widthSegments: 80,
            heightSegments: 40
        });
        /**
     * @type {clay.geometry.Plane}
     */ this._planeGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PlaneGeometry();
        /**
     * @type {clay.geometry.Mesh}
     */ this._earthMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            renderNormal: true
        });
        /**
     * @type {clay.geometry.Mesh}
     */ this._atmosphereMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh();
        this._atmosphereGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SphereGeometry({
            widthSegments: 80,
            heightSegments: 40
        });
        this._atmosphereMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.atmosphere.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.atmosphere.fragment')),
            transparent: true
        });
        this._atmosphereMesh.geometry = this._atmosphereGeometry;
        this._atmosphereMesh.material = this._atmosphereMaterial;
        this._atmosphereMesh.frontFace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.CW;
        this._lightRoot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._sceneHelper.initLight(this._lightRoot);
        this.groupGL.add(this._atmosphereMesh);
        this.groupGL.add(this._earthMesh);
        this._control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            zr: api.getZr()
        });
        this._control.init();
        this._layerMeshes = {};
    },
    render: function(globeModel, ecModel, api) {
        var coordSys = globeModel.coordinateSystem;
        var shading = globeModel.get('shading'); // Always have light.
        coordSys.viewGL.add(this._lightRoot);
        if (globeModel.get('show')) {
            // Add self to scene;
            coordSys.viewGL.add(this.groupGL);
        } else {
            coordSys.viewGL.remove(this.groupGL);
        }
        this._sceneHelper.setScene(coordSys.viewGL.scene); // Set post effect
        coordSys.viewGL.setPostEffect(globeModel.getModel('postEffect'), api);
        coordSys.viewGL.setTemporalSuperSampling(globeModel.getModel('temporalSuperSampling'));
        var earthMesh = this._earthMesh;
        earthMesh.geometry = this._sphereGeometry;
        var shadingPrefix = 'ecgl.' + shading;
        if (!earthMesh.material || earthMesh.material.shader.name !== shadingPrefix) {
            earthMesh.material = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createMaterial(shadingPrefix);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setMaterialFromModel(shading, earthMesh.material, globeModel, api);
        [
            'roughnessMap',
            'metalnessMap',
            'detailMap',
            'normalMap'
        ].forEach(function(texName) {
            var texture = earthMesh.material.get(texName);
            if (texture) {
                texture.flipY = false;
            }
        });
        earthMesh.material.set('color', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(globeModel.get('baseColor'))); // shrink a little
        var scale = coordSys.radius * 0.99;
        earthMesh.scale.set(scale, scale, scale);
        if (globeModel.get('atmosphere.show')) {
            earthMesh.material.define('both', 'ATMOSPHERE_ENABLED');
            this._atmosphereMesh.invisible = false;
            this._atmosphereMaterial.setUniforms({
                glowPower: globeModel.get('atmosphere.glowPower') || 6.0,
                glowColor: globeModel.get('atmosphere.color') || '#ffffff'
            });
            earthMesh.material.setUniforms({
                glowPower: globeModel.get('atmosphere.innerGlowPower') || 2.0,
                glowColor: globeModel.get('atmosphere.color') || '#ffffff'
            });
            var offset = globeModel.get('atmosphere.offset') || 5;
            this._atmosphereMesh.scale.set(scale + offset, scale + offset, scale + offset);
        } else {
            earthMesh.material.undefine('both', 'ATMOSPHERE_ENABLED');
            this._atmosphereMesh.invisible = true;
        }
        var diffuseTexture = earthMesh.material.setTextureImage('diffuseMap', globeModel.get('baseTexture'), api, {
            flipY: false,
            anisotropic: 8
        });
        if (diffuseTexture && diffuseTexture.surface) {
            diffuseTexture.surface.attachToMesh(earthMesh);
        } // Update bump map
        var bumpTexture = earthMesh.material.setTextureImage('bumpMap', globeModel.get('heightTexture'), api, {
            flipY: false,
            anisotropic: 8
        });
        if (bumpTexture && bumpTexture.surface) {
            bumpTexture.surface.attachToMesh(earthMesh);
        }
        earthMesh.material[globeModel.get('postEffect.enable') ? 'define' : 'undefine']('fragment', 'SRGB_DECODE');
        this._updateLight(globeModel, api);
        this._displaceVertices(globeModel, api);
        this._updateViewControl(globeModel, api);
        this._updateLayers(globeModel, api);
    },
    afterRender: function(globeModel, ecModel, api, layerGL) {
        // Create ambient cubemap after render because we need to know the renderer.
        // TODO
        var renderer = layerGL.renderer;
        this._sceneHelper.updateAmbientCubemap(renderer, globeModel, api);
        this._sceneHelper.updateSkybox(renderer, globeModel, api);
    },
    _updateLayers: function(globeModel, api) {
        var coordSys = globeModel.coordinateSystem;
        var layers = globeModel.get('layers');
        var lastDistance = coordSys.radius;
        var layerDiffuseTextures = [];
        var layerDiffuseIntensity = [];
        var layerEmissiveTextures = [];
        var layerEmissionIntensity = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(layers, function(layerOption) {
            var layerModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__["Model"](layerOption);
            var layerType = layerModel.get('type');
            var texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadTexture(layerModel.get('texture'), api, {
                flipY: false,
                anisotropic: 8
            });
            if (texture.surface) {
                texture.surface.attachToMesh(this._earthMesh);
            }
            if (layerType === 'blend') {
                var blendTo = layerModel.get('blendTo');
                var intensity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(layerModel.get('intensity'), 1.0);
                if (blendTo === 'emission') {
                    layerEmissiveTextures.push(texture);
                    layerEmissionIntensity.push(intensity);
                } else {
                    // Default is albedo
                    layerDiffuseTextures.push(texture);
                    layerDiffuseIntensity.push(intensity);
                }
            } else {
                // Default use overlay
                var id = layerModel.get('id');
                var overlayMesh = this._layerMeshes[id];
                if (!overlayMesh) {
                    overlayMesh = this._layerMeshes[id] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
                        geometry: this._overlayGeometry,
                        castShadow: false,
                        ignorePicking: true
                    });
                }
                var shading = layerModel.get('shading');
                if (shading === 'lambert') {
                    overlayMesh.material = overlayMesh.__lambertMaterial || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                        autoUpdateTextureStatus: false,
                        shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.lambert'),
                        transparent: true,
                        depthMask: false
                    });
                    overlayMesh.__lambertMaterial = overlayMesh.material;
                } else {
                    // color
                    overlayMesh.material = overlayMesh.__colorMaterial || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                        autoUpdateTextureStatus: false,
                        shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.color'),
                        transparent: true,
                        depthMask: false
                    });
                    overlayMesh.__colorMaterial = overlayMesh.material;
                } // overlay should be transparent if texture is not loaded yet.
                overlayMesh.material.enableTexture('diffuseMap');
                var distance = layerModel.get('distance'); // Based on distance of last layer
                var radius = lastDistance + (distance == null ? coordSys.radius / 100 : distance);
                overlayMesh.scale.set(radius, radius, radius);
                lastDistance = radius; // FIXME Exists blink.
                var blankTexture = this._blankTexture || (this._blankTexture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createBlankTexture('rgba(255, 255, 255, 0)'));
                overlayMesh.material.set('diffuseMap', blankTexture);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadTexture(layerModel.get('texture'), api, {
                    flipY: false,
                    anisotropic: 8
                }, function(texture) {
                    if (texture.surface) {
                        texture.surface.attachToMesh(overlayMesh);
                    }
                    overlayMesh.material.set('diffuseMap', texture);
                    api.getZr().refresh();
                });
                layerModel.get('show') ? this.groupGL.add(overlayMesh) : this.groupGL.remove(overlayMesh);
            }
        }, this);
        var earthMaterial = this._earthMesh.material;
        earthMaterial.define('fragment', 'LAYER_DIFFUSEMAP_COUNT', layerDiffuseTextures.length);
        earthMaterial.define('fragment', 'LAYER_EMISSIVEMAP_COUNT', layerEmissiveTextures.length);
        earthMaterial.set('layerDiffuseMap', layerDiffuseTextures);
        earthMaterial.set('layerDiffuseIntensity', layerDiffuseIntensity);
        earthMaterial.set('layerEmissiveMap', layerEmissiveTextures);
        earthMaterial.set('layerEmissionIntensity', layerEmissionIntensity);
        var debugWireframeModel = globeModel.getModel('debug.wireframe');
        if (debugWireframeModel.get('show')) {
            earthMaterial.define('both', 'WIREFRAME_TRIANGLE');
            var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(debugWireframeModel.get('lineStyle.color') || 'rgba(0,0,0,0.5)');
            var width = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(debugWireframeModel.get('lineStyle.width'), 1);
            earthMaterial.set('wireframeLineWidth', width);
            earthMaterial.set('wireframeLineColor', color);
        } else {
            earthMaterial.undefine('both', 'WIREFRAME_TRIANGLE');
        }
    },
    _updateViewControl: function(globeModel, api) {
        var coordSys = globeModel.coordinateSystem; // Update camera
        var viewControlModel = globeModel.getModel('viewControl');
        var camera = coordSys.viewGL.camera;
        var self = this;
        function makeAction() {
            return {
                type: 'globeChangeCamera',
                alpha: control.getAlpha(),
                beta: control.getBeta(),
                distance: control.getDistance() - coordSys.radius,
                center: control.getCenter(),
                from: self.uid,
                globeId: globeModel.id
            };
        } // Update control
        var control = this._control;
        control.setViewGL(coordSys.viewGL);
        var coord = viewControlModel.get('targetCoord');
        var alpha, beta;
        if (coord != null) {
            beta = coord[0] + 90;
            alpha = coord[1];
        }
        control.setFromViewControlModel(viewControlModel, {
            baseDistance: coordSys.radius,
            alpha: alpha,
            beta: beta
        });
        control.off('update');
        control.on('update', function() {
            api.dispatchAction(makeAction());
        });
    },
    _displaceVertices: function(globeModel, api) {
        var displacementQuality = globeModel.get('displacementQuality');
        var showDebugWireframe = globeModel.get('debug.wireframe.show');
        var globe = globeModel.coordinateSystem;
        if (!globeModel.isDisplacementChanged() && displacementQuality === this._displacementQuality && showDebugWireframe === this._showDebugWireframe) {
            return;
        }
        this._displacementQuality = displacementQuality;
        this._showDebugWireframe = showDebugWireframe;
        var geometry = this._sphereGeometry;
        var widthSegments = {
            low: 100,
            medium: 200,
            high: 400,
            ultra: 800
        }[displacementQuality] || 200;
        var heightSegments = widthSegments / 2;
        if (geometry.widthSegments !== widthSegments || showDebugWireframe) {
            geometry.widthSegments = widthSegments;
            geometry.heightSegments = heightSegments;
            geometry.build();
        }
        this._doDisplaceVertices(geometry, globe);
        if (showDebugWireframe) {
            geometry.generateBarycentric();
        }
    },
    _doDisplaceVertices: function(geometry, globe) {
        var positionArr = geometry.attributes.position.value;
        var uvArr = geometry.attributes.texcoord0.value;
        var originalPositionArr = geometry.__originalPosition;
        if (!originalPositionArr || originalPositionArr.length !== positionArr.length) {
            originalPositionArr = new Float32Array(positionArr.length);
            originalPositionArr.set(positionArr);
            geometry.__originalPosition = originalPositionArr;
        }
        var width = globe.displacementWidth;
        var height = globe.displacementHeight;
        var data = globe.displacementData;
        for(var i = 0; i < geometry.vertexCount; i++){
            var i3 = i * 3;
            var i2 = i * 2;
            var x = originalPositionArr[i3 + 1];
            var y = originalPositionArr[i3 + 2];
            var z = originalPositionArr[i3 + 3];
            var u = uvArr[i2++];
            var v = uvArr[i2++];
            var j = Math.round(u * (width - 1));
            var k = Math.round(v * (height - 1));
            var idx = k * width + j;
            var scale = data ? data[idx] : 0;
            positionArr[i3 + 1] = x + x * scale;
            positionArr[i3 + 2] = y + y * scale;
            positionArr[i3 + 3] = z + z * scale;
        }
        geometry.generateVertexNormals();
        geometry.dirty();
        geometry.updateBoundingBox();
    },
    _updateLight: function(globeModel, api) {
        var earthMesh = this._earthMesh;
        this._sceneHelper.updateLight(globeModel);
        var mainLight = this._sceneHelper.mainLight; // Put sun in the right position
        var time = globeModel.get('light.main.time') || new Date(); // http://en.wikipedia.org/wiki/Azimuth
        var pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$sunCalc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getPosition(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].parseDate(time), 0, 0);
        var r0 = Math.cos(pos.altitude); // FIXME How to calculate the y ?
        mainLight.position.y = -r0 * Math.cos(pos.azimuth);
        mainLight.position.x = Math.sin(pos.altitude);
        mainLight.position.z = r0 * Math.sin(pos.azimuth);
        mainLight.lookAt(earthMesh.getWorldPosition());
    },
    dispose: function(ecModel, api) {
        this.groupGL.removeAll();
        this._control.dispose();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/coord/globe/Globe.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
function Globe(radius) {
    this.radius = radius;
    this.viewGL = null;
    this.altitudeAxis; // Displacement data provided by texture.
    this.displacementData = null;
    this.displacementWidth;
    this.displacementHeight;
}
Globe.prototype = {
    constructor: Globe,
    dimensions: [
        'lng',
        'lat',
        'alt'
    ],
    type: 'globe',
    containPoint: function() {},
    setDisplacementData: function(data, width, height) {
        this.displacementData = data;
        this.displacementWidth = width;
        this.displacementHeight = height;
    },
    _getDisplacementScale: function(lng, lat) {
        var i = (lng + 180) / 360 * (this.displacementWidth - 1);
        var j = (90 - lat) / 180 * (this.displacementHeight - 1); // NEAREST SAMPLING
        // TODO Better bilinear sampling
        var idx = Math.round(i) + Math.round(j) * this.displacementWidth;
        return this.displacementData[idx];
    },
    dataToPoint: function(data, out) {
        var lng = data[0];
        var lat = data[1]; // Default have 0 altitude
        var altVal = data[2] || 0;
        var r = this.radius;
        if (this.displacementData) {
            r *= 1 + this._getDisplacementScale(lng, lat);
        }
        if (this.altitudeAxis) {
            r += this.altitudeAxis.dataToCoord(altVal);
        }
        lng = lng * Math.PI / 180;
        lat = lat * Math.PI / 180;
        var r0 = Math.cos(lat) * r;
        out = out || []; // PENDING
        out[0] = -r0 * Math.cos(lng + Math.PI);
        out[1] = Math.sin(lat) * r;
        out[2] = r0 * Math.sin(lng + Math.PI);
        return out;
    },
    pointToData: function(point, out) {
        var x = point[0];
        var y = point[1];
        var z = point[2];
        var len = vec3.len(point);
        x /= len;
        y /= len;
        z /= len;
        var theta = Math.asin(y);
        var phi = Math.atan2(z, -x);
        if (phi < 0) {
            phi = Math.PI * 2 + phi;
        }
        var lat = theta * 180 / Math.PI;
        var lng = phi * 180 / Math.PI - 180;
        out = out || [];
        out[0] = lng;
        out[1] = lat;
        out[2] = len - this.radius;
        if (this.altitudeAxis) {
            out[2] = this.altitudeAxis.coordToData(out[2]);
        }
        return out;
    }
};
const __TURBOPACK__default__export__ = Globe;
}}),
"[project]/node_modules/echarts-gl/lib/coord/globeCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$globe$2f$Globe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/globe/Globe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/coord/Axis.js [app-client] (ecmascript) <export default as Axis>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/util/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
;
;
;
;
;
;
function getDisplacementData(img, displacementScale) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var width = img.width;
    var height = img.height;
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    var rgbaArr = ctx.getImageData(0, 0, width, height).data;
    var displacementArr = new Float32Array(rgbaArr.length / 4);
    for(var i = 0; i < rgbaArr.length / 4; i++){
        var x = rgbaArr[i * 4];
        displacementArr[i] = x / 255 * displacementScale;
    }
    return {
        data: displacementArr,
        width: width,
        height: height
    };
}
function resizeGlobe(globeModel, api) {
    // Use left/top/width/height
    var boxLayoutOption = globeModel.getBoxLayoutParams();
    var viewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutRect"])(boxLayoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
    }); // Flip Y
    viewport.y = api.getHeight() - viewport.y - viewport.height;
    this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
    this.radius = globeModel.get('globeRadius');
    var outerRadius = globeModel.get('globeOuterRadius');
    if (this.altitudeAxis) {
        this.altitudeAxis.setExtent(0, outerRadius - this.radius);
    }
}
function updateGlobe(ecModel, api) {
    var altitudeDataExtent = [
        Infinity,
        -Infinity
    ];
    ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem !== this) {
            return;
        } // Get altitude data extent.
        var data = seriesModel.getData();
        var altDims = seriesModel.coordDimToDataDim('alt');
        var altDim = altDims && altDims[0];
        if (altDim) {
            // TODO altitiude is in coords of lines.
            var dataExtent = data.getDataExtent(altDim, true);
            altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
            altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
        }
    }, this); // Create altitude axis
    if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
        var scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createScale(altitudeDataExtent, {
            type: 'value',
            // PENDING
            min: 'dataMin',
            max: 'dataMax'
        });
        this.altitudeAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$coord$2f$Axis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Axis$3e$__["Axis"]('altitude', scale); // Resize again
        this.resize(this.model, api);
    }
}
var globeCreator = {
    dimensions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$globe$2f$Globe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.dimensions,
    create: function(ecModel, api) {
        var globeList = [];
        ecModel.eachComponent('globe', function(globeModel) {
            // FIXME
            globeModel.__viewGL = globeModel.__viewGL || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            var globe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$globe$2f$Globe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            globe.viewGL = globeModel.__viewGL;
            globeModel.coordinateSystem = globe;
            globe.model = globeModel;
            globeList.push(globe); // Inject resize
            globe.resize = resizeGlobe;
            globe.resize(globeModel, api);
            globe.update = updateGlobe;
        });
        ecModel.eachSeries(function(seriesModel) {
            if (seriesModel.get('coordinateSystem') === 'globe') {
                var globeModel = seriesModel.getReferringComponents('globe').models[0];
                if (!globeModel) {
                    globeModel = ecModel.getComponent('globe');
                }
                if (!globeModel) {
                    throw new Error('globe "' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('globe3DIndex'), seriesModel.get('globe3DId'), 0) + '" not found');
                }
                var coordSys = globeModel.coordinateSystem;
                seriesModel.coordinateSystem = coordSys;
            }
        });
        ecModel.eachComponent('globe', function(globeModel, idx) {
            var globe = globeModel.coordinateSystem; // Update displacement data
            var displacementTextureValue = globeModel.getDisplacementTexture();
            var displacementScale = globeModel.getDisplacemenScale();
            if (globeModel.isDisplacementChanged()) {
                if (globeModel.hasDisplacement()) {
                    var immediateLoaded = true;
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadTexture(displacementTextureValue, api, function(texture) {
                        var img = texture.image;
                        var displacementData = getDisplacementData(img, displacementScale);
                        globeModel.setDisplacementData(displacementData.data, displacementData.width, displacementData.height);
                        if (!immediateLoaded) {
                            // Update layouts
                            api.dispatchAction({
                                type: 'globeUpdateDisplacment'
                            });
                        }
                    });
                    immediateLoaded = false;
                } else {
                    globe.setDisplacementData(null, 0, 0);
                }
                globe.setDisplacementData(globeModel.displacementData, globeModel.displacementWidth, globeModel.displacementHeight);
            }
        });
        return globeList;
    }
};
const __TURBOPACK__default__export__ = globeCreator;
}}),
"[project]/node_modules/echarts-gl/lib/component/globe/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$GlobeModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/globe/GlobeModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$GlobeView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/globe/GlobeView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$globeCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/globeCreator.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerComponentModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$GlobeModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerComponentView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$GlobeView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerCoordinateSystem('globe', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$globeCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'globeChangeCamera',
        event: 'globecamerachanged',
        update: 'series:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'globe',
            query: payload
        }, function(componentModel) {
            componentModel.setView(payload);
        });
    });
    registers.registerAction({
        type: 'globeUpdateDisplacment',
        event: 'globedisplacementupdated',
        update: 'update'
    }, function(payload, ecModel) {});
}
}}),
"[project]/node_modules/echarts-gl/lib/component/globe.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/globe/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
;
;
;
var MAPBOX_CAMERA_OPTION = [
    'zoom',
    'center',
    'pitch',
    'bearing'
];
var Mapbox3DModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'mapbox3D',
    layoutMode: 'box',
    coordinateSystem: null,
    defaultOption: {
        zlevel: -10,
        style: 'mapbox://styles/mapbox/light-v9',
        center: [
            0,
            0
        ],
        zoom: 0,
        pitch: 0,
        bearing: 0,
        light: {
            main: {
                alpha: 20,
                beta: 30
            }
        },
        altitudeScale: 1,
        // Default depend on altitudeScale
        boxHeight: 'auto'
    },
    getMapboxCameraOption: function() {
        var self = this;
        return MAPBOX_CAMERA_OPTION.reduce(function(obj, key) {
            obj[key] = self.get(key);
            return obj;
        }, {});
    },
    setMapboxCameraOption: function(option) {
        if (option != null) {
            MAPBOX_CAMERA_OPTION.forEach(function(key) {
                if (option[key] != null) {
                    this.option[key] = option[key];
                }
            }, this);
        }
    },
    /**
   * Get mapbox instance
   */ getMapbox: function() {
        return this._mapbox;
    },
    setMapbox: function(mapbox) {
        this._mapbox = mapbox;
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Mapbox3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Mapbox3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Mapbox3DModel;
}}),
"[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DLayer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @constructor
 * @alias module:echarts-gl/component/mapbox3D/Mapbox3DLayer
 * @param {string} id Layer ID
 * @param {module:zrender/ZRender} zr
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function Mapbox3DLayer(id, zr) {
    this.id = id;
    this.zr = zr;
    this.dom = document.createElement('div');
    this.dom.style.cssText = 'position:absolute;left:0;right:0;top:0;bottom:0;'; // FIXME If in module environment.
    if (!mapboxgl) {
        throw new Error('Mapbox GL library must be included. See https://www.mapbox.com/mapbox-gl-js/api/');
    }
    this._mapbox = new mapboxgl.Map({
        container: this.dom
    }); // Proxy events
    this._initEvents();
}
Mapbox3DLayer.prototype.setUnpainted = function() {};
Mapbox3DLayer.prototype.resize = function() {
    this._mapbox.resize();
};
Mapbox3DLayer.prototype.getMapbox = function() {
    return this._mapbox;
};
Mapbox3DLayer.prototype.clear = function() {};
Mapbox3DLayer.prototype.refresh = function() {
    this._mapbox.resize();
};
var EVENTS = [
    'mousedown',
    'mouseup',
    'click',
    'dblclick',
    'mousemove',
    'mousewheel',
    'wheel',
    'touchstart',
    'touchend',
    'touchmove',
    'touchcancel'
];
Mapbox3DLayer.prototype._initEvents = function() {
    // Event is bound on canvas container.
    var mapboxRoot = this._mapbox.getCanvasContainer();
    this._handlers = this._handlers || {
        contextmenu: function(e) {
            e.preventDefault();
            return false;
        }
    };
    EVENTS.forEach(function(eName) {
        this._handlers[eName] = function(e) {
            var obj = {};
            for(var name in e){
                obj[name] = e[name];
            }
            obj.bubbles = false;
            var newE = new e.constructor(e.type, obj);
            mapboxRoot.dispatchEvent(newE);
        };
        this.zr.dom.addEventListener(eName, this._handlers[eName]);
    }, this); // PENDING
    this.zr.dom.addEventListener('contextmenu', this._handlers.contextmenu);
};
Mapbox3DLayer.prototype.dispose = function() {
    EVENTS.forEach(function(eName) {
        this.zr.dom.removeEventListener(eName, this._handlers[eName]);
    }, this);
};
const __TURBOPACK__default__export__ = Mapbox3DLayer;
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/displayShadow.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "\n@export ecgl.displayShadow.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\nvarying vec3 v_WorldPosition;\n\nvarying vec3 v_Normal;\n\nvoid main()\n{\n @import ecgl.common.uv.main\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n\n v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n\n@end\n\n\n@export ecgl.displayShadow.fragment\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform float roughness: 0.2;\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n@import ecgl.common.ssaoMap.header\n\n@import clay.plugin.compute_shadow_map\n\nvoid main()\n{\n float shadow = 1.0;\n\n @import ecgl.common.ssaoMap.main\n\n#if defined(DIRECTIONAL_LIGHT_COUNT) && defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n for (int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++) {\n shadow = min(shadow, shadowContribsDir[i] * 0.5 + 0.5);\n }\n#endif\n\n shadow *= 0.5 + ao * 0.5;\n shadow = clamp(shadow, 0.0, 1.0);\n\n gl_FragColor = vec4(vec3(0.0), 1.0 - shadow);\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Component.js [app-client] (ecmascript) <export default as ComponentView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DLayer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DLayer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$displayShadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/displayShadow.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$displayShadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var TILE_SIZE = 512;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__["ComponentView"].extend({
    type: 'mapbox3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        var zr = api.getZr();
        this._zrLayer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DLayer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('mapbox3D', zr);
        zr.painter.insertLayer(-1000, this._zrLayer);
        this._lightRoot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this._lightRoot);
        this._sceneHelper.initLight(this._lightRoot);
        var mapbox = this._zrLayer.getMapbox();
        var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, mapbox); // PENDING
        [
            'zoom',
            'rotate',
            'drag',
            'pitch',
            'rotate',
            'move'
        ].forEach(function(eName) {
            mapbox.on(eName, dispatchInteractAction);
        });
        this._groundMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PlaneGeometry(),
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader({
                    vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.displayShadow.vertex'),
                    fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.displayShadow.fragment')
                }),
                depthMask: false
            }),
            // Render first
            renderOrder: -100,
            culling: false,
            castShadow: false,
            $ignorePicking: true,
            renderNormal: true
        });
    },
    render: function(mapbox3DModel, ecModel, api) {
        var mapbox = this._zrLayer.getMapbox();
        var styleDesc = mapbox3DModel.get('style');
        var styleStr = JSON.stringify(styleDesc);
        if (styleStr !== this._oldStyleStr) {
            if (styleDesc) {
                mapbox.setStyle(styleDesc);
            }
        }
        this._oldStyleStr = styleStr;
        mapbox.setCenter(mapbox3DModel.get('center'));
        mapbox.setZoom(mapbox3DModel.get('zoom'));
        mapbox.setPitch(mapbox3DModel.get('pitch'));
        mapbox.setBearing(mapbox3DModel.get('bearing'));
        mapbox3DModel.setMapbox(mapbox);
        var coordSys = mapbox3DModel.coordinateSystem; // Not add to rootNode. Or light direction will be stretched by rootNode scale
        coordSys.viewGL.scene.add(this._lightRoot);
        coordSys.viewGL.add(this._groundMesh);
        this._updateGroundMesh(); // Update lights
        this._sceneHelper.setScene(coordSys.viewGL.scene);
        this._sceneHelper.updateLight(mapbox3DModel); // Update post effects
        coordSys.viewGL.setPostEffect(mapbox3DModel.getModel('postEffect'), api);
        coordSys.viewGL.setTemporalSuperSampling(mapbox3DModel.getModel('temporalSuperSampling'));
        this._mapbox3DModel = mapbox3DModel;
    },
    afterRender: function(mapbox3DModel, ecModel, api, layerGL) {
        var renderer = layerGL.renderer;
        this._sceneHelper.updateAmbientCubemap(renderer, mapbox3DModel, api);
        this._sceneHelper.updateSkybox(renderer, mapbox3DModel, api); // FIXME If other series changes coordinate system.
        // FIXME When doing progressive rendering.
        mapbox3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh) {
            if (mesh.material) {
                mesh.material.define('fragment', 'NORMAL_UP_AXIS', 2);
                mesh.material.define('fragment', 'NORMAL_FRONT_AXIS', 1);
            }
        });
    },
    updateCamera: function(mapbox3DModel, ecModel, api, payload) {
        mapbox3DModel.coordinateSystem.setCameraOption(payload);
        this._updateGroundMesh();
        api.getZr().refresh();
    },
    _dispatchInteractAction: function(api, mapbox, mapbox3DModel) {
        api.dispatchAction({
            type: 'mapbox3DChangeCamera',
            pitch: mapbox.getPitch(),
            zoom: mapbox.getZoom(),
            center: mapbox.getCenter().toArray(),
            bearing: mapbox.getBearing(),
            mapbox3DId: this._mapbox3DModel && this._mapbox3DModel.id
        });
    },
    _updateGroundMesh: function() {
        if (this._mapbox3DModel) {
            var coordSys = this._mapbox3DModel.coordinateSystem;
            var pt = coordSys.dataToPoint(coordSys.center);
            this._groundMesh.position.set(pt[0], pt[1], -0.001);
            var plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Plane(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3(0, 0, 1), 0);
            var ray1 = coordSys.viewGL.camera.castRay(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector2(-1, -1));
            var ray2 = coordSys.viewGL.camera.castRay(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector2(1, 1));
            var pos0 = ray1.intersectPlane(plane);
            var pos1 = ray2.intersectPlane(plane);
            var scale = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
            this._groundMesh.scale.set(scale, scale, 1);
        }
    },
    dispose: function(ecModel, api) {
        if (this._zrLayer) {
            this._zrLayer.dispose();
        }
        api.getZr().painter.delLayer(-1000);
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
var mat4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mat4;
var TILE_SIZE = 512;
var FOV = 0.6435011087932844;
var PI = Math.PI;
var WORLD_SCALE = 1 / 10;
function MapServiceCoordSys3D() {
    /**
   * Width of mapbox viewport
   */ this.width = 0;
    /**
   * Height of mapbox viewport
   */ this.height = 0;
    this.altitudeScale = 1; // TODO Change boxHeight won't have animation.
    this.boxHeight = 'auto'; // Set by mapbox creator
    this.altitudeExtent;
    this.bearing = 0;
    this.pitch = 0;
    this.center = [
        0,
        0
    ];
    this._origin;
    this.zoom = 0;
    this._initialZoom; // Some parameters for different map services.
    this.maxPitch = 60;
    this.zoomOffset = 0;
}
MapServiceCoordSys3D.prototype = {
    constructor: MapServiceCoordSys3D,
    dimensions: [
        'lng',
        'lat',
        'alt'
    ],
    containPoint: function() {},
    setCameraOption: function(option) {
        this.bearing = option.bearing;
        this.pitch = option.pitch;
        this.center = option.center;
        this.zoom = option.zoom;
        if (!this._origin) {
            this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);
        }
        if (this._initialZoom == null) {
            this._initialZoom = this.zoom;
        }
        this.updateTransform();
    },
    // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479
    updateTransform: function() {
        if (!this.height) {
            return;
        }
        var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE; // Convert to radian.
        var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI; // Find the distance from the center point [width/2, height/2] to the
        // center top point [width/2, 0] in Z units, using the law of sines.
        // 1 Z unit is equivalent to 1 horizontal px at the center of the map
        // (the distance between[width/2, height/2] and [width/2 + 1, height/2])
        var halfFov = FOV / 2;
        var groundAngle = Math.PI / 2 + pitch;
        var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered.
        var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`
        var farZ = furthestDistance * 1.1; // Forced to be 1000
        if (this.pitch > 50) {
            farZ = 1000;
        } // matrix for conversion from location to GL coordinates (-1 .. 1)
        var m = [];
        mat4.perspective(m, FOV, this.width / this.height, 1, farZ);
        this.viewGL.camera.projectionMatrix.setArray(m);
        this.viewGL.camera.decomposeProjectionMatrix();
        var m = mat4.identity([]);
        var pt = this.dataToPoint(this.center); // Inverse
        mat4.scale(m, m, [
            1,
            -1,
            1
        ]); // Translate to altitude
        mat4.translate(m, m, [
            0,
            0,
            -cameraToCenterDistance
        ]);
        mat4.rotateX(m, m, pitch);
        mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI); // Translate to center.
        mat4.translate(m, m, [
            -pt[0] * this.getScale() * WORLD_SCALE,
            -pt[1] * this.getScale() * WORLD_SCALE,
            0
        ]);
        this.viewGL.camera.viewMatrix.array = m;
        var invertM = [];
        mat4.invert(invertM, m);
        this.viewGL.camera.worldTransform.array = invertM;
        this.viewGL.camera.decomposeWorldTransform(); // scale vertically to meters per pixel (inverse of ground resolution):
        // worldSize / (circumferenceOfEarth * cos(lat * π / 180))
        var worldSize = TILE_SIZE * this.getScale();
        var verticalScale;
        if (this.altitudeExtent && !isNaN(this.boxHeight)) {
            var range = this.altitudeExtent[1] - this.altitudeExtent[0];
            verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);
        } else {
            verticalScale = worldSize / (2 * Math.PI * 6378000 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;
        } // Include scale to avoid relayout when zooming
        // FIXME Camera scale may have problem in shadow
        this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);
    },
    getScale: function() {
        return Math.pow(2, this.zoom - this.zoomOffset);
    },
    projectOnTile: function(data, out) {
        return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);
    },
    projectOnTileWithScale: function(data, scale, out) {
        var lng = data[0];
        var lat = data[1];
        var lambda2 = lng * PI / 180;
        var phi2 = lat * PI / 180;
        var x = scale * (lambda2 + PI) / (2 * PI);
        var y = scale * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);
        out = out || [];
        out[0] = x;
        out[1] = y;
        return out;
    },
    unprojectFromTile: function(point, out) {
        return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);
    },
    unprojectOnTileWithScale: function(point, scale, out) {
        var x = point[0];
        var y = point[1];
        var lambda2 = x / scale * (2 * PI) - PI;
        var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI / 4);
        out = out || [];
        out[0] = lambda2 * 180 / PI;
        out[1] = phi2 * 180 / PI;
        return out;
    },
    dataToPoint: function(data, out) {
        out = this.projectOnTileWithScale(data, TILE_SIZE, out); // Add a origin to avoid precision issue in WebGL.
        out[0] -= this._origin[0];
        out[1] -= this._origin[1]; // PENDING
        out[2] = !isNaN(data[2]) ? data[2] : 0;
        if (!isNaN(data[2])) {
            out[2] = data[2];
            if (this.altitudeExtent) {
                out[2] -= this.altitudeExtent[0];
            }
        }
        return out;
    }
};
const __TURBOPACK__default__export__ = MapServiceCoordSys3D;
}}),
"[project]/node_modules/echarts-gl/lib/coord/mapbox3D/Mapbox3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js [app-client] (ecmascript)");
;
function Mapbox3D() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].apply(this, arguments);
}
Mapbox3D.prototype = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
Mapbox3D.prototype.constructor = Mapbox3D;
Mapbox3D.prototype.type = 'mapbox3D';
const __TURBOPACK__default__export__ = Mapbox3D;
}}),
"[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/createMapService3DCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
;
;
;
function __TURBOPACK__default__export__(serviceComponentType, ServiceCtor, afterCreate) {
    function resizeMapService3D(mapService3DModel, api) {
        var width = api.getWidth();
        var height = api.getHeight();
        var dpr = api.getDevicePixelRatio();
        this.viewGL.setViewport(0, 0, width, height, dpr);
        this.width = width;
        this.height = height;
        this.altitudeScale = mapService3DModel.get('altitudeScale');
        this.boxHeight = mapService3DModel.get('boxHeight'); // this.updateTransform();
    }
    function updateService3D(ecModel, api) {
        if (this.model.get('boxHeight') === 'auto') {
            return;
        }
        var altitudeDataExtent = [
            Infinity,
            -Infinity
        ];
        ecModel.eachSeries(function(seriesModel) {
            if (seriesModel.coordinateSystem !== this) {
                return;
            } // Get altitude data extent.
            var data = seriesModel.getData();
            var altDim = seriesModel.coordDimToDataDim('alt')[0];
            if (altDim) {
                // TODO altitiude is in coords of lines.
                var dataExtent = data.getDataExtent(altDim, true);
                altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
                altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
            }
        }, this);
        if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
            this.altitudeExtent = altitudeDataExtent;
        }
    }
    return {
        dimensions: ServiceCtor.prototype.dimensions,
        create: function(ecModel, api) {
            var mapService3DList = [];
            ecModel.eachComponent(serviceComponentType, function(mapService3DModel) {
                var viewGL = mapService3DModel.__viewGL;
                if (!viewGL) {
                    viewGL = mapService3DModel.__viewGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                    viewGL.setRootNode(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node());
                }
                var mapService3DCoordSys = new ServiceCtor();
                mapService3DCoordSys.viewGL = mapService3DModel.__viewGL; // Inject resize
                mapService3DCoordSys.resize = resizeMapService3D;
                mapService3DCoordSys.resize(mapService3DModel, api);
                mapService3DList.push(mapService3DCoordSys);
                mapService3DModel.coordinateSystem = mapService3DCoordSys;
                mapService3DCoordSys.model = mapService3DModel;
                mapService3DCoordSys.update = updateService3D;
            });
            ecModel.eachSeries(function(seriesModel) {
                if (seriesModel.get('coordinateSystem') === serviceComponentType) {
                    var mapService3DModel = seriesModel.getReferringComponents(serviceComponentType).models[0];
                    if (!mapService3DModel) {
                        mapService3DModel = ecModel.getComponent(serviceComponentType);
                    }
                    if (!mapService3DModel) {
                        throw new Error(serviceComponentType + ' "' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get(serviceComponentType + 'Index'), seriesModel.get(serviceComponentType + 'Id'), 0) + '" not found');
                    }
                    seriesModel.coordinateSystem = mapService3DModel.coordinateSystem;
                }
            });
            afterCreate && afterCreate(mapService3DList, ecModel, api);
            return mapService3DList;
        }
    };
}
}}),
"[project]/node_modules/echarts-gl/lib/coord/mapbox3DCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapbox3D$2f$Mapbox3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapbox3D/Mapbox3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$createMapService3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/createMapService3DCreator.js [app-client] (ecmascript)");
;
;
var mapbox3DCreator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$createMapService3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('mapbox3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapbox3D$2f$Mapbox3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], function(mapbox3DList) {
    mapbox3DList.forEach(function(mapbox3D) {
        mapbox3D.setCameraOption(mapbox3D.model.getMapboxCameraOption());
    });
});
const __TURBOPACK__default__export__ = mapbox3DCreator;
}}),
"[project]/node_modules/echarts-gl/lib/component/mapbox3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapbox3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapbox3DCreator.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerComponentModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerComponentView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$Mapbox3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerCoordinateSystem('mapbox3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapbox3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'mapbox3DChangeCamera',
        event: 'mapbox3dcamerachanged',
        update: 'mapbox3D:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'mapbox3D',
            query: payload
        }, function(componentModel) {
            componentModel.setMapboxCameraOption(payload);
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/component/mapbox3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/mapbox3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Component.js [app-client] (ecmascript) <export default as ComponentModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
;
;
;
var MAPTALKS_CAMERA_OPTION = [
    'zoom',
    'center',
    'pitch',
    'bearing'
];
var Maptalks3DModel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentModel$3e$__["ComponentModel"].extend({
    type: 'maptalks3D',
    layoutMode: 'box',
    coordinateSystem: null,
    defaultOption: {
        zlevel: -10,
        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>',
        center: [
            0,
            0
        ],
        zoom: 0,
        pitch: 0,
        bearing: 0,
        light: {
            main: {
                alpha: 20,
                beta: 30
            }
        },
        altitudeScale: 1,
        // Default depend on altitudeScale
        boxHeight: 'auto'
    },
    getMaptalksCameraOption: function() {
        var self = this;
        return MAPTALKS_CAMERA_OPTION.reduce(function(obj, key) {
            obj[key] = self.get(key);
            return obj;
        }, {});
    },
    setMaptalksCameraOption: function(option) {
        if (option != null) {
            MAPTALKS_CAMERA_OPTION.forEach(function(key) {
                if (option[key] != null) {
                    this.option[key] = option[key];
                }
            }, this);
        }
    },
    /**
   * Get maptalks instance
   */ getMaptalks: function() {
        return this._maptalks;
    },
    setMaptalks: function(maptalks) {
        this._maptalks = maptalks;
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Maptalks3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Maptalks3DModel.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Maptalks3DModel;
}}),
"[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DLayer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @constructor
 * @alias module:echarts-gl/component/maptalks/Maptalks3DLayer
 * @param {string} id Layer ID
 * @param {module:zrender/ZRender} zr
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function Maptalks3DLayer(id, zr, defaultCenter, defaultZoom) {
    this.id = id;
    this.zr = zr;
    this.dom = document.createElement('div');
    this.dom.style.cssText = 'position:absolute;left:0;right:0;top:0;bottom:0;'; // FIXME If in module environment.
    if (!maptalks) {
        throw new Error('Maptalks library must be included. See https://maptalks.org');
    }
    this._maptalks = new maptalks.Map(this.dom, {
        center: defaultCenter,
        zoom: defaultZoom,
        doubleClickZoom: false,
        fog: false // fogColor: [0, 0, 0]
    }); // Proxy events
    this._initEvents();
}
Maptalks3DLayer.prototype.setUnpainted = function() {};
Maptalks3DLayer.prototype.resize = function() {
    this._maptalks.checkSize();
};
Maptalks3DLayer.prototype.getMaptalks = function() {
    return this._maptalks;
};
Maptalks3DLayer.prototype.clear = function() {};
Maptalks3DLayer.prototype.refresh = function() {
    this._maptalks.checkSize();
};
var EVENTS = [
    'mousedown',
    'mouseup',
    'click',
    'dblclick',
    'mousemove',
    'mousewheel',
    'DOMMouseScroll',
    'touchstart',
    'touchend',
    'touchmove',
    'touchcancel'
];
Maptalks3DLayer.prototype._initEvents = function() {
    // Event is bound on canvas container.
    var maptalksRoot = this.dom;
    this._handlers = this._handlers || {
        contextmenu: function(e) {
            e.preventDefault();
            return false;
        }
    };
    EVENTS.forEach(function(eName) {
        this._handlers[eName] = function(e) {
            var obj = {};
            for(var name in e){
                obj[name] = e[name];
            }
            obj.bubbles = false;
            var newE = new e.constructor(e.type, obj);
            if (eName === 'mousewheel' || eName === 'DOMMouseScroll') {
                // maptalks listens events to different elements?
                maptalksRoot.dispatchEvent(newE);
            } else {
                maptalksRoot.firstElementChild.dispatchEvent(newE);
            }
        };
        this.zr.dom.addEventListener(eName, this._handlers[eName]);
    }, this); // PENDING
    this.zr.dom.addEventListener('contextmenu', this._handlers.contextmenu);
};
Maptalks3DLayer.prototype.dispose = function() {
    EVENTS.forEach(function(eName) {
        this.zr.dom.removeEventListener(eName, this._handlers[eName]);
    }, this);
    this._maptalks.remove();
};
const __TURBOPACK__default__export__ = Maptalks3DLayer;
}}),
"[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Component.js [app-client] (ecmascript) <export default as ComponentView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DLayer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DLayer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$displayShadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/displayShadow.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$displayShadow$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ComponentView$3e$__["ComponentView"].extend({
    type: 'maptalks3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this._groundMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PlaneGeometry(),
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader({
                    vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.displayShadow.vertex'),
                    fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.displayShadow.fragment')
                }),
                depthMask: false
            }),
            // Render first
            renderOrder: -100,
            culling: false,
            castShadow: false,
            $ignorePicking: true,
            renderNormal: true
        });
    },
    _initMaptalksLayer: function(mapbox3DModel, api) {
        var zr = api.getZr();
        this._zrLayer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DLayer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('maptalks3D', zr, mapbox3DModel.get('center'), mapbox3DModel.get('zoom'));
        zr.painter.insertLayer(-1000, this._zrLayer);
        this._lightRoot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this._lightRoot);
        this._sceneHelper.initLight(this._lightRoot);
        var maptalks1 = this._zrLayer.getMaptalks();
        var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, maptalks1); // PENDING
        [
            'zoomend',
            'zooming',
            'zoomstart',
            'dragrotating',
            'pitch',
            'pitchend',
            'movestart',
            'moving',
            'moveend',
            'resize',
            'touchstart',
            'touchmove',
            'touchend',
            'animating'
        ].forEach(function(eName) {
            maptalks1.on(eName, dispatchInteractAction);
        });
    },
    render: function(maptalks3DModel, ecModel, api) {
        if (!this._zrLayer) {
            this._initMaptalksLayer(maptalks3DModel, api);
        }
        var mtks = this._zrLayer.getMaptalks();
        var urlTemplate = maptalks3DModel.get('urlTemplate');
        var baseLayer = mtks.getBaseLayer();
        if (urlTemplate !== this._oldUrlTemplate) {
            if (!baseLayer) {
                baseLayer = new maptalks.TileLayer('maptalks-echarts-gl-baselayer', {
                    urlTemplate: urlTemplate,
                    // used sequentially to help with browser parallel requests per domain limitation
                    subdomains: [
                        'a',
                        'b',
                        'c'
                    ],
                    attribution: maptalks3DModel.get('attribution')
                });
                mtks.setBaseLayer(baseLayer);
            } else {
                // PENDING setOptions may not work?
                baseLayer.setOptions({
                    urlTemplate: urlTemplate,
                    attribution: maptalks3DModel.get('attribution')
                });
            }
        }
        this._oldUrlTemplate = urlTemplate;
        mtks.setCenter(maptalks3DModel.get('center'));
        mtks.setZoom(maptalks3DModel.get('zoom'), {
            animation: false
        });
        mtks.setPitch(maptalks3DModel.get('pitch'));
        mtks.setBearing(maptalks3DModel.get('bearing'));
        maptalks3DModel.setMaptalks(mtks);
        var coordSys = maptalks3DModel.coordinateSystem; // Not add to rootNode. Or light direction will be stretched by rootNode scale
        coordSys.viewGL.scene.add(this._lightRoot);
        coordSys.viewGL.add(this._groundMesh);
        this._updateGroundMesh(); // Update lights
        this._sceneHelper.setScene(coordSys.viewGL.scene);
        this._sceneHelper.updateLight(maptalks3DModel); // Update post effects
        coordSys.viewGL.setPostEffect(maptalks3DModel.getModel('postEffect'), api);
        coordSys.viewGL.setTemporalSuperSampling(maptalks3DModel.getModel('temporalSuperSampling'));
        this._maptalks3DModel = maptalks3DModel;
    },
    afterRender: function(maptalks3DModel, ecModel, api, layerGL) {
        var renderer = layerGL.renderer;
        this._sceneHelper.updateAmbientCubemap(renderer, maptalks3DModel, api);
        this._sceneHelper.updateSkybox(renderer, maptalks3DModel, api); // FIXME If other series changes coordinate system.
        // FIXME When doing progressive rendering.
        maptalks3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh) {
            if (mesh.material) {
                mesh.material.define('fragment', 'NORMAL_UP_AXIS', 2);
                mesh.material.define('fragment', 'NORMAL_FRONT_AXIS', 1);
            }
        });
    },
    updateCamera: function(maptalks3DModel, ecModel, api, payload) {
        maptalks3DModel.coordinateSystem.setCameraOption(payload);
        this._updateGroundMesh();
        api.getZr().refresh();
    },
    _dispatchInteractAction: function(api, maptalks1, maptalks3DModel) {
        api.dispatchAction({
            type: 'maptalks3DChangeCamera',
            pitch: maptalks1.getPitch(),
            zoom: getMapboxZoom(maptalks1.getResolution()) + 1,
            center: maptalks1.getCenter().toArray(),
            bearing: maptalks1.getBearing(),
            maptalks3DId: this._maptalks3DModel && this._maptalks3DModel.id
        });
    },
    _updateGroundMesh: function() {
        if (this._maptalks3DModel) {
            var coordSys = this._maptalks3DModel.coordinateSystem;
            var pt = coordSys.dataToPoint(coordSys.center);
            this._groundMesh.position.set(pt[0], pt[1], -0.001);
            var plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Plane(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3(0, 0, 1), 0);
            var ray1 = coordSys.viewGL.camera.castRay(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector2(-1, -1));
            var ray2 = coordSys.viewGL.camera.castRay(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector2(1, 1));
            var pos0 = ray1.intersectPlane(plane);
            var pos1 = ray2.intersectPlane(plane);
            var scale = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
            this._groundMesh.scale.set(scale, scale, 1);
        }
    },
    dispose: function(ecModel, api) {
        if (this._zrLayer) {
            this._zrLayer.dispose();
        }
        api.getZr().painter.delLayer(-1000);
    }
});
const MAX_RES = 2 * 6378137 * Math.PI / (256 * Math.pow(2, 20));
function getMapboxZoom(res) {
    return 19 - Math.log(res / MAX_RES) / Math.LN2;
}
}}),
"[project]/node_modules/echarts-gl/lib/coord/maptalks3D/Maptalks3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js [app-client] (ecmascript)");
;
function Maptalks3D() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].apply(this, arguments);
    this.maxPitch = 85;
    this.zoomOffset = 1;
}
Maptalks3D.prototype = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$MapService3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
Maptalks3D.prototype.constructor = Maptalks3D;
Maptalks3D.prototype.type = 'maptalks3D';
const __TURBOPACK__default__export__ = Maptalks3D;
}}),
"[project]/node_modules/echarts-gl/lib/coord/maptalks3DCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$maptalks3D$2f$Maptalks3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/maptalks3D/Maptalks3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$createMapService3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/mapServiceCommon/createMapService3DCreator.js [app-client] (ecmascript)");
;
;
var maptalks3DCreator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$mapServiceCommon$2f$createMapService3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('maptalks3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$maptalks3D$2f$Maptalks3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], function(maptalks3DList) {
    maptalks3DList.forEach(function(maptalks3D) {
        maptalks3D.setCameraOption(maptalks3D.model.getMaptalksCameraOption());
    });
});
const __TURBOPACK__default__export__ = maptalks3DCreator;
}}),
"[project]/node_modules/echarts-gl/lib/component/maptalks3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$maptalks3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/maptalks3DCreator.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerComponentModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerComponentView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$Maptalks3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerCoordinateSystem('maptalks3D', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$maptalks3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'maptalks3DChangeCamera',
        event: 'maptalks3dcamerachanged',
        update: 'maptalks3D:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'maptalks3D',
            query: payload
        }, function(componentModel) {
            componentModel.setMaptalksCameraOption(payload);
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/component/maptalks3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Thanks to https://gitee.com/iverson_hu/maptalks-echarts-gl
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/maptalks3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/cartesian3DLayout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var isDimensionStacked = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].dataStack.isDimensionStacked;
function ifCrossZero(extent) {
    var min = extent[0];
    var max = extent[1];
    return !(min > 0 && max > 0 || min < 0 && max < 0);
}
;
function cartesian3DLayout(seriesModel, coordSys) {
    var data = seriesModel.getData(); // var barOnPlane = seriesModel.get('onGridPlane');
    var barSize = seriesModel.get('barSize');
    if (barSize == null) {
        var size = coordSys.size;
        var barWidth;
        var barDepth;
        var xAxis = coordSys.getAxis('x');
        var yAxis = coordSys.getAxis('y');
        if (xAxis.type === 'category') {
            barWidth = xAxis.getBandWidth() * 0.7;
        } else {
            // PENDING
            barWidth = Math.round(size[0] / Math.sqrt(data.count())) * 0.6;
        }
        if (yAxis.type === 'category') {
            barDepth = yAxis.getBandWidth() * 0.7;
        } else {
            barDepth = Math.round(size[1] / Math.sqrt(data.count())) * 0.6;
        }
        barSize = [
            barWidth,
            barDepth
        ];
    } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(barSize)) {
        barSize = [
            barSize,
            barSize
        ];
    }
    var zAxisExtent = coordSys.getAxis('z').scale.getExtent();
    var ifZAxisCrossZero = ifCrossZero(zAxisExtent);
    var dims = [
        'x',
        'y',
        'z'
    ].map(function(coordDimName) {
        return seriesModel.coordDimToDataDim(coordDimName)[0];
    });
    var isStacked = isDimensionStacked(data, dims[2]);
    var valueDim = isStacked ? data.getCalculationInfo('stackResultDimension') : dims[2];
    data.each(dims, function(x, y, z, idx) {
        // TODO zAxis is inversed
        // TODO On different plane.
        var stackedValue = data.get(valueDim, idx);
        var baseValue = isStacked ? stackedValue - z : ifZAxisCrossZero ? 0 : zAxisExtent[0];
        var start = coordSys.dataToPoint([
            x,
            y,
            baseValue
        ]);
        var end = coordSys.dataToPoint([
            x,
            y,
            stackedValue
        ]);
        var height = vec3.dist(start, end); // PENDING When zAxis is not cross zero.
        var dir = [
            0,
            end[1] < start[1] ? -1 : 1,
            0
        ];
        if (Math.abs(height) === 0) {
            // TODO
            height = 0.1;
        }
        var size = [
            barSize[0],
            height,
            barSize[1]
        ];
        data.setItemLayout(idx, [
            start,
            dir,
            size
        ]);
    });
    data.setLayout('orient', [
        1,
        0,
        0
    ]);
}
const __TURBOPACK__default__export__ = cartesian3DLayout;
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/evaluateBarSparseness.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(data, dimX, dimY) {
    var xExtent = data.getDataExtent(dimX);
    var yExtent = data.getDataExtent(dimY); // TODO Handle one data situation
    var xSpan = xExtent[1] - xExtent[0] || xExtent[0];
    var ySpan = yExtent[1] - yExtent[0] || yExtent[0];
    var dimSize = 50;
    var tmp = new Uint8Array(dimSize * dimSize);
    for(var i = 0; i < data.count(); i++){
        var x = data.get(dimX, i);
        var y = data.get(dimY, i);
        var xIdx = Math.floor((x - xExtent[0]) / xSpan * (dimSize - 1));
        var yIdx = Math.floor((y - yExtent[0]) / ySpan * (dimSize - 1));
        var idx = yIdx * dimSize + xIdx;
        tmp[idx] = tmp[idx] || 1;
    }
    var filledCount = 0;
    for(var i = 0; i < tmp.length; i++){
        if (tmp[i]) {
            filledCount++;
        }
    }
    return filledCount / tmp.length;
}
;
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/bar3DLayout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>registerBarLayout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$cartesian3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/cartesian3DLayout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$evaluateBarSparseness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/evaluateBarSparseness.js [app-client] (ecmascript)");
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var isDimensionStacked = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].dataStack.isDimensionStacked;
function globeLayout(seriesModel, coordSys) {
    var data = seriesModel.getData();
    var barMinHeight = seriesModel.get('minHeight') || 0;
    var barSize = seriesModel.get('barSize');
    var dims = [
        'lng',
        'lat',
        'alt'
    ].map(function(coordDimName) {
        return seriesModel.coordDimToDataDim(coordDimName)[0];
    });
    if (barSize == null) {
        var perimeter = coordSys.radius * Math.PI;
        var fillRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$evaluateBarSparseness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, dims[0], dims[1]);
        barSize = [
            perimeter / Math.sqrt(data.count() / fillRatio),
            perimeter / Math.sqrt(data.count() / fillRatio)
        ];
    } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(barSize)) {
        barSize = [
            barSize,
            barSize
        ];
    }
    var valueDim = getValueDimension(data, dims);
    data.each(dims, function(lng, lat, val, idx) {
        var stackedValue = data.get(valueDim.dimension, idx);
        var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0]; // TODO Stacked with minHeight.
        var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
        var start = coordSys.dataToPoint([
            lng,
            lat,
            baseValue
        ]);
        var end = coordSys.dataToPoint([
            lng,
            lat,
            stackedValue
        ]);
        var dir = vec3.sub([], end, start);
        vec3.normalize(dir, dir);
        var size = [
            barSize[0],
            height,
            barSize[1]
        ];
        data.setItemLayout(idx, [
            start,
            dir,
            size
        ]);
    });
    data.setLayout('orient', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UP.array);
}
function geo3DLayout(seriesModel, coordSys) {
    var data = seriesModel.getData();
    var barSize = seriesModel.get('barSize');
    var barMinHeight = seriesModel.get('minHeight') || 0;
    var dims = [
        'lng',
        'lat',
        'alt'
    ].map(function(coordDimName) {
        return seriesModel.coordDimToDataDim(coordDimName)[0];
    });
    if (barSize == null) {
        var size = Math.min(coordSys.size[0], coordSys.size[2]);
        var fillRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$evaluateBarSparseness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, dims[0], dims[1]);
        barSize = [
            size / Math.sqrt(data.count() / fillRatio),
            size / Math.sqrt(data.count() / fillRatio)
        ];
    } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(barSize)) {
        barSize = [
            barSize,
            barSize
        ];
    }
    var dir = [
        0,
        1,
        0
    ];
    var valueDim = getValueDimension(data, dims);
    data.each(dims, function(lng, lat, val, idx) {
        var stackedValue = data.get(valueDim.dimension, idx);
        var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0];
        var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
        var start = coordSys.dataToPoint([
            lng,
            lat,
            baseValue
        ]);
        var size = [
            barSize[0],
            height,
            barSize[1]
        ];
        data.setItemLayout(idx, [
            start,
            dir,
            size
        ]);
    });
    data.setLayout('orient', [
        1,
        0,
        0
    ]);
}
function mapService3DLayout(seriesModel, coordSys) {
    var data = seriesModel.getData();
    var dimLng = seriesModel.coordDimToDataDim('lng')[0];
    var dimLat = seriesModel.coordDimToDataDim('lat')[0];
    var dimAlt = seriesModel.coordDimToDataDim('alt')[0];
    var barSize = seriesModel.get('barSize');
    var barMinHeight = seriesModel.get('minHeight') || 0;
    if (barSize == null) {
        var xExtent = data.getDataExtent(dimLng);
        var yExtent = data.getDataExtent(dimLat);
        var corner0 = coordSys.dataToPoint([
            xExtent[0],
            yExtent[0]
        ]);
        var corner1 = coordSys.dataToPoint([
            xExtent[1],
            yExtent[1]
        ]);
        var size = Math.min(Math.abs(corner0[0] - corner1[0]), Math.abs(corner0[1] - corner1[1])) || 1;
        var fillRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$evaluateBarSparseness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, dimLng, dimLat); // PENDING, data density
        barSize = [
            size / Math.sqrt(data.count() / fillRatio),
            size / Math.sqrt(data.count() / fillRatio)
        ];
    } else {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(barSize)) {
            barSize = [
                barSize,
                barSize
            ];
        }
        barSize[0] /= coordSys.getScale() / 16;
        barSize[1] /= coordSys.getScale() / 16;
    }
    var dir = [
        0,
        0,
        1
    ];
    var dims = [
        dimLng,
        dimLat,
        dimAlt
    ];
    var valueDim = getValueDimension(data, dims);
    data.each(dims, function(lng, lat, val, idx) {
        var stackedValue = data.get(valueDim.dimension, idx);
        var baseValue = valueDim.isStacked ? stackedValue - val : 0;
        var start = coordSys.dataToPoint([
            lng,
            lat,
            baseValue
        ]);
        var end = coordSys.dataToPoint([
            lng,
            lat,
            stackedValue
        ]);
        var height = Math.max(end[2] - start[2], barMinHeight);
        var size = [
            barSize[0],
            height,
            barSize[1]
        ];
        data.setItemLayout(idx, [
            start,
            dir,
            size
        ]);
    });
    data.setLayout('orient', [
        1,
        0,
        0
    ]);
}
function getValueDimension(data, dataDims) {
    var isStacked = isDimensionStacked(data, dataDims[2]);
    return {
        dimension: isStacked ? data.getCalculationInfo('stackResultDimension') : dataDims[2],
        isStacked: isStacked
    };
}
function registerBarLayout(registers) {
    registers.registerLayout(function(ecModel, api) {
        ecModel.eachSeriesByType('bar3D', function(seriesModel) {
            var coordSys = seriesModel.coordinateSystem;
            var coordSysType = coordSys && coordSys.type;
            if (coordSysType === 'globe') {
                globeLayout(seriesModel, coordSys);
            } else if (coordSysType === 'cartesian3D') {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$cartesian3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(seriesModel, coordSys);
            } else if (coordSysType === 'geo3D') {
                geo3DLayout(seriesModel, coordSys);
            } else if (coordSysType === 'mapbox3D' || coordSysType === 'maptalks3D') {
                mapService3DLayout(seriesModel, coordSys);
            } else {
                if ("TURBOPACK compile-time truthy", 1) {
                    if (!coordSys) {
                        throw new Error('bar3D doesn\'t have coordinate system.');
                    } else {
                        throw new Error('bar3D doesn\'t support coordinate system ' + coordSys.type);
                    }
                }
            }
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/format.js [app-client] (ecmascript) <export * as format>");
;
var formatUtil = {};
formatUtil.getFormattedLabel = function(seriesModel, dataIndex, status, dataType, dimIndex) {
    status = status || 'normal';
    var data = seriesModel.getData(dataType);
    var itemModel = data.getItemModel(dataIndex);
    var params = seriesModel.getDataParams(dataIndex, dataType);
    if (dimIndex != null && params.value instanceof Array) {
        params.value = params.value[dimIndex];
    }
    var formatter = itemModel.get(status === 'normal' ? [
        'label',
        'formatter'
    ] : [
        'emphasis',
        'label',
        'formatter'
    ]);
    if (formatter == null) {
        formatter = itemModel.get([
            'label',
            'formatter'
        ]);
    }
    var text;
    if (typeof formatter === 'function') {
        params.status = status;
        text = formatter(params);
    } else if (typeof formatter === 'string') {
        text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].formatTpl(formatter, params);
    }
    return text;
};
/**
 * If value is not array, then convert it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */ formatUtil.normalizeToArray = function(value) {
    return value instanceof Array ? value : value == null ? [] : [
        value
    ];
};
const __TURBOPACK__default__export__ = formatUtil;
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/format.js [app-client] (ecmascript) <export * as format>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
function otherDimToDataDim(data, otherDim) {
    var dataDim = [];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(data.dimensions, function(dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        var otherDims = dimItem.otherDims;
        var dimIndex = otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
            dataDim[dimIndex] = dimItem.name;
        }
    });
    return dataDim;
}
function __TURBOPACK__default__export__(seriesModel, dataIndex, multipleSeries) {
    function formatArrayValue(value) {
        var vertially = true;
        var result = [];
        var tooltipDims = otherDimToDataDim(data, 'tooltip');
        tooltipDims.length ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(tooltipDims, function(dimIdx) {
            setEachItem(data.get(dimIdx, dataIndex), dimIdx);
        }) // By default, all dims is used on tooltip.
         : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(value, setEachItem);
        function setEachItem(val, dimIdx) {
            var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.
            if (!dimInfo || dimInfo.otherDims.tooltip === false) {
                return;
            }
            var dimType = dimInfo.type;
            var valStr = (("TURBOPACK compile-time truthy", 1) ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : ("TURBOPACK unreachable", undefined)) + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].formatTime('yyyy/MM/dd hh:mm:ss', val) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].addCommas(val));
            valStr && result.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(valStr));
        }
        return (("TURBOPACK compile-time truthy", 1) ? '<br/>' : ("TURBOPACK unreachable", undefined)) + result.join(("TURBOPACK compile-time truthy", 1) ? '<br/>' : ("TURBOPACK unreachable", undefined));
    }
    var data = seriesModel.getData();
    var value = seriesModel.getRawValue(dataIndex);
    var formattedValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(value) ? formatArrayValue(value) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].addCommas(value));
    var name = data.getName(dataIndex);
    var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isObject(color) && color.colorStops) {
        color = (color.colorStops[0] || {}).color;
    }
    color = color || 'transparent';
    var colorEl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].getTooltipMarker(color);
    var seriesName = seriesModel.name; // FIXME
    if (seriesName === '\0-') {
        // Not show '-'
        seriesName = '';
    }
    seriesName = seriesName ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';
    return !multipleSeries ? seriesName + colorEl + (name ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
}
;
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/createList.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/core/echarts.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
;
function __TURBOPACK__default__export__(seriesModel, dims, source) {
    source = source || seriesModel.getSource();
    var coordSysDimensions = dims || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCoordinateSystemDimensions"])(seriesModel.get('coordinateSystem')) || [
        'x',
        'y',
        'z'
    ];
    var dimensions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createDimensions(source, {
        dimensionsDefine: source.dimensionsDefine || seriesModel.get('dimensions'),
        encodeDefine: source.encodeDefine || seriesModel.get('encode'),
        coordDimensions: coordSysDimensions.map(function(dim) {
            var axis3DModel = seriesModel.getReferringComponents(dim + 'Axis3D').models[0];
            return {
                type: axis3DModel && axis3DModel.get('type') === 'category' ? 'ordinal' : 'float',
                name: dim // Find stackable dimension. Which will represent value.
            };
        })
    });
    if (seriesModel.get('coordinateSystem') === 'cartesian3D') {
        dimensions.forEach(function(dimInfo) {
            if (coordSysDimensions.indexOf(dimInfo.coordDim) >= 0) {
                var axis3DModel = seriesModel.getReferringComponents(dimInfo.coordDim + 'Axis3D').models[0];
                if (axis3DModel && axis3DModel.get('type') === 'category') {
                    dimInfo.ordinalMeta = axis3DModel.getOrdinalMeta();
                }
            }
        });
    }
    var stackCalculationInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].dataStack.enableDataStack(seriesModel, dimensions, {
        byIndex: true,
        stackedCoordDimension: 'z'
    });
    var data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"](dimensions, seriesModel);
    data.setCalculationInfo(stackCalculationInfo);
    data.initData(source);
    return data;
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/Bar3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/createList.js [app-client] (ecmascript)");
;
;
;
;
;
var Bar3DSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.bar3D',
    dependencies: [
        'globe'
    ],
    visualStyleAccessPathvisu: 'itemStyle',
    getInitialData: function(option, ecModel) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
    },
    getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
        var text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
        if (text == null) {
            text = this.getData().get('z', dataIndex);
        }
        return text;
    },
    formatTooltip: function(dataIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dataIndex);
    },
    defaultOption: {
        coordinateSystem: 'cartesian3D',
        globeIndex: 0,
        grid3DIndex: 0,
        zlevel: -10,
        // bevelSize, 0 has no bevel
        bevelSize: 0,
        // higher is smoother
        bevelSmoothness: 2,
        // Bar width and depth
        // barSize: [1, 1],
        // On grid plane when coordinateSystem is cartesian3D
        onGridPlane: 'xy',
        // Shading of globe
        shading: 'color',
        minHeight: 0,
        itemStyle: {
            opacity: 1
        },
        label: {
            show: false,
            distance: 2,
            textStyle: {
                fontSize: 14,
                color: '#000',
                backgroundColor: 'rgba(255,255,255,0.7)',
                padding: 3,
                borderRadius: 3
            }
        },
        emphasis: {
            label: {
                show: true
            }
        },
        animationDurationUpdate: 500
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Bar3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Bar3DSeries;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/Bars3DGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Geometry collecting bars data
 *
 * @module echarts-gl/chart/bars/BarsGeometry
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/trianglesSortMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var mat3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mat3;
/**
 * @constructor
 * @alias module:echarts-gl/chart/bars/BarsGeometry
 * @extends clay.Geometry
 */ var BarsGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 3, 'POSITION'),
            normal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('normal', 'float', 3, 'NORMAL'),
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('color', 'float', 4, 'COLOR'),
            prevPosition: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('prevPosition', 'float', 3),
            prevNormal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('prevNormal', 'float', 3)
        },
        dynamic: true,
        enableNormal: false,
        bevelSize: 1,
        bevelSegments: 0,
        // Map from vertexIndex to dataIndex.
        _dataIndices: null,
        _vertexOffset: 0,
        _triangleOffset: 0
    };
}, /** @lends module:echarts-gl/chart/bars/BarsGeometry.prototype */ {
    resetOffset: function() {
        this._vertexOffset = 0;
        this._triangleOffset = 0;
    },
    setBarCount: function(barCount) {
        var enableNormal = this.enableNormal;
        var vertexCount = this.getBarVertexCount() * barCount;
        var triangleCount = this.getBarTriangleCount() * barCount;
        if (this.vertexCount !== vertexCount) {
            this.attributes.position.init(vertexCount);
            if (enableNormal) {
                this.attributes.normal.init(vertexCount);
            } else {
                this.attributes.normal.value = null;
            }
            this.attributes.color.init(vertexCount);
        }
        if (this.triangleCount !== triangleCount) {
            this.indices = vertexCount > 0xffff ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
            this._dataIndices = new Uint32Array(vertexCount);
        }
    },
    getBarVertexCount: function() {
        var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
        return bevelSegments > 0 ? this._getBevelBarVertexCount(bevelSegments) : this.enableNormal ? 24 : 8;
    },
    getBarTriangleCount: function() {
        var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
        return bevelSegments > 0 ? this._getBevelBarTriangleCount(bevelSegments) : 12;
    },
    _getBevelBarVertexCount: function(bevelSegments) {
        return (bevelSegments + 1) * 4 * (bevelSegments + 1) * 2;
    },
    _getBevelBarTriangleCount: function(bevelSegments) {
        var widthSegments = bevelSegments * 4 + 3;
        var heightSegments = bevelSegments * 2 + 1;
        return (widthSegments + 1) * heightSegments * 2 + 4;
    },
    setColor: function(idx, color) {
        var vertexCount = this.getBarVertexCount();
        var start = vertexCount * idx;
        var end = vertexCount * (idx + 1);
        for(var i = start; i < end; i++){
            this.attributes.color.set(i, color);
        }
        this.dirtyAttribute('color');
    },
    /**
   * Get dataIndex of vertex.
   * @param {number} vertexIndex
   */ getDataIndexOfVertex: function(vertexIndex) {
        return this._dataIndices ? this._dataIndices[vertexIndex] : null;
    },
    /**
   * Add a bar
   * @param {Array.<number>} start
   * @param {Array.<number>} end
   * @param {Array.<number>} orient  right direction
   * @param {Array.<number>} size size on x and z
   * @param {Array.<number>} color
   */ addBar: function() {
        var v3Create = vec3.create;
        var v3ScaleAndAdd = vec3.scaleAndAdd;
        var end = v3Create();
        var px = v3Create();
        var py = v3Create();
        var pz = v3Create();
        var nx = v3Create();
        var ny = v3Create();
        var nz = v3Create();
        var pts = [];
        var normals = [];
        for(var i = 0; i < 8; i++){
            pts[i] = v3Create();
        }
        var cubeFaces4 = [
            [
                0,
                1,
                5,
                4
            ],
            [
                2,
                3,
                7,
                6
            ],
            [
                4,
                5,
                6,
                7
            ],
            [
                3,
                2,
                1,
                0
            ],
            [
                0,
                4,
                7,
                3
            ],
            [
                1,
                2,
                6,
                5
            ]
        ];
        var face4To3 = [
            0,
            1,
            2,
            0,
            2,
            3
        ];
        var cubeFaces3 = [];
        for(var i = 0; i < cubeFaces4.length; i++){
            var face4 = cubeFaces4[i];
            for(var j = 0; j < 2; j++){
                var face = [];
                for(var k = 0; k < 3; k++){
                    face.push(face4[face4To3[j * 3 + k]]);
                }
                cubeFaces3.push(face);
            }
        }
        return function(start, dir, leftDir, size, color, dataIndex) {
            // Use vertex, triangle maybe sorted.
            var startVertex = this._vertexOffset;
            if (this.bevelSize > 0 && this.bevelSegments > 0) {
                this._addBevelBar(start, dir, leftDir, size, this.bevelSize, this.bevelSegments, color);
            } else {
                vec3.copy(py, dir);
                vec3.normalize(py, py); // x * y => z
                vec3.cross(pz, leftDir, py);
                vec3.normalize(pz, pz); // y * z => x
                vec3.cross(px, py, pz);
                vec3.normalize(pz, pz);
                vec3.negate(nx, px);
                vec3.negate(ny, py);
                vec3.negate(nz, pz);
                v3ScaleAndAdd(pts[0], start, px, size[0] / 2);
                v3ScaleAndAdd(pts[0], pts[0], pz, size[2] / 2);
                v3ScaleAndAdd(pts[1], start, px, size[0] / 2);
                v3ScaleAndAdd(pts[1], pts[1], nz, size[2] / 2);
                v3ScaleAndAdd(pts[2], start, nx, size[0] / 2);
                v3ScaleAndAdd(pts[2], pts[2], nz, size[2] / 2);
                v3ScaleAndAdd(pts[3], start, nx, size[0] / 2);
                v3ScaleAndAdd(pts[3], pts[3], pz, size[2] / 2);
                v3ScaleAndAdd(end, start, py, size[1]);
                v3ScaleAndAdd(pts[4], end, px, size[0] / 2);
                v3ScaleAndAdd(pts[4], pts[4], pz, size[2] / 2);
                v3ScaleAndAdd(pts[5], end, px, size[0] / 2);
                v3ScaleAndAdd(pts[5], pts[5], nz, size[2] / 2);
                v3ScaleAndAdd(pts[6], end, nx, size[0] / 2);
                v3ScaleAndAdd(pts[6], pts[6], nz, size[2] / 2);
                v3ScaleAndAdd(pts[7], end, nx, size[0] / 2);
                v3ScaleAndAdd(pts[7], pts[7], pz, size[2] / 2);
                var attributes = this.attributes;
                if (this.enableNormal) {
                    normals[0] = px;
                    normals[1] = nx;
                    normals[2] = py;
                    normals[3] = ny;
                    normals[4] = pz;
                    normals[5] = nz;
                    var vertexOffset = this._vertexOffset;
                    for(var i = 0; i < cubeFaces4.length; i++){
                        var idx3 = this._triangleOffset * 3;
                        for(var k = 0; k < 6; k++){
                            this.indices[idx3++] = vertexOffset + face4To3[k];
                        }
                        vertexOffset += 4;
                        this._triangleOffset += 2;
                    }
                    for(var i = 0; i < cubeFaces4.length; i++){
                        var normal = normals[i];
                        for(var k = 0; k < 4; k++){
                            var idx = cubeFaces4[i][k];
                            attributes.position.set(this._vertexOffset, pts[idx]);
                            attributes.normal.set(this._vertexOffset, normal);
                            attributes.color.set(this._vertexOffset++, color);
                        }
                    }
                } else {
                    for(var i = 0; i < cubeFaces3.length; i++){
                        var idx3 = this._triangleOffset * 3;
                        for(var k = 0; k < 3; k++){
                            this.indices[idx3 + k] = cubeFaces3[i][k] + this._vertexOffset;
                        }
                        this._triangleOffset++;
                    }
                    for(var i = 0; i < pts.length; i++){
                        attributes.position.set(this._vertexOffset, pts[i]);
                        attributes.color.set(this._vertexOffset++, color);
                    }
                }
            }
            var endVerex = this._vertexOffset;
            for(var i = startVertex; i < endVerex; i++){
                this._dataIndices[i] = dataIndex;
            }
        };
    }(),
    /**
   * Add a bar with bevel
   * @param {Array.<number>} start
   * @param {Array.<number>} end
   * @param {Array.<number>} orient  right direction
   * @param {Array.<number>} size size on x and z
   * @param {number} bevelSize
   * @param {number} bevelSegments
   * @param {Array.<number>} color
   */ _addBevelBar: function() {
        var px = vec3.create();
        var py = vec3.create();
        var pz = vec3.create();
        var rotateMat = mat3.create();
        var bevelStartSize = [];
        var xOffsets = [
            1,
            -1,
            -1,
            1
        ];
        var zOffsets = [
            1,
            1,
            -1,
            -1
        ];
        var yOffsets = [
            2,
            0
        ];
        return function(start, dir, leftDir, size, bevelSize, bevelSegments, color) {
            vec3.copy(py, dir);
            vec3.normalize(py, py); // x * y => z
            vec3.cross(pz, leftDir, py);
            vec3.normalize(pz, pz); // y * z => x
            vec3.cross(px, py, pz);
            vec3.normalize(pz, pz);
            rotateMat[0] = px[0];
            rotateMat[1] = px[1];
            rotateMat[2] = px[2];
            rotateMat[3] = py[0];
            rotateMat[4] = py[1];
            rotateMat[5] = py[2];
            rotateMat[6] = pz[0];
            rotateMat[7] = pz[1];
            rotateMat[8] = pz[2];
            bevelSize = Math.min(size[0], size[2]) / 2 * bevelSize;
            for(var i = 0; i < 3; i++){
                bevelStartSize[i] = Math.max(size[i] - bevelSize * 2, 0);
            }
            var rx = (size[0] - bevelStartSize[0]) / 2;
            var ry = (size[1] - bevelStartSize[1]) / 2;
            var rz = (size[2] - bevelStartSize[2]) / 2;
            var pos = [];
            var normal = [];
            var vertexOffset = this._vertexOffset;
            var endIndices = [];
            for(var i = 0; i < 2; i++){
                endIndices[i] = endIndices[i] = [];
                for(var m = 0; m <= bevelSegments; m++){
                    for(var j = 0; j < 4; j++){
                        if (m === 0 && i === 0 || i === 1 && m === bevelSegments) {
                            endIndices[i].push(vertexOffset);
                        }
                        for(var n = 0; n <= bevelSegments; n++){
                            var phi = n / bevelSegments * Math.PI / 2 + Math.PI / 2 * j;
                            var theta = m / bevelSegments * Math.PI / 2 + Math.PI / 2 * i; // var r = rx < ry ? (rz < rx ? rz : rx) : (rz < ry ? rz : ry);
                            normal[0] = rx * Math.cos(phi) * Math.sin(theta);
                            normal[1] = ry * Math.cos(theta);
                            normal[2] = rz * Math.sin(phi) * Math.sin(theta);
                            pos[0] = normal[0] + xOffsets[j] * bevelStartSize[0] / 2;
                            pos[1] = normal[1] + ry + yOffsets[i] * bevelStartSize[1] / 2;
                            pos[2] = normal[2] + zOffsets[j] * bevelStartSize[2] / 2; // Normal is not right if rx, ry, rz not equal.
                            if (!(Math.abs(rx - ry) < 1e-6 && Math.abs(ry - rz) < 1e-6)) {
                                normal[0] /= rx * rx;
                                normal[1] /= ry * ry;
                                normal[2] /= rz * rz;
                            }
                            vec3.normalize(normal, normal);
                            vec3.transformMat3(pos, pos, rotateMat);
                            vec3.transformMat3(normal, normal, rotateMat);
                            vec3.add(pos, pos, start);
                            this.attributes.position.set(vertexOffset, pos);
                            if (this.enableNormal) {
                                this.attributes.normal.set(vertexOffset, normal);
                            }
                            this.attributes.color.set(vertexOffset, color);
                            vertexOffset++;
                        }
                    }
                }
            }
            var widthSegments = bevelSegments * 4 + 3;
            var heightSegments = bevelSegments * 2 + 1;
            var len = widthSegments + 1;
            for(var j = 0; j < heightSegments; j++){
                for(var i = 0; i <= widthSegments; i++){
                    var i2 = j * len + i + this._vertexOffset;
                    var i1 = j * len + (i + 1) % len + this._vertexOffset;
                    var i4 = (j + 1) * len + (i + 1) % len + this._vertexOffset;
                    var i3 = (j + 1) * len + i + this._vertexOffset;
                    this.setTriangleIndices(this._triangleOffset++, [
                        i4,
                        i2,
                        i1
                    ]);
                    this.setTriangleIndices(this._triangleOffset++, [
                        i4,
                        i3,
                        i2
                    ]);
                }
            } // Close top and bottom
            this.setTriangleIndices(this._triangleOffset++, [
                endIndices[0][0],
                endIndices[0][2],
                endIndices[0][1]
            ]);
            this.setTriangleIndices(this._triangleOffset++, [
                endIndices[0][0],
                endIndices[0][3],
                endIndices[0][2]
            ]);
            this.setTriangleIndices(this._triangleOffset++, [
                endIndices[1][0],
                endIndices[1][1],
                endIndices[1][2]
            ]);
            this.setTriangleIndices(this._triangleOffset++, [
                endIndices[1][0],
                endIndices[1][2],
                endIndices[1][3]
            ]);
            this._vertexOffset = vertexOffset;
        };
    }()
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(BarsGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(BarsGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = BarsGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/Bar3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/tool/color.js [app-client] (ecmascript) <export * as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Bars3DGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Bars3DGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/LabelsBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'bar3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._api = api;
        this._labelsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](256, 256, api);
        var self = this;
        this._labelsBuilder.getLabelPosition = function(dataIndex, position, distance) {
            if (self._data) {
                var layout = self._data.getItemLayout(dataIndex);
                var start = layout[0];
                var dir = layout[1];
                var height = layout[2][1];
                return vec3.scaleAndAdd([], start, dir, distance + height);
            } else {
                return [
                    0,
                    0
                ];
            }
        }; // Give a large render order.
        this._labelsBuilder.getMesh().renderOrder = 100;
    },
    render: function(seriesModel, ecModel, api) {
        // Swap barMesh
        var tmp = this._prevBarMesh;
        this._prevBarMesh = this._barMesh;
        this._barMesh = tmp;
        if (!this._barMesh) {
            this._barMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
                geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Bars3DGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
                shadowDepthMaterial: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                    shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.sm.depth.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.sm.depth.fragment'))
                }),
                // Only cartesian3D enable culling
                // FIXME Performance
                culling: seriesModel.coordinateSystem.type === 'cartesian3D',
                // Render after axes
                renderOrder: 10,
                // Render normal in normal pass
                renderNormal: true
            });
        }
        this.groupGL.remove(this._prevBarMesh);
        this.groupGL.add(this._barMesh);
        this.groupGL.add(this._labelsBuilder.getMesh());
        var coordSys = seriesModel.coordinateSystem;
        this._doRender(seriesModel, api);
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
            var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
            this._barMesh.material[methodName]('fragment', 'SRGB_DECODE');
        }
        this._data = seriesModel.getData();
        this._labelsBuilder.updateData(this._data);
        this._labelsBuilder.updateLabels();
        this._updateAnimation(seriesModel);
    },
    _updateAnimation: function(seriesModel) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].updateVertexAnimation([
            [
                'prevPosition',
                'position'
            ],
            [
                'prevNormal',
                'normal'
            ]
        ], this._prevBarMesh, this._barMesh, seriesModel);
    },
    _doRender: function(seriesModel, api) {
        var data = seriesModel.getData();
        var shading = seriesModel.get('shading');
        var enableNormal = shading !== 'color';
        var self = this;
        var barMesh = this._barMesh;
        var shadingPrefix = 'ecgl.' + shading;
        if (!barMesh.material || barMesh.material.shader.name !== shadingPrefix) {
            barMesh.material = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createMaterial(shadingPrefix, [
                'VERTEX_COLOR'
            ]);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setMaterialFromModel(shading, barMesh.material, seriesModel, api);
        barMesh.geometry.enableNormal = enableNormal;
        barMesh.geometry.resetOffset(); // Bevel settings
        var bevelSize = seriesModel.get('bevelSize');
        var bevelSegments = seriesModel.get('bevelSmoothness');
        barMesh.geometry.bevelSegments = bevelSegments;
        barMesh.geometry.bevelSize = bevelSize;
        var colorArr = [];
        var vertexColors = new Float32Array(data.count() * 4);
        var colorOffset = 0;
        var barCount = 0;
        var hasTransparent = false;
        data.each(function(idx) {
            if (!data.hasValue(idx)) {
                return;
            }
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, idx);
            var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, idx);
            if (opacity == null) {
                opacity = 1;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color, colorArr);
            colorArr[3] *= opacity;
            vertexColors[colorOffset++] = colorArr[0];
            vertexColors[colorOffset++] = colorArr[1];
            vertexColors[colorOffset++] = colorArr[2];
            vertexColors[colorOffset++] = colorArr[3];
            if (colorArr[3] > 0) {
                barCount++;
                if (colorArr[3] < 0.99) {
                    hasTransparent = true;
                }
            }
        });
        barMesh.geometry.setBarCount(barCount);
        var orient = data.getLayout('orient'); // Map of dataIndex and barIndex.
        var barIndexOfData = this._barIndexOfData = new Int32Array(data.count());
        var barCount = 0;
        data.each(function(idx) {
            if (!data.hasValue(idx)) {
                barIndexOfData[idx] = -1;
                return;
            }
            var layout = data.getItemLayout(idx);
            var start = layout[0];
            var dir = layout[1];
            var size = layout[2];
            var idx4 = idx * 4;
            colorArr[0] = vertexColors[idx4++];
            colorArr[1] = vertexColors[idx4++];
            colorArr[2] = vertexColors[idx4++];
            colorArr[3] = vertexColors[idx4++];
            if (colorArr[3] > 0) {
                self._barMesh.geometry.addBar(start, dir, orient, size, colorArr, idx);
                barIndexOfData[idx] = barCount++;
            }
        });
        barMesh.geometry.dirty();
        barMesh.geometry.updateBoundingBox();
        var material = barMesh.material;
        material.transparent = hasTransparent;
        material.depthMask = !hasTransparent;
        barMesh.geometry.sortTriangles = hasTransparent;
        this._initHandler(seriesModel, api);
    },
    _initHandler: function(seriesModel, api) {
        var data = seriesModel.getData();
        var barMesh = this._barMesh;
        var isCartesian3D = seriesModel.coordinateSystem.type === 'cartesian3D';
        barMesh.seriesIndex = seriesModel.seriesIndex;
        var lastDataIndex = -1;
        barMesh.off('mousemove');
        barMesh.off('mouseout');
        barMesh.on('mousemove', function(e) {
            var dataIndex = barMesh.geometry.getDataIndexOfVertex(e.triangle[0]);
            if (dataIndex !== lastDataIndex) {
                this._downplay(lastDataIndex);
                this._highlight(dataIndex);
                this._labelsBuilder.updateLabels([
                    dataIndex
                ]);
                if (isCartesian3D) {
                    api.dispatchAction({
                        type: 'grid3DShowAxisPointer',
                        value: [
                            data.get('x', dataIndex),
                            data.get('y', dataIndex),
                            data.get('z', dataIndex, true)
                        ]
                    });
                }
            }
            lastDataIndex = dataIndex;
            barMesh.dataIndex = dataIndex;
        }, this);
        barMesh.on('mouseout', function(e) {
            this._downplay(lastDataIndex);
            this._labelsBuilder.updateLabels();
            lastDataIndex = -1;
            barMesh.dataIndex = -1;
            if (isCartesian3D) {
                api.dispatchAction({
                    type: 'grid3DHideAxisPointer'
                });
            }
        }, this);
    },
    _highlight: function(dataIndex) {
        var data = this._data;
        if (!data) {
            return;
        }
        var barIndex = this._barIndexOfData[dataIndex];
        if (barIndex < 0) {
            return;
        }
        var itemModel = data.getItemModel(dataIndex);
        var emphasisItemStyleModel = itemModel.getModel('emphasis.itemStyle');
        var emphasisColor = emphasisItemStyleModel.get('color');
        var emphasisOpacity = emphasisItemStyleModel.get('opacity');
        if (emphasisColor == null) {
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
            emphasisColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__["color"].lift(color, -0.4);
        }
        if (emphasisOpacity == null) {
            emphasisOpacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex);
        }
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(emphasisColor);
        colorArr[3] *= emphasisOpacity;
        this._barMesh.geometry.setColor(barIndex, colorArr);
        this._api.getZr().refresh();
    },
    _downplay: function(dataIndex) {
        var data = this._data;
        if (!data) {
            return;
        }
        var barIndex = this._barIndexOfData[dataIndex];
        if (barIndex < 0) {
            return;
        }
        var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
        var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex);
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
        colorArr[3] *= opacity;
        this._barMesh.geometry.setColor(barIndex, colorArr);
        this._api.getZr().refresh();
    },
    highlight: function(seriesModel, ecModel, api, payload) {
        this._toggleStatus('highlight', seriesModel, ecModel, api, payload);
    },
    downplay: function(seriesModel, ecModel, api, payload) {
        this._toggleStatus('downplay', seriesModel, ecModel, api, payload);
    },
    _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].queryDataIndex(data, payload);
        var self = this;
        if (dataIndex != null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalizeToArray(dataIndex), function(dataIdx) {
                status === 'highlight' ? this._highlight(dataIdx) : this._downplay(dataIdx);
            }, this);
        } else {
            data.each(function(dataIdx) {
                status === 'highlight' ? self._highlight(dataIdx) : self._downplay(dataIdx);
            });
        }
    },
    remove: function() {
        this.groupGL.removeAll();
    },
    dispose: function() {
        this._labelsBuilder.dispose();
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$bar3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/bar3DLayout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$Bar3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/Bar3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$Bar3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/Bar3DView.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$Bar3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$Bar3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$bar3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(registers);
    registers.registerProcessor(function(ecModel, api) {
        ecModel.eachSeriesByType('bar3d', function(seriesModel) {
            var data = seriesModel.getData();
            data.filterSelf(function(idx) {
                return data.hasValue(idx);
            });
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/bar3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/line3D/Line3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/createList.js [app-client] (ecmascript)");
;
;
;
var Line3DSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.line3D',
    dependencies: [
        'grid3D'
    ],
    visualStyleAccessPath: 'lineStyle',
    visualDrawType: 'stroke',
    getInitialData: function(option, ecModel) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
    },
    formatTooltip: function(dataIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dataIndex);
    },
    defaultOption: {
        coordinateSystem: 'cartesian3D',
        zlevel: -10,
        // Cartesian coordinate system
        grid3DIndex: 0,
        lineStyle: {
            width: 2
        },
        animationDurationUpdate: 500
    }
});
const __TURBOPACK__default__export__ = Line3DSeries;
}}),
"[project]/node_modules/echarts-gl/lib/chart/line3D/Line3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Vector3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$contain$2f$line$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/contain/line.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lines3D.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'line3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._api = api;
    },
    render: function(seriesModel, ecModel, api) {
        var tmp = this._prevLine3DMesh;
        this._prevLine3DMesh = this._line3DMesh;
        this._line3DMesh = tmp;
        if (!this._line3DMesh) {
            this._line3DMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
                geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    useNativeLine: false,
                    sortTriangles: true
                }),
                material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                    shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines3D')
                }),
                // Render after axes
                renderOrder: 10
            });
            this._line3DMesh.geometry.pick = this._pick.bind(this);
        }
        this.groupGL.remove(this._prevLine3DMesh);
        this.groupGL.add(this._line3DMesh);
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL); // TODO
            var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
            this._line3DMesh.material[methodName]('fragment', 'SRGB_DECODE');
        }
        this._doRender(seriesModel, api);
        this._data = seriesModel.getData();
        this._camera = coordSys.viewGL.camera;
        this.updateCamera();
        this._updateAnimation(seriesModel);
    },
    updateCamera: function() {
        this._updateNDCPosition();
    },
    _doRender: function(seriesModel, api) {
        var data = seriesModel.getData();
        var lineMesh = this._line3DMesh;
        lineMesh.geometry.resetOffset();
        var points = data.getLayout('points');
        var colorArr = [];
        var vertexColors = new Float32Array(points.length / 3 * 4);
        var colorOffset = 0;
        var hasTransparent = false;
        data.each(function(idx) {
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, idx);
            var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, idx);
            if (opacity == null) {
                opacity = 1;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color, colorArr);
            colorArr[3] *= opacity;
            vertexColors[colorOffset++] = colorArr[0];
            vertexColors[colorOffset++] = colorArr[1];
            vertexColors[colorOffset++] = colorArr[2];
            vertexColors[colorOffset++] = colorArr[3];
            if (colorArr[3] < 0.99) {
                hasTransparent = true;
            }
        });
        lineMesh.geometry.setVertexCount(lineMesh.geometry.getPolylineVertexCount(points));
        lineMesh.geometry.setTriangleCount(lineMesh.geometry.getPolylineTriangleCount(points));
        lineMesh.geometry.addPolyline(points, vertexColors, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('lineStyle.width'), 1));
        lineMesh.geometry.dirty();
        lineMesh.geometry.updateBoundingBox();
        var material = lineMesh.material;
        material.transparent = hasTransparent;
        material.depthMask = !hasTransparent;
        var debugWireframeModel = seriesModel.getModel('debug.wireframe');
        if (debugWireframeModel.get('show')) {
            lineMesh.geometry.createAttribute('barycentric', 'float', 3);
            lineMesh.geometry.generateBarycentric();
            lineMesh.material.set('both', 'WIREFRAME_TRIANGLE');
            lineMesh.material.set('wireframeLineColor', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(debugWireframeModel.get('lineStyle.color') || 'rgba(0,0,0,0.5)'));
            lineMesh.material.set('wireframeLineWidth', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(debugWireframeModel.get('lineStyle.width'), 1));
        } else {
            lineMesh.material.set('both', 'WIREFRAME_TRIANGLE');
        }
        this._points = points;
        this._initHandler(seriesModel, api);
    },
    _updateAnimation: function(seriesModel) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].updateVertexAnimation([
            [
                'prevPosition',
                'position'
            ],
            [
                'prevPositionPrev',
                'positionPrev'
            ],
            [
                'prevPositionNext',
                'positionNext'
            ]
        ], this._prevLine3DMesh, this._line3DMesh, seriesModel);
    },
    _initHandler: function(seriesModel, api) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var lineMesh = this._line3DMesh;
        var lastDataIndex = -1;
        lineMesh.seriesIndex = seriesModel.seriesIndex;
        lineMesh.off('mousemove');
        lineMesh.off('mouseout');
        lineMesh.on('mousemove', function(e) {
            var value = coordSys.pointToData(e.point.array);
            var dataIndex = data.indicesOfNearest('x', value[0])[0];
            if (dataIndex !== lastDataIndex) {
                // this._downplay(lastDataIndex);
                // this._highlight(dataIndex);
                api.dispatchAction({
                    type: 'grid3DShowAxisPointer',
                    value: [
                        data.get('x', dataIndex),
                        data.get('y', dataIndex),
                        data.get('z', dataIndex)
                    ]
                });
                lineMesh.dataIndex = dataIndex;
            }
            lastDataIndex = dataIndex;
        }, this);
        lineMesh.on('mouseout', function(e) {
            // this._downplay(lastDataIndex);
            lastDataIndex = -1;
            lineMesh.dataIndex = -1;
            api.dispatchAction({
                type: 'grid3DHideAxisPointer'
            });
        }, this);
    },
    // _highlight: function (dataIndex) {
    //     var data = this._data;
    //     if (!data) {
    //         return;
    //     }
    // },
    // _downplay: function (dataIndex) {
    //     var data = this._data;
    //     if (!data) {
    //         return;
    //     }
    // },
    _updateNDCPosition: function() {
        var worldViewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var camera = this._camera;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].multiply(worldViewProjection, camera.projectionMatrix, camera.viewMatrix);
        var positionNDC = this._positionNDC;
        var points = this._points;
        var nPoints = points.length / 3;
        if (!positionNDC || positionNDC.length / 2 !== nPoints) {
            positionNDC = this._positionNDC = new Float32Array(nPoints * 2);
        }
        var pos = [];
        for(var i = 0; i < nPoints; i++){
            var i3 = i * 3;
            var i2 = i * 2;
            pos[0] = points[i3];
            pos[1] = points[i3 + 1];
            pos[2] = points[i3 + 2];
            pos[3] = 1;
            vec3.transformMat4(pos, pos, worldViewProjection.array);
            positionNDC[i2] = pos[0] / pos[3];
            positionNDC[i2 + 1] = pos[1] / pos[3];
        }
    },
    _pick: function(x, y, renderer, camera, renderable, out) {
        var positionNDC = this._positionNDC;
        var seriesModel = this._data.hostModel;
        var lineWidth = seriesModel.get('lineStyle.width');
        var dataIndex = -1;
        var width = renderer.viewport.width;
        var height = renderer.viewport.height;
        var halfWidth = width * 0.5;
        var halfHeight = height * 0.5;
        x = (x + 1) * halfWidth;
        y = (y + 1) * halfHeight;
        for(var i = 1; i < positionNDC.length / 2; i++){
            var x0 = (positionNDC[(i - 1) * 2] + 1) * halfWidth;
            var y0 = (positionNDC[(i - 1) * 2 + 1] + 1) * halfHeight;
            var x1 = (positionNDC[i * 2] + 1) * halfWidth;
            var y1 = (positionNDC[i * 2 + 1] + 1) * halfHeight;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$contain$2f$line$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containStroke"])(x0, y0, x1, y1, lineWidth, x, y)) {
                var dist0 = (x0 - x) * (x0 - x) + (y0 - y) * (y0 - y);
                var dist1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y); // Nearest point.
                dataIndex = dist0 < dist1 ? i - 1 : i;
            }
        }
        if (dataIndex >= 0) {
            var i3 = dataIndex * 3;
            var point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Vector3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this._points[i3], this._points[i3 + 1], this._points[i3 + 2]);
            out.push({
                dataIndex: dataIndex,
                point: point,
                pointWorld: point.clone(),
                target: this._line3DMesh,
                distance: this._camera.getWorldPosition().dist(point)
            });
        }
    },
    remove: function() {
        this.groupGL.removeAll();
    },
    dispose: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/line3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$Line3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/line3D/Line3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$Line3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/line3D/Line3DView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$Line3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$Line3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerLayout(function(ecModel, api) {
        ecModel.eachSeriesByType('line3D', function(seriesModel) {
            var data = seriesModel.getData();
            var coordSys = seriesModel.coordinateSystem;
            if (coordSys) {
                if (coordSys.type !== 'cartesian3D') {
                    if ("TURBOPACK compile-time truthy", 1) {
                        console.error('line3D needs cartesian3D coordinateSystem');
                    }
                    return;
                }
                var points = new Float32Array(data.count() * 3);
                var item = [];
                var out = [];
                var coordDims = coordSys.dimensions;
                var dims = coordDims.map(function(coordDim) {
                    return seriesModel.coordDimToDataDim(coordDim)[0];
                });
                if (coordSys) {
                    data.each(dims, function(x, y, z, idx) {
                        item[0] = x;
                        item[1] = y;
                        item[2] = z;
                        coordSys.dataToPoint(item, out);
                        points[idx * 3] = out[0];
                        points[idx * 3 + 1] = out[1];
                        points[idx * 3 + 2] = out[2];
                    });
                }
                data.setLayout('points', points);
            }
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/line3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/line3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/createList.js [app-client] (ecmascript)");
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.scatter3D',
    dependencies: [
        'globe',
        'grid3D',
        'geo3D'
    ],
    visualStyleAccessPath: 'itemStyle',
    hasSymbolVisual: true,
    getInitialData: function(option, ecModel) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this);
    },
    getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
        var text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
        if (text == null) {
            var data = this.getData();
            var lastDim = data.dimensions[data.dimensions.length - 1];
            text = data.get(lastDim, dataIndex);
        }
        return text;
    },
    formatTooltip: function(dataIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dataIndex);
    },
    defaultOption: {
        coordinateSystem: 'cartesian3D',
        zlevel: -10,
        progressive: 1e5,
        progressiveThreshold: 1e5,
        // Cartesian coordinate system
        grid3DIndex: 0,
        globeIndex: 0,
        symbol: 'circle',
        symbolSize: 10,
        // Support source-over, lighter
        blendMode: 'source-over',
        label: {
            show: false,
            position: 'right',
            // Screen space distance
            distance: 5,
            textStyle: {
                fontSize: 14,
                color: '#000',
                backgroundColor: 'rgba(255,255,255,0.7)',
                padding: 3,
                borderRadius: 3
            }
        },
        itemStyle: {
            opacity: 0.8
        },
        emphasis: {
            label: {
                show: true
            }
        },
        animationDurationUpdate: 500
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/util/sprite.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$canvas$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__brushSingle__as__innerDrawElementOnCanvas$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/canvas/graphic.js [app-client] (ecmascript) <export brushSingle as innerDrawElementOnCanvas>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
;
function makeSprite(size, canvas, draw) {
    // http://simonsarris.com/blog/346-how-you-clear-your-canvas-matters
    // http://jsperf.com/canvasclear
    // Set width and height is fast
    // And use the exist canvas if possible
    // http://jsperf.com/create-canvas-vs-set-width-height/2
    var canvas = canvas || document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext('2d');
    draw && draw(ctx);
    return canvas;
}
function makePath(symbol, symbolSize, style, marginBias) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].isArray(symbolSize)) {
        symbolSize = [
            symbolSize,
            symbolSize
        ];
    }
    var margin = spriteUtil.getMarginByStyle(style, marginBias);
    var width = symbolSize[0] + margin.left + margin.right;
    var height = symbolSize[1] + margin.top + margin.bottom;
    var path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createSymbol(symbol, 0, 0, symbolSize[0], symbolSize[1]);
    var size = Math.max(width, height);
    path.x = margin.left;
    path.y = margin.top;
    if (width > height) {
        path.y += (size - height) / 2;
    } else {
        path.x += (size - width) / 2;
    }
    var rect = path.getBoundingRect();
    path.x -= rect.x;
    path.y -= rect.y;
    path.setStyle(style);
    path.update();
    path.__size = size;
    return path;
} // http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf
function generateSDF(ctx, sourceImageData, range) {
    var sourceWidth = sourceImageData.width;
    var sourceHeight = sourceImageData.height;
    var width = ctx.canvas.width;
    var height = ctx.canvas.height;
    var scaleX = sourceWidth / width;
    var scaleY = sourceHeight / height;
    function sign(r) {
        return r < 128 ? 1 : -1;
    }
    function searchMinDistance(x, y) {
        var minDistSqr = Infinity;
        x = Math.floor(x * scaleX);
        y = Math.floor(y * scaleY);
        var i = y * sourceWidth + x;
        var r = sourceImageData.data[i * 4];
        var a = sign(r); // Search for min distance
        for(var y2 = Math.max(y - range, 0); y2 < Math.min(y + range, sourceHeight); y2++){
            for(var x2 = Math.max(x - range, 0); x2 < Math.min(x + range, sourceWidth); x2++){
                var i = y2 * sourceWidth + x2;
                var r2 = sourceImageData.data[i * 4];
                var b = sign(r2);
                var dx = x2 - x;
                var dy = y2 - y;
                if (a !== b) {
                    var distSqr = dx * dx + dy * dy;
                    if (distSqr < minDistSqr) {
                        minDistSqr = distSqr;
                    }
                }
            }
        }
        return a * Math.sqrt(minDistSqr);
    }
    var sdfImageData = ctx.createImageData(width, height);
    for(var y = 0; y < height; y++){
        for(var x = 0; x < width; x++){
            var dist = searchMinDistance(x, y);
            var normalized = dist / range * 0.5 + 0.5;
            var i = (y * width + x) * 4;
            sdfImageData.data[i++] = (1.0 - normalized) * 255;
            sdfImageData.data[i++] = (1.0 - normalized) * 255;
            sdfImageData.data[i++] = (1.0 - normalized) * 255;
            sdfImageData.data[i++] = 255;
        }
    }
    return sdfImageData;
}
var spriteUtil = {
    getMarginByStyle: function(style) {
        var minMargin = style.minMargin || 0;
        var lineWidth = 0;
        if (style.stroke && style.stroke !== 'none') {
            lineWidth = style.lineWidth == null ? 1 : style.lineWidth;
        }
        var shadowBlurSize = style.shadowBlur || 0;
        var shadowOffsetX = style.shadowOffsetX || 0;
        var shadowOffsetY = style.shadowOffsetY || 0;
        var margin = {};
        margin.left = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize, minMargin);
        margin.right = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize, minMargin);
        margin.top = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize, minMargin);
        margin.bottom = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize, minMargin);
        return margin;
    },
    // TODO Not consider shadowOffsetX, shadowOffsetY.
    /**
   * @param {string} symbol
   * @param {number | Array.<number>} symbolSize
   * @param {Object} style
   */ createSymbolSprite: function(symbol, symbolSize, style, canvas) {
        var path = makePath(symbol, symbolSize, style);
        var margin = spriteUtil.getMarginByStyle(style);
        return {
            image: makeSprite(path.__size, canvas, function(ctx) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$canvas$2f$graphic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__brushSingle__as__innerDrawElementOnCanvas$3e$__["innerDrawElementOnCanvas"])(ctx, path);
            }),
            margin: margin
        };
    },
    createSDFFromCanvas: function(canvas, size, range, outCanvas) {
        // TODO Create a low resolution SDF from high resolution image.
        return makeSprite(size, outCanvas, function(outCtx) {
            var ctx = canvas.getContext('2d');
            var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            outCtx.putImageData(generateSDF(outCtx, imgData, range), 0, 0);
        });
    },
    createSimpleSprite: function(size, canvas) {
        return makeSprite(size, canvas, function(ctx) {
            var halfSize = size / 2;
            ctx.beginPath();
            ctx.arc(halfSize, halfSize, 60, 0, Math.PI * 2, false);
            ctx.closePath();
            var gradient = ctx.createRadialGradient(halfSize, halfSize, 0, halfSize, halfSize, halfSize);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fill();
        });
    }
};
const __TURBOPACK__default__export__ = spriteUtil;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/verticesSortMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/ProgressiveQuickSort.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
const __TURBOPACK__default__export__ = {
    needsSortVertices: function() {
        return this.sortVertices;
    },
    needsSortVerticesProgressively: function() {
        return this.needsSortVertices() && this.vertexCount >= 2e4;
    },
    doSortVertices: function(cameraPos, frame) {
        var indices = this.indices;
        var p = vec3.create();
        if (!indices) {
            indices = this.indices = this.vertexCount > 0xffff ? new Uint32Array(this.vertexCount) : new Uint16Array(this.vertexCount);
            for(var i = 0; i < indices.length; i++){
                indices[i] = i;
            }
        } // Do progressive quick sort.
        if (frame === 0) {
            var posAttr = this.attributes.position;
            var cameraPos = cameraPos.array;
            var noneCount = 0;
            if (!this._zList || this._zList.length !== this.vertexCount) {
                this._zList = new Float32Array(this.vertexCount);
            }
            var firstZ;
            for(var i = 0; i < this.vertexCount; i++){
                posAttr.get(i, p); // Camera position is in object space
                var z = vec3.sqrDist(p, cameraPos);
                if (isNaN(z)) {
                    // Put far away, NaN value may cause sort slow
                    z = 1e7;
                    noneCount++;
                }
                if (i === 0) {
                    firstZ = z;
                    z = 0;
                } else {
                    // Only store the difference to avoid the precision issue.
                    z = z - firstZ;
                }
                this._zList[i] = z;
            }
            this._noneCount = noneCount;
        }
        if (this.vertexCount < 2e4) {
            // Use simple native sort for simple geometries.
            if (frame === 0) {
                this._simpleSort(this._noneCount / this.vertexCount > 0.05);
            }
        } else {
            for(var i = 0; i < 3; i++){
                this._progressiveQuickSort(frame * 3 + i);
            }
        }
        this.dirtyIndices();
    },
    _simpleSort: function(useNativeQuickSort) {
        var zList = this._zList;
        var indices = this.indices;
        function compare(a, b) {
            // Sort from far to near. which is descending order
            return zList[b] - zList[a];
        } // When too much value are equal, using native quick sort with three partition..
        // or the simple quick sort will be nearly O(n*n)
        // http://stackoverflow.com/questions/5126586/quicksort-complexity-when-all-the-elements-are-same
        // Otherwise simple quicksort is more effecient than v8 native quick sort when data all different.
        if (useNativeQuickSort) {
            Array.prototype.sort.call(indices, compare);
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].sort(indices, compare, 0, indices.length - 1);
        }
    },
    _progressiveQuickSort: function(frame) {
        var zList = this._zList;
        var indices = this.indices;
        this._quickSort = this._quickSort || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$ProgressiveQuickSort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._quickSort.step(indices, function(a, b) {
            return zList[b] - zList[a];
        }, frame);
    }
};
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/sdfSprite.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.sdfSprite.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform float elapsedTime : 0;\n\nattribute vec3 position : POSITION;\n\n#ifdef VERTEX_SIZE\nattribute float size;\n#else\nuniform float u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_FillColor: COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute float prevSize;\nuniform float percent : 1.0;\n#endif\n\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvarying float v_Size;\n\nvoid main()\n{\n\n#ifdef POSITIONTEXTURE_ENABLED\n gl_Position = worldViewProjection * vec4(texture2D(positionTexture, position.xy).xy, -10.0, 1.0);\n#else\n\n #ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n #else\n vec3 pos = position;\n #endif\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n#endif\n\n#ifdef VERTEX_SIZE\n#ifdef VERTEX_ANIMATION\n v_Size = mix(prevSize, size, percent);\n#else\n v_Size = size;\n#endif\n#else\n v_Size = u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\n v_Color = a_FillColor;\n #endif\n\n gl_PointSize = v_Size;\n}\n\n@end\n\n@export ecgl.sdfSprite.fragment\n\nuniform vec4 color: [1, 1, 1, 1];\nuniform vec4 strokeColor: [1, 1, 1, 1];\nuniform float smoothing: 0.07;\n\nuniform float lineWidth: 0.0;\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\nvarying float v_Size;\n\nuniform sampler2D sprite;\n\n@import clay.util.srgb\n\nvoid main()\n{\n gl_FragColor = color;\n\n vec4 _strokeColor = strokeColor;\n\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n #endif\n\n#ifdef SPRITE_ENABLED\n float d = texture2D(sprite, gl_PointCoord).r;\n gl_FragColor.a *= smoothstep(0.5 - smoothing, 0.5 + smoothing, d);\n\n if (lineWidth > 0.0) {\n float sLineWidth = lineWidth / 2.0;\n\n float outlineMaxValue0 = 0.5 + sLineWidth;\n float outlineMaxValue1 = 0.5 + sLineWidth + smoothing;\n float outlineMinValue0 = 0.5 - sLineWidth - smoothing;\n float outlineMinValue1 = 0.5 - sLineWidth;\n\n if (d <= outlineMaxValue1 && d >= outlineMinValue0) {\n float a = _strokeColor.a;\n if (d <= outlineMinValue1) {\n a = a * smoothstep(outlineMinValue0, outlineMinValue1, d);\n }\n else {\n a = a * smoothstep(outlineMaxValue1, outlineMaxValue0, d);\n }\n gl_FragColor.rgb = mix(gl_FragColor.rgb * gl_FragColor.a, _strokeColor.rgb, a);\n gl_FragColor.a = gl_FragColor.a * (1.0 - a) + a;\n }\n }\n#endif\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(gl_FragColor);\n#endif\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/PointsMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$verticesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/verticesSortMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$sdfSprite$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/sdfSprite.glsl.js [app-client] (ecmascript)");
;
;
;
;
var vec4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec4;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$sdfSprite$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var PointsMesh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.extend(function() {
    var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
        dynamic: true,
        attributes: {
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('color', 'float', 4, 'COLOR'),
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('position', 'float', 3, 'POSITION'),
            size: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('size', 'float', 1),
            prevPosition: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('prevPosition', 'float', 3),
            prevSize: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('prevSize', 'float', 1)
        }
    });
    Object.assign(geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$verticesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    var material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
        shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.sdfSprite'),
        transparent: true,
        depthMask: false
    });
    material.enableTexture('sprite');
    material.define('both', 'VERTEX_COLOR');
    material.define('both', 'VERTEX_SIZE');
    var sdfTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D({
        image: document.createElement('canvas'),
        flipY: false
    });
    material.set('sprite', sdfTexture); // Custom pick methods.
    geometry.pick = this._pick.bind(this);
    return {
        geometry: geometry,
        material: material,
        mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.POINTS,
        sizeScale: 1
    };
}, {
    _pick: function(x, y, renderer, camera, renderable, out) {
        var positionNDC = this._positionNDC;
        if (!positionNDC) {
            return;
        }
        var viewport = renderer.viewport;
        var ndcScaleX = 2 / viewport.width;
        var ndcScaleY = 2 / viewport.height; // From near to far. indices have been sorted.
        for(var i = this.geometry.vertexCount - 1; i >= 0; i--){
            var idx;
            if (!this.geometry.indices) {
                idx = i;
            } else {
                idx = this.geometry.indices[i];
            }
            var cx = positionNDC[idx * 2];
            var cy = positionNDC[idx * 2 + 1];
            var size = this.geometry.attributes.size.get(idx) / this.sizeScale;
            var halfSize = size / 2;
            if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {
                var point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3();
                var pointWorld = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3();
                this.geometry.attributes.position.get(idx, point.array);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Vector3.transformMat4(pointWorld, point, this.worldTransform);
                out.push({
                    vertexIndex: idx,
                    point: point,
                    pointWorld: pointWorld,
                    target: this,
                    distance: pointWorld.distance(camera.getWorldPosition())
                });
            }
        }
    },
    updateNDCPosition: function(worldViewProjection, is2D, api) {
        var positionNDC = this._positionNDC;
        var geometry = this.geometry;
        if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {
            positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);
        }
        var pos = vec4.create();
        for(var i = 0; i < geometry.vertexCount; i++){
            geometry.attributes.position.get(i, pos);
            pos[3] = 1;
            vec4.transformMat4(pos, pos, worldViewProjection.array);
            vec4.scale(pos, pos, 1 / pos[3]);
            positionNDC[i * 2] = pos[0];
            positionNDC[i * 2 + 1] = pos[1];
        }
    }
});
const __TURBOPACK__default__export__ = PointsMesh;
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/PointsBuilder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/tool/color.js [app-client] (ecmascript) <export * as color>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$sprite$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/sprite.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/PointsMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/LabelsBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/math/Matrix4.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
var SDF_RANGE = 20;
var Z_2D = -10;
function isSymbolSizeSame(a, b) {
    return a && b && a[0] === b[0] && a[1] === b[1];
} // TODO gl_PointSize has max value.
function PointsBuilder(is2D, api) {
    this.rootNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
    /**
   * @type {boolean}
   */ this.is2D = is2D;
    this._labelsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$LabelsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](256, 256, api); // Give a large render order.
    this._labelsBuilder.getMesh().renderOrder = 100;
    this.rootNode.add(this._labelsBuilder.getMesh());
    this._api = api;
    this._spriteImageCanvas = document.createElement('canvas');
    this._startDataIndex = 0;
    this._endDataIndex = 0;
    this._sizeScale = 1;
}
PointsBuilder.prototype = {
    constructor: PointsBuilder,
    /**
   * If highlight on over
   */ highlightOnMouseover: true,
    update: function(seriesModel, ecModel, api, start, end) {
        // Swap barMesh
        var tmp = this._prevMesh;
        this._prevMesh = this._mesh;
        this._mesh = tmp;
        var data = seriesModel.getData();
        if (start == null) {
            start = 0;
        }
        if (end == null) {
            end = data.count();
        }
        this._startDataIndex = start;
        this._endDataIndex = end - 1;
        if (!this._mesh) {
            var material = this._prevMesh && this._prevMesh.material;
            this._mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                // Render after axes
                renderOrder: 10,
                // FIXME
                frustumCulling: false
            });
            if (material) {
                this._mesh.material = material;
            }
        }
        var material = this._mesh.material;
        var geometry = this._mesh.geometry;
        var attributes = geometry.attributes;
        this.rootNode.remove(this._prevMesh);
        this.rootNode.add(this._mesh);
        this._setPositionTextureToMesh(this._mesh, this._positionTexture);
        var symbolInfo = this._getSymbolInfo(seriesModel, start, end);
        var dpr = api.getDevicePixelRatio(); // TODO image symbol
        var itemStyle = seriesModel.getModel('itemStyle').getItemStyle();
        var largeMode = seriesModel.get('large');
        var pointSizeScale = 1;
        if (symbolInfo.maxSize > 2) {
            pointSizeScale = this._updateSymbolSprite(seriesModel, itemStyle, symbolInfo, dpr);
            material.enableTexture('sprite');
        } else {
            material.disableTexture('sprite');
        }
        attributes.position.init(end - start);
        var rgbaArr = [];
        if (largeMode) {
            material.undefine('VERTEX_SIZE');
            material.undefine('VERTEX_COLOR');
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVisualColor"])(data);
            var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVisualOpacity"])(data);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color, rgbaArr);
            rgbaArr[3] *= opacity;
            material.set({
                color: rgbaArr,
                'u_Size': symbolInfo.maxSize * this._sizeScale
            });
        } else {
            material.set({
                color: [
                    1,
                    1,
                    1,
                    1
                ]
            });
            material.define('VERTEX_SIZE');
            material.define('VERTEX_COLOR');
            attributes.size.init(end - start);
            attributes.color.init(end - start);
            this._originalOpacity = new Float32Array(end - start);
        }
        var points = data.getLayout('points');
        var positionArr = attributes.position.value;
        var hasTransparentPoint = false;
        for(var i = 0; i < end - start; i++){
            var i3 = i * 3;
            var i2 = i * 2;
            if (this.is2D) {
                positionArr[i3] = points[i2];
                positionArr[i3 + 1] = points[i2 + 1];
                positionArr[i3 + 2] = Z_2D;
            } else {
                positionArr[i3] = points[i3];
                positionArr[i3 + 1] = points[i3 + 1];
                positionArr[i3 + 2] = points[i3 + 2];
            }
            if (!largeMode) {
                var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, i);
                var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, i);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color, rgbaArr);
                rgbaArr[3] *= opacity;
                attributes.color.set(i, rgbaArr);
                if (rgbaArr[3] < 0.99) {
                    hasTransparentPoint = true;
                }
                var symbolSize = data.getItemVisual(i, 'symbolSize');
                symbolSize = symbolSize instanceof Array ? Math.max(symbolSize[0], symbolSize[1]) : symbolSize; // NaN pointSize may have strange result.
                if (isNaN(symbolSize)) {
                    symbolSize = 0;
                } // Scale point size because canvas has margin.
                attributes.size.value[i] = symbolSize * pointSizeScale * this._sizeScale; // Save the original opacity for recover from fadeIn.
                this._originalOpacity[i] = rgbaArr[3];
            }
        }
        this._mesh.sizeScale = pointSizeScale;
        geometry.updateBoundingBox();
        geometry.dirty(); // Update material.
        this._updateMaterial(seriesModel, itemStyle);
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
            material[methodName]('fragment', 'SRGB_DECODE');
        }
        if (!largeMode) {
            this._updateLabelBuilder(seriesModel, start, end);
        }
        this._updateHandler(seriesModel, ecModel, api);
        this._updateAnimation(seriesModel);
        this._api = api;
    },
    getPointsMesh: function() {
        return this._mesh;
    },
    updateLabels: function(highlightDataIndices) {
        this._labelsBuilder.updateLabels(highlightDataIndices);
    },
    hideLabels: function() {
        this.rootNode.remove(this._labelsBuilder.getMesh());
    },
    showLabels: function() {
        this.rootNode.add(this._labelsBuilder.getMesh());
    },
    dispose: function() {
        this._labelsBuilder.dispose();
    },
    _updateSymbolSprite: function(seriesModel, itemStyle, symbolInfo, dpr) {
        symbolInfo.maxSize = Math.min(symbolInfo.maxSize * 2, 200);
        var symbolSize = [];
        if (symbolInfo.aspect > 1) {
            symbolSize[0] = symbolInfo.maxSize;
            symbolSize[1] = symbolInfo.maxSize / symbolInfo.aspect;
        } else {
            symbolSize[1] = symbolInfo.maxSize;
            symbolSize[0] = symbolInfo.maxSize * symbolInfo.aspect;
        } // In case invalid data.
        symbolSize[0] = symbolSize[0] || 1;
        symbolSize[1] = symbolSize[1] || 1;
        if (this._symbolType !== symbolInfo.type || !isSymbolSizeSame(this._symbolSize, symbolSize) || this._lineWidth !== itemStyle.lineWidth) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$sprite$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSymbolSprite(symbolInfo.type, symbolSize, {
                fill: '#fff',
                lineWidth: itemStyle.lineWidth,
                stroke: 'transparent',
                shadowColor: 'transparent',
                minMargin: Math.min(symbolSize[0] / 2, 10)
            }, this._spriteImageCanvas);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$sprite$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSDFFromCanvas(this._spriteImageCanvas, Math.min(this._spriteImageCanvas.width, 32), SDF_RANGE, this._mesh.material.get('sprite').image);
            this._symbolType = symbolInfo.type;
            this._symbolSize = symbolSize;
            this._lineWidth = itemStyle.lineWidth;
        }
        return this._spriteImageCanvas.width / symbolInfo.maxSize * dpr;
    },
    _updateMaterial: function(seriesModel, itemStyle) {
        var blendFunc = seriesModel.get('blendMode') === 'lighter' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].additiveBlend : null;
        var material = this._mesh.material;
        material.blend = blendFunc;
        material.set('lineWidth', itemStyle.lineWidth / SDF_RANGE);
        var strokeColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(itemStyle.stroke);
        material.set('strokeColor', strokeColor); // Because of symbol texture, we always needs it be transparent.
        material.transparent = true;
        material.depthMask = false;
        material.depthTest = !this.is2D;
        material.sortVertices = !this.is2D;
    },
    _updateLabelBuilder: function(seriesModel, start, end) {
        var data = seriesModel.getData();
        var geometry = this._mesh.geometry;
        var positionArr = geometry.attributes.position.value;
        var start = this._startDataIndex;
        var pointSizeScale = this._mesh.sizeScale;
        this._labelsBuilder.updateData(data, start, end);
        this._labelsBuilder.getLabelPosition = function(dataIndex, positionDesc, distance) {
            var idx3 = (dataIndex - start) * 3;
            return [
                positionArr[idx3],
                positionArr[idx3 + 1],
                positionArr[idx3 + 2]
            ];
        };
        this._labelsBuilder.getLabelDistance = function(dataIndex, positionDesc, distance) {
            var size = geometry.attributes.size.get(dataIndex - start) / pointSizeScale;
            return size / 2 + distance;
        };
        this._labelsBuilder.updateLabels();
    },
    _updateAnimation: function(seriesModel) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].updateVertexAnimation([
            [
                'prevPosition',
                'position'
            ],
            [
                'prevSize',
                'size'
            ]
        ], this._prevMesh, this._mesh, seriesModel);
    },
    _updateHandler: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var pointsMesh = this._mesh;
        var self = this;
        var lastDataIndex = -1;
        var isCartesian3D = seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian3D';
        var grid3DModel;
        if (isCartesian3D) {
            grid3DModel = seriesModel.coordinateSystem.model;
        }
        pointsMesh.seriesIndex = seriesModel.seriesIndex;
        pointsMesh.off('mousemove');
        pointsMesh.off('mouseout');
        pointsMesh.on('mousemove', function(e) {
            var dataIndex = e.vertexIndex + self._startDataIndex;
            if (dataIndex !== lastDataIndex) {
                if (this.highlightOnMouseover) {
                    this.downplay(data, lastDataIndex);
                    this.highlight(data, dataIndex);
                    this._labelsBuilder.updateLabels([
                        dataIndex
                    ]);
                }
                if (isCartesian3D) {
                    api.dispatchAction({
                        type: 'grid3DShowAxisPointer',
                        value: [
                            data.get(seriesModel.coordDimToDataDim('x')[0], dataIndex),
                            data.get(seriesModel.coordDimToDataDim('y')[0], dataIndex),
                            data.get(seriesModel.coordDimToDataDim('z')[0], dataIndex)
                        ],
                        grid3DIndex: grid3DModel.componentIndex
                    });
                }
            }
            pointsMesh.dataIndex = dataIndex;
            lastDataIndex = dataIndex;
        }, this);
        pointsMesh.on('mouseout', function(e) {
            var dataIndex = e.vertexIndex + self._startDataIndex;
            if (this.highlightOnMouseover) {
                this.downplay(data, dataIndex);
                this._labelsBuilder.updateLabels();
            }
            lastDataIndex = -1;
            pointsMesh.dataIndex = -1;
            if (isCartesian3D) {
                api.dispatchAction({
                    type: 'grid3DHideAxisPointer',
                    grid3DIndex: grid3DModel.componentIndex
                });
            }
        }, this);
    },
    updateLayout: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        if (!this._mesh) {
            return;
        }
        var positionArr = this._mesh.geometry.attributes.position.value;
        var points = data.getLayout('points');
        if (this.is2D) {
            for(var i = 0; i < points.length / 2; i++){
                var i3 = i * 3;
                var i2 = i * 2;
                positionArr[i3] = points[i2];
                positionArr[i3 + 1] = points[i2 + 1];
                positionArr[i3 + 2] = Z_2D;
            }
        } else {
            for(var i = 0; i < points.length; i++){
                positionArr[i] = points[i];
            }
        }
        this._mesh.geometry.dirty();
        api.getZr().refresh();
    },
    updateView: function(camera) {
        if (!this._mesh) {
            return;
        }
        var worldViewProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mul(worldViewProjection, camera.viewMatrix, this._mesh.worldTransform);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$math$2f$Matrix4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].mul(worldViewProjection, camera.projectionMatrix, worldViewProjection);
        this._mesh.updateNDCPosition(worldViewProjection, this.is2D, this._api);
    },
    highlight: function(data, dataIndex) {
        if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
            return;
        }
        var itemModel = data.getItemModel(dataIndex);
        var emphasisItemStyleModel = itemModel.getModel('emphasis.itemStyle');
        var emphasisColor = emphasisItemStyleModel.get('color');
        var emphasisOpacity = emphasisItemStyleModel.get('opacity');
        if (emphasisColor == null) {
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
            emphasisColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$tool$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__color$3e$__["color"].lift(color, -0.4);
        }
        if (emphasisOpacity == null) {
            emphasisOpacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex);
        }
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(emphasisColor);
        colorArr[3] *= emphasisOpacity;
        this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
        this._mesh.geometry.dirtyAttribute('color');
        this._api.getZr().refresh();
    },
    downplay: function(data, dataIndex) {
        if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
            return;
        }
        var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex);
        var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex);
        var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
        colorArr[3] *= opacity;
        this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
        this._mesh.geometry.dirtyAttribute('color');
        this._api.getZr().refresh();
    },
    fadeOutAll: function(fadeOutPercent) {
        if (this._originalOpacity) {
            var geo = this._mesh.geometry;
            for(var i = 0; i < geo.vertexCount; i++){
                var fadeOutOpacity = this._originalOpacity[i] * fadeOutPercent;
                geo.attributes.color.value[i * 4 + 3] = fadeOutOpacity;
            }
            geo.dirtyAttribute('color');
            this._api.getZr().refresh();
        }
    },
    fadeInAll: function() {
        this.fadeOutAll(1);
    },
    setPositionTexture: function(texture) {
        if (this._mesh) {
            this._setPositionTextureToMesh(this._mesh, texture);
        }
        this._positionTexture = texture;
    },
    removePositionTexture: function() {
        this._positionTexture = null;
        if (this._mesh) {
            this._setPositionTextureToMesh(this._mesh, null);
        }
    },
    setSizeScale: function(sizeScale) {
        if (sizeScale !== this._sizeScale) {
            if (this._mesh) {
                var originalSize = this._mesh.material.get('u_Size');
                this._mesh.material.set('u_Size', originalSize / this._sizeScale * sizeScale);
                var attributes = this._mesh.geometry.attributes;
                if (attributes.size.value) {
                    for(var i = 0; i < attributes.size.value.length; i++){
                        attributes.size.value[i] = attributes.size.value[i] / this._sizeScale * sizeScale;
                    }
                }
            }
            this._sizeScale = sizeScale;
        }
    },
    _setPositionTextureToMesh: function(mesh, texture) {
        if (texture) {
            mesh.material.set('positionTexture', texture);
        }
        mesh.material[texture ? 'enableTexture' : 'disableTexture']('positionTexture');
    },
    _getSymbolInfo: function(seriesModel, start, end) {
        if (seriesModel.get('large')) {
            var symbolSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('symbolSize'), 1);
            var maxSymbolSize;
            var symbolAspect;
            if (symbolSize instanceof Array) {
                maxSymbolSize = Math.max(symbolSize[0], symbolSize[1]);
                symbolAspect = symbolSize[0] / symbolSize[1];
            } else {
                maxSymbolSize = symbolSize;
                symbolAspect = 1;
            }
            return {
                maxSize: symbolSize,
                type: seriesModel.get('symbol'),
                aspect: symbolAspect
            };
        }
        var data = seriesModel.getData();
        var symbolAspect;
        var differentSymbolAspect = false;
        var symbolType = data.getItemVisual(0, 'symbol') || 'circle';
        var differentSymbolType = false;
        var maxSymbolSize = 0;
        for(var idx = start; idx < end; idx++){
            var symbolSize = data.getItemVisual(idx, 'symbolSize');
            var currentSymbolType = data.getItemVisual(idx, 'symbol');
            var currentSymbolAspect;
            if (!(symbolSize instanceof Array)) {
                // Ignore NaN value.
                if (isNaN(symbolSize)) {
                    continue;
                }
                currentSymbolAspect = 1;
                maxSymbolSize = Math.max(symbolSize, maxSymbolSize);
            } else {
                currentSymbolAspect = symbolSize[0] / symbolSize[1];
                maxSymbolSize = Math.max(Math.max(symbolSize[0], symbolSize[1]), maxSymbolSize);
            }
            if ("TURBOPACK compile-time truthy", 1) {
                if (symbolAspect != null && Math.abs(currentSymbolAspect - symbolAspect) > 0.05) {
                    differentSymbolAspect = true;
                }
                if (currentSymbolType !== symbolType) {
                    differentSymbolType = true;
                }
            }
            symbolType = currentSymbolType;
            symbolAspect = currentSymbolAspect;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (differentSymbolAspect) {
                console.warn('Different symbol width / height ratio will be ignored.');
            }
            if (differentSymbolType) {
                console.warn('Different symbol type will be ignored.');
            }
        }
        return {
            maxSize: maxSymbolSize,
            type: symbolType,
            aspect: symbolAspect
        };
    }
};
const __TURBOPACK__default__export__ = PointsBuilder;
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/PointsBuilder.js [app-client] (ecmascript)");
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'scatter3D',
    hasSymbolVisual: true,
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._pointsBuilderList = [];
        this._currentStep = 0;
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        if (!seriesModel.getData().count()) {
            return;
        }
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
            this._camera = coordSys.viewGL.camera;
            var pointsBuilder = this._pointsBuilderList[0];
            if (!pointsBuilder) {
                pointsBuilder = this._pointsBuilderList[0] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](false, api);
            }
            this._pointsBuilderList.length = 1;
            this.groupGL.add(pointsBuilder.rootNode);
            pointsBuilder.update(seriesModel, ecModel, api);
            pointsBuilder.updateView(coordSys.viewGL.camera);
        } else {
            if ("TURBOPACK compile-time truthy", 1) {
                throw new Error('Invalid coordinate system');
            }
        }
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
            this._camera = coordSys.viewGL.camera;
        } else {
            if ("TURBOPACK compile-time truthy", 1) {
                throw new Error('Invalid coordinate system');
            }
        }
        this.groupGL.removeAll();
        this._currentStep = 0;
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
        // TODO Sort transparency.
        if (params.end <= params.start) {
            return;
        }
        var pointsBuilder = this._pointsBuilderList[this._currentStep];
        if (!pointsBuilder) {
            pointsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](false, api);
            this._pointsBuilderList[this._currentStep] = pointsBuilder;
        }
        this.groupGL.add(pointsBuilder.rootNode);
        pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
        pointsBuilder.updateView(seriesModel.coordinateSystem.viewGL.camera);
        this._currentStep++;
    },
    updateCamera: function() {
        this._pointsBuilderList.forEach(function(pointsBuilder) {
            pointsBuilder.updateView(this._camera);
        }, this);
    },
    highlight: function(seriesModel, ecModel, api, payload) {
        this._toggleStatus('highlight', seriesModel, ecModel, api, payload);
    },
    downplay: function(seriesModel, ecModel, api, payload) {
        this._toggleStatus('downplay', seriesModel, ecModel, api, payload);
    },
    _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].queryDataIndex(data, payload);
        var isHighlight = status === 'highlight';
        if (dataIndex != null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].each(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalizeToArray(dataIndex), function(dataIdx) {
                for(var i = 0; i < this._pointsBuilderList.length; i++){
                    var pointsBuilder = this._pointsBuilderList[i];
                    isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
                }
            }, this);
        } else {
            // PENDING, OPTIMIZE
            data.each(function(dataIdx) {
                for(var i = 0; i < this._pointsBuilderList.length; i++){
                    var pointsBuilder = this._pointsBuilderList[i];
                    isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
                }
            });
        }
    },
    dispose: function() {
        this._pointsBuilderList.forEach(function(pointsBuilder) {
            pointsBuilder.dispose();
        });
        this.groupGL.removeAll();
    },
    remove: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatter3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$Scatter3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$Scatter3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$Scatter3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$Scatter3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerLayout({
        seriesType: 'scatter3D',
        reset: function(seriesModel) {
            var coordSys = seriesModel.coordinateSystem;
            if (coordSys) {
                var coordDims = coordSys.dimensions;
                if (coordDims.length < 3) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        console.error('scatter3D needs 3D coordinateSystem');
                    }
                    return;
                }
                var dims = coordDims.map(function(coordDim) {
                    return seriesModel.coordDimToDataDim(coordDim)[0];
                });
                var item = [];
                var out = [];
                return {
                    progress: function(params, data) {
                        var points = new Float32Array((params.end - params.start) * 3);
                        for(var idx = params.start; idx < params.end; idx++){
                            var idx3 = (idx - params.start) * 3;
                            item[0] = data.get(dims[0], idx);
                            item[1] = data.get(dims[1], idx);
                            item[2] = data.get(dims[2], idx);
                            coordSys.dataToPoint(item, out);
                            points[idx3] = out[0];
                            points[idx3 + 1] = out[1];
                            points[idx3 + 2] = out[2];
                        }
                        data.setLayout('points', points);
                    }
                };
            }
        }
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatter3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatter3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/lines3DLayout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>lines3DLayout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
var vec2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec2;
var normalize = vec3.normalize;
var cross = vec3.cross;
var sub = vec3.sub;
var add = vec3.add;
var create = vec3.create;
var normal = create();
var tangent = create();
var bitangent = create();
var halfVector = create();
var coord0 = [];
var coord1 = [];
function getCubicPointsOnGlobe(coords, coordSys) {
    vec2.copy(coord0, coords[0]);
    vec2.copy(coord1, coords[1]);
    var pts = [];
    var p0 = pts[0] = create();
    var p1 = pts[1] = create();
    var p2 = pts[2] = create();
    var p3 = pts[3] = create();
    coordSys.dataToPoint(coord0, p0);
    coordSys.dataToPoint(coord1, p3); // Get p1
    normalize(normal, p0); // TODO p0-p3 is parallel with normal
    sub(tangent, p3, p0);
    normalize(tangent, tangent);
    cross(bitangent, tangent, normal);
    normalize(bitangent, bitangent);
    cross(tangent, normal, bitangent); // p1 is half vector of p0 and tangent on p0
    add(p1, normal, tangent);
    normalize(p1, p1); // Get p2
    normalize(normal, p3);
    sub(tangent, p0, p3);
    normalize(tangent, tangent);
    cross(bitangent, tangent, normal);
    normalize(bitangent, bitangent);
    cross(tangent, normal, bitangent); // p2 is half vector of p3 and tangent on p3
    add(p2, normal, tangent);
    normalize(p2, p2); // Project distance of p0 on halfVector
    add(halfVector, p0, p3);
    normalize(halfVector, halfVector);
    var projDist = vec3.dot(p0, halfVector); // Angle of halfVector and p1
    var cosTheta = vec3.dot(halfVector, p1);
    var len = (Math.max(vec3.len(p0), vec3.len(p3)) - projDist) / cosTheta * 2;
    vec3.scaleAndAdd(p1, p0, p1, len);
    vec3.scaleAndAdd(p2, p3, p2, len);
    return pts;
}
function getCubicPointsOnPlane(coords, coordSys, up) {
    var pts = [];
    var p0 = pts[0] = vec3.create();
    var p1 = pts[1] = vec3.create();
    var p2 = pts[2] = vec3.create();
    var p3 = pts[3] = vec3.create();
    coordSys.dataToPoint(coords[0], p0);
    coordSys.dataToPoint(coords[1], p3);
    var len = vec3.dist(p0, p3);
    vec3.lerp(p1, p0, p3, 0.3);
    vec3.lerp(p2, p0, p3, 0.3);
    vec3.scaleAndAdd(p1, p1, up, Math.min(len * 0.1, 10));
    vec3.scaleAndAdd(p2, p2, up, Math.min(len * 0.1, 10));
    return pts;
}
function getPolylinePoints(coords, coordSys) {
    var pts = new Float32Array(coords.length * 3);
    var off = 0;
    var pt = [];
    for(var i = 0; i < coords.length; i++){
        coordSys.dataToPoint(coords[i], pt);
        pts[off++] = pt[0];
        pts[off++] = pt[1];
        pts[off++] = pt[2];
    }
    return pts;
}
function prepareCoords(data) {
    var coordsList = [];
    data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords', true);
        if ("TURBOPACK compile-time truthy", 1) {
            if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
                throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');
            }
        }
        coordsList.push(coords);
    });
    return {
        coordsList: coordsList
    };
}
function layoutGlobe(seriesModel, coordSys) {
    var data = seriesModel.getData();
    var isPolyline = seriesModel.get('polyline');
    data.setLayout('lineType', isPolyline ? 'polyline' : 'cubicBezier');
    var res = prepareCoords(data);
    data.each(function(idx) {
        var coords = res.coordsList[idx];
        var getPointsMethod = isPolyline ? getPolylinePoints : getCubicPointsOnGlobe;
        data.setItemLayout(idx, getPointsMethod(coords, coordSys));
    });
}
function layoutOnPlane(seriesModel, coordSys, normal) {
    var data = seriesModel.getData();
    var isPolyline = seriesModel.get('polyline');
    var res = prepareCoords(data);
    data.setLayout('lineType', isPolyline ? 'polyline' : 'cubicBezier');
    data.each(function(idx) {
        var coords = res.coordsList[idx];
        var pts = isPolyline ? getPolylinePoints(coords, coordSys) : getCubicPointsOnPlane(coords, coordSys, normal);
        data.setItemLayout(idx, pts);
    });
}
function lines3DLayout(ecModel, api) {
    ecModel.eachSeriesByType('lines3D', function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type === 'globe') {
            layoutGlobe(seriesModel, coordSys);
        } else if (coordSys.type === 'geo3D') {
            layoutOnPlane(seriesModel, coordSys, [
                0,
                1,
                0
            ]);
        } else if (coordSys.type === 'mapbox3D' || coordSys.type === 'maptalks3D') {
            layoutOnPlane(seriesModel, coordSys, [
                0,
                0,
                1
            ]);
        }
    });
}
;
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/Lines3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.lines3D',
    dependencies: [
        'globe'
    ],
    visualStyleAccessPath: 'lineStyle',
    visualDrawType: 'stroke',
    getInitialData: function(option, ecModel) {
        var lineData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"]([
            'value'
        ], this);
        lineData.hasItemOption = false;
        lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
            // dataItem is simply coords
            if (dataItem instanceof Array) {
                return NaN;
            } else {
                lineData.hasItemOption = true;
                var value = dataItem.value;
                if (value != null) {
                    return value instanceof Array ? value[dimIndex] : value;
                }
            }
        });
        return lineData;
    },
    defaultOption: {
        coordinateSystem: 'globe',
        globeIndex: 0,
        geo3DIndex: 0,
        zlevel: -10,
        polyline: false,
        effect: {
            show: false,
            period: 4,
            // Trail width
            trailWidth: 4,
            trailLength: 0.2,
            spotIntensity: 6
        },
        silent: true,
        // Support source-over, lighter
        blendMode: 'source-over',
        lineStyle: {
            width: 1,
            opacity: 0.5 // color
        }
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/shader/trail2.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.trail2.vertex\nattribute vec3 position: POSITION;\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float offset;\nattribute float dist;\nattribute float distAll;\nattribute float start;\n\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\nuniform float near : NEAR;\n\nuniform float speed : 0;\nuniform float trailLength: 0.3;\nuniform float time;\nuniform float period: 1000;\n\nuniform float spotSize: 1;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.vertexHeader\n\n@import ecgl.lines3D.clipNear\n\nvoid main()\n{\n @import ecgl.lines3D.expandLine\n\n gl_Position = currProj;\n\n v_Color = a_Color;\n\n @import ecgl.common.wireframe.vertexMain\n\n#ifdef CONSTANT_SPEED\n float t = mod((speed * time + start) / distAll, 1. + trailLength) - trailLength;\n#else\n float t = mod((time + start) / period, 1. + trailLength) - trailLength;\n#endif\n\n float trailLen = distAll * trailLength;\n\n v_Percent = (dist - t * distAll) / trailLen;\n\n v_SpotPercent = spotSize / distAll;\n\n }\n@end\n\n\n@export ecgl.trail2.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform float spotIntensity: 5;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n if (v_Percent > 1.0 || v_Percent < 0.0) {\n discard;\n }\n\n float fade = v_Percent;\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n\n @import ecgl.common.wireframe.fragmentMain\n\n if (v_Percent > (1.0 - v_SpotPercent)) {\n gl_FragColor.rgb *= spotIntensity;\n }\n\n gl_FragColor.a *= fade;\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/TrailMesh2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$shader$2f$trail2$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/shader/trail2.glsl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
function sign(a) {
    return a > 0 ? 1 : -1;
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$shader$2f$trail2$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.extend(function() {
    var material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
        shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.trail2.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.trail2.fragment')),
        transparent: true,
        depthMask: false
    });
    var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        dynamic: true
    });
    geometry.createAttribute('dist', 'float', 1);
    geometry.createAttribute('distAll', 'float', 1);
    geometry.createAttribute('start', 'float', 1);
    return {
        geometry: geometry,
        material: material,
        culling: false,
        $ignorePicking: true
    };
}, {
    updateData: function(data, api, lines3DGeometry) {
        var seriesModel = data.hostModel;
        var geometry = this.geometry;
        var effectModel = seriesModel.getModel('effect');
        var size = effectModel.get('trailWidth') * api.getDevicePixelRatio();
        var trailLength = effectModel.get('trailLength');
        var speed = seriesModel.get('effect.constantSpeed');
        var period = seriesModel.get('effect.period') * 1000;
        var useConstantSpeed = speed != null;
        if ("TURBOPACK compile-time truthy", 1) {
            if (!this.getScene()) {
                console.error('TrailMesh must been add to scene before updateData');
            }
        }
        useConstantSpeed ? this.material.set('speed', speed / 1000) : this.material.set('period', period);
        this.material[useConstantSpeed ? 'define' : 'undefine']('vertex', 'CONSTANT_SPEED');
        var isPolyline = seriesModel.get('polyline');
        geometry.trailLength = trailLength;
        this.material.set('trailLength', trailLength);
        geometry.resetOffset();
        [
            'position',
            'positionPrev',
            'positionNext'
        ].forEach(function(attrName) {
            geometry.attributes[attrName].value = lines3DGeometry.attributes[attrName].value;
        });
        var extraAttrs = [
            'dist',
            'distAll',
            'start',
            'offset',
            'color'
        ];
        extraAttrs.forEach(function(attrName) {
            geometry.attributes[attrName].init(geometry.vertexCount);
        });
        geometry.indices = lines3DGeometry.indices;
        var colorArr = [];
        var effectColor = effectModel.get('trailColor');
        var effectOpacity = effectModel.get('trailOpacity');
        var hasEffectColor = effectColor != null;
        var hasEffectOpacity = effectOpacity != null;
        this.updateWorldTransform();
        var xScale = this.worldTransform.x.len();
        var yScale = this.worldTransform.y.len();
        var zScale = this.worldTransform.z.len();
        var vertexOffset = 0;
        var maxDistance = 0;
        data.each(function(idx) {
            var pts = data.getItemLayout(idx);
            var opacity = hasEffectOpacity ? effectOpacity : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, idx);
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, idx);
            if (opacity == null) {
                opacity = 1;
            }
            colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(hasEffectColor ? effectColor : color, colorArr);
            colorArr[3] *= opacity;
            var vertexCount = isPolyline ? lines3DGeometry.getPolylineVertexCount(pts) : lines3DGeometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
            var dist = 0;
            var pos = [];
            var posPrev = [];
            for(var i = vertexOffset; i < vertexOffset + vertexCount; i++){
                geometry.attributes.position.get(i, pos);
                pos[0] *= xScale;
                pos[1] *= yScale;
                pos[2] *= zScale;
                if (i > vertexOffset) {
                    dist += vec3.dist(pos, posPrev);
                }
                geometry.attributes.dist.set(i, dist);
                vec3.copy(posPrev, pos);
            }
            maxDistance = Math.max(maxDistance, dist);
            var randomStart = Math.random() * (useConstantSpeed ? dist : period);
            for(var i = vertexOffset; i < vertexOffset + vertexCount; i++){
                geometry.attributes.distAll.set(i, dist);
                geometry.attributes.start.set(i, randomStart);
                geometry.attributes.offset.set(i, sign(lines3DGeometry.attributes.offset.get(i)) * size / 2);
                geometry.attributes.color.set(i, colorArr);
            }
            vertexOffset += vertexCount;
        });
        this.material.set('spotSize', maxDistance * 0.1 * trailLength);
        this.material.set('spotIntensity', effectModel.get('spotIntensity'));
        geometry.dirty();
    },
    setAnimationTime: function(time) {
        this.material.set('time', time);
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/Lines3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines3D.js [app-client] (ecmascript)"); // import TrailMesh from './TrailMesh';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$TrailMesh2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/TrailMesh2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lines3D.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines3D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function getCoordSysSize(coordSys) {
    if (coordSys.radius != null) {
        return coordSys.radius;
    }
    if (coordSys.size != null) {
        return Math.max(coordSys.size[0], coordSys.size[1], coordSys.size[2]);
    } else {
        return 100;
    }
}
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'lines3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._meshLinesMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines3D'),
            transparent: true,
            depthMask: false
        });
        this._linesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
            material: this._meshLinesMaterial,
            $ignorePicking: true
        }); // this._trailMesh = new TrailMesh();
        this._trailMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$TrailMesh2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.add(this._linesMesh);
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        if (coordSys && coordSys.viewGL) {
            var viewGL = coordSys.viewGL;
            viewGL.add(this.groupGL);
            this._updateLines(seriesModel, ecModel, api);
            var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
            this._linesMesh.material[methodName]('fragment', 'SRGB_DECODE');
            this._trailMesh.material[methodName]('fragment', 'SRGB_DECODE');
        }
        var trailMesh = this._trailMesh;
        trailMesh.stopAnimation();
        if (seriesModel.get('effect.show')) {
            this.groupGL.add(trailMesh);
            trailMesh.updateData(data, api, this._linesMesh.geometry);
            trailMesh.__time = trailMesh.__time || 0;
            var time = 3600 * 1000; // 1hour
            this._curveEffectsAnimator = trailMesh.animate('', {
                loop: true
            }).when(time, {
                __time: time
            }).during(function() {
                trailMesh.setAnimationTime(trailMesh.__time);
            }).start();
        } else {
            this.groupGL.remove(trailMesh);
            this._curveEffectsAnimator = null;
        }
        this._linesMesh.material.blend = this._trailMesh.material.blend = seriesModel.get('blendMode') === 'lighter' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].additiveBlend : null;
    },
    pauseEffect: function() {
        if (this._curveEffectsAnimator) {
            this._curveEffectsAnimator.pause();
        }
    },
    resumeEffect: function() {
        if (this._curveEffectsAnimator) {
            this._curveEffectsAnimator.resume();
        }
    },
    toggleEffect: function() {
        var animator = this._curveEffectsAnimator;
        if (animator) {
            animator.isPaused() ? animator.resume() : animator.pause();
        }
    },
    _updateLines: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var geometry = this._linesMesh.geometry;
        var isPolyline = seriesModel.get('polyline');
        geometry.expandLine = true;
        var size = getCoordSysSize(coordSys);
        geometry.segmentScale = size / 20;
        var lineWidthQueryPath = 'lineStyle.width'.split('.');
        var dpr = api.getDevicePixelRatio();
        var maxLineWidth = 0;
        data.each(function(idx) {
            var itemModel = data.getItemModel(idx);
            var lineWidth = itemModel.get(lineWidthQueryPath);
            if (lineWidth == null) {
                lineWidth = 1;
            }
            data.setItemVisual(idx, 'lineWidth', lineWidth);
            maxLineWidth = Math.max(lineWidth, maxLineWidth);
        }); // Must set useNativeLine before calling any other methods
        geometry.useNativeLine = false;
        var nVertex = 0;
        var nTriangle = 0;
        data.each(function(idx) {
            var pts = data.getItemLayout(idx);
            if (isPolyline) {
                nVertex += geometry.getPolylineVertexCount(pts);
                nTriangle += geometry.getPolylineTriangleCount(pts);
            } else {
                nVertex += geometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
                nTriangle += geometry.getCubicCurveTriangleCount(pts[0], pts[1], pts[2], pts[3]);
            }
        });
        geometry.setVertexCount(nVertex);
        geometry.setTriangleCount(nTriangle);
        geometry.resetOffset();
        var colorArr = [];
        data.each(function(idx) {
            var pts = data.getItemLayout(idx);
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, idx);
            var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, idx);
            var lineWidth = data.getItemVisual(idx, 'lineWidth') * dpr;
            if (opacity == null) {
                opacity = 1;
            }
            colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color, colorArr);
            colorArr[3] *= opacity;
            if (isPolyline) {
                geometry.addPolyline(pts, colorArr, lineWidth);
            } else {
                geometry.addCubicCurve(pts[0], pts[1], pts[2], pts[3], colorArr, lineWidth);
            }
        });
        geometry.dirty();
    },
    remove: function() {
        this.groupGL.removeAll();
    },
    dispose: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$lines3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/lines3DLayout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$Lines3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/Lines3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$Lines3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/Lines3DView.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$Lines3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$Lines3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerLayout(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$lines3DLayout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'lines3DPauseEffect',
        event: 'lines3deffectpaused',
        update: 'series.lines3D:pauseEffect'
    }, function() {});
    registers.registerAction({
        type: 'lines3DResumeEffect',
        event: 'lines3deffectresumed',
        update: 'series.lines3D:resumeEffect'
    }, function() {});
    registers.registerAction({
        type: 'lines3DToggleEffect',
        event: 'lines3deffectchanged',
        update: 'series.lines3D:toggleEffect'
    }, function() {});
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/lines3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
;
;
function transformPolygon(coordSys, poly) {
    var ret = [];
    for(var i = 0; i < poly.length; i++){
        ret.push(coordSys.dataToPoint(poly[i]));
    }
    return ret;
}
var Polygons3DSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.polygons3D',
    getRegionModel: function(idx) {
        return this.getData().getItemModel(idx);
    },
    getRegionPolygonCoords: function(idx) {
        var coordSys = this.coordinateSystem;
        var itemModel = this.getData().getItemModel(idx);
        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');
        if (!itemModel.get('multiPolygon')) {
            coords = [
                coords
            ];
        } // TODO Validate
        var out = [];
        for(var i = 0; i < coords.length; i++){
            // TODO Convert here ?
            var interiors = [];
            for(var k = 1; k < coords[i].length; k++){
                interiors.push(transformPolygon(coordSys, coords[i][k]));
            }
            out.push({
                exterior: transformPolygon(coordSys, coords[i][0]),
                interiors: interiors
            });
        }
        return out;
    },
    getInitialData: function(option) {
        var polygonsData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"]([
            'value'
        ], this);
        polygonsData.hasItemOption = false;
        polygonsData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
            // dataItem is simply coords
            if (dataItem instanceof Array) {
                return NaN;
            } else {
                polygonsData.hasItemOption = true;
                var value = dataItem.value;
                if (value != null) {
                    return value instanceof Array ? value[dimIndex] : value;
                }
            }
        });
        return polygonsData;
    },
    defaultOption: {
        show: true,
        data: null,
        multiPolygon: false,
        progressiveThreshold: 1e3,
        progressive: 1e3,
        zlevel: -10,
        label: {
            show: false,
            // Distance in 3d space.
            distance: 2,
            textStyle: {
                fontSize: 20,
                color: '#000',
                backgroundColor: 'rgba(255,255,255,0.7)',
                padding: 3,
                borderRadius: 4
            }
        },
        itemStyle: {
            color: '#fff',
            borderWidth: 0,
            borderColor: '#333'
        },
        emphasis: {
            itemStyle: {
                color: '#639fc0'
            },
            label: {
                show: true
            }
        }
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Polygons3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Polygons3DSeries;
}}),
"[project]/node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/Geo3DBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'polygons3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this._geo3DBuilderList = [];
        this._currentStep = 0;
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
        }
        var geo3DBuilder = this._geo3DBuilderList[0];
        if (!geo3DBuilder) {
            geo3DBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](api);
            geo3DBuilder.extrudeY = coordSys.type !== 'mapbox3D' && coordSys.type !== 'maptalks3D';
            this._geo3DBuilderList[0] = geo3DBuilder;
        }
        this._updateShaderDefines(coordSys, geo3DBuilder);
        geo3DBuilder.update(seriesModel, ecModel, api);
        this._geo3DBuilderList.length = 1;
        this.groupGL.add(geo3DBuilder.rootNode);
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
        }
        this._currentStep = 0;
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
        var geo3DBuilder = this._geo3DBuilderList[this._currentStep];
        var coordSys = seriesModel.coordinateSystem;
        if (!geo3DBuilder) {
            geo3DBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](api);
            geo3DBuilder.extrudeY = coordSys.type !== 'mapbox3D' && coordSys.type !== 'maptalks3D';
            this._geo3DBuilderList[this._currentStep] = geo3DBuilder;
        }
        geo3DBuilder.update(seriesModel, ecModel, api, params.start, params.end);
        this.groupGL.add(geo3DBuilder.rootNode);
        this._updateShaderDefines(coordSys, geo3DBuilder);
        this._currentStep++;
    },
    _updateShaderDefines: function(coordSys, geo3DBuilder) {
        var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
        geo3DBuilder.rootNode.traverse(function(mesh) {
            if (mesh.material) {
                mesh.material[methodName]('fragment', 'SRGB_DECODE'); // FIXME
                if (coordSys.type === 'mapbox3D' || coordSys.type === 'maptalks3D') {
                    mesh.material.define('fragment', 'NORMAL_UP_AXIS', 2);
                    mesh.material.define('fragment', 'NORMAL_FRONT_AXIS', 1);
                }
            }
        });
    },
    remove: function() {
        this.groupGL.removeAll();
    },
    dispose: function() {
        this.groupGL.removeAll();
        this._geo3DBuilderList.forEach(function(geo3DBuilder) {
            geo3DBuilder.dispose();
        });
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/polygons3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$Polygons3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$Polygons3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$Polygons3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$Polygons3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/polygons3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/polygons3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/surface/SurfaceSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/number.js [app-client] (ecmascript) <export * as number>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/createList.js [app-client] (ecmascript)");
;
;
;
;
var SurfaceSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.surface',
    dependencies: [
        'globe',
        'grid3D',
        'geo3D'
    ],
    visualStyleAccessPath: 'itemStyle',
    formatTooltip: function(dataIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dataIndex);
    },
    getInitialData: function(option, ecModel) {
        var data = option.data;
        function validateDimension(dimOpts) {
            return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));
        }
        function getPrecision(dimOpts) {
            var getPrecision = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].getPrecisionSafe;
            return Math.max(getPrecision(dimOpts.min), getPrecision(dimOpts.max), getPrecision(dimOpts.step)) + 1;
        }
        if (!data) {
            if (!option.parametric) {
                // From surface equation
                var equation = option.equation || {};
                var xOpts = equation.x || {};
                var yOpts = equation.y || {};
                [
                    'x',
                    'y'
                ].forEach(function(dim) {
                    if (!validateDimension(equation[dim])) {
                        if ("TURBOPACK compile-time truthy", 1) {
                            console.error('Invalid equation.%s', dim);
                        }
                        return;
                    }
                });
                if (typeof equation.z !== 'function') {
                    if ("TURBOPACK compile-time truthy", 1) {
                        console.error('equation.z needs to be function');
                    }
                    return;
                }
                var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);
                var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);
                data = new Float32Array(xCount * yCount * 3);
                var xPrecision = getPrecision(xOpts);
                var yPrecision = getPrecision(yOpts);
                var off = 0;
                for(var j = 0; j < yCount; j++){
                    for(var i = 0; i < xCount; i++){
                        var x = i * xOpts.step + xOpts.min;
                        var y = j * yOpts.step + yOpts.min;
                        var x2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].round(Math.min(x, xOpts.max), xPrecision);
                        var y2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].round(Math.min(y, yOpts.max), yPrecision);
                        var z = equation.z(x2, y2);
                        data[off++] = x2;
                        data[off++] = y2;
                        data[off++] = z;
                    }
                }
            } else {
                var parametricEquation = option.parametricEquation || {};
                var uOpts = parametricEquation.u || {};
                var vOpts = parametricEquation.v || {};
                [
                    'u',
                    'v'
                ].forEach(function(dim) {
                    if (!validateDimension(parametricEquation[dim])) {
                        if ("TURBOPACK compile-time truthy", 1) {
                            console.error('Invalid parametricEquation.%s', dim);
                        }
                        return;
                    }
                });
                [
                    'x',
                    'y',
                    'z'
                ].forEach(function(dim) {
                    if (typeof parametricEquation[dim] !== 'function') {
                        if ("TURBOPACK compile-time truthy", 1) {
                            console.error('parametricEquation.%s needs to be function', dim);
                        }
                        return;
                    }
                });
                var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);
                var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);
                data = new Float32Array(uCount * vCount * 5);
                var uPrecision = getPrecision(uOpts);
                var vPrecision = getPrecision(vOpts);
                var off = 0;
                for(var j = 0; j < vCount; j++){
                    for(var i = 0; i < uCount; i++){
                        var u = i * uOpts.step + uOpts.min;
                        var v = j * vOpts.step + vOpts.min;
                        var u2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].round(Math.min(u, uOpts.max), uPrecision);
                        var v2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].round(Math.min(v, vOpts.max), vPrecision);
                        var x = parametricEquation.x(u2, v2);
                        var y = parametricEquation.y(u2, v2);
                        var z = parametricEquation.z(u2, v2);
                        data[off++] = x;
                        data[off++] = y;
                        data[off++] = z;
                        data[off++] = u2;
                        data[off++] = v2;
                    }
                }
            }
        }
        var dims = [
            'x',
            'y',
            'z'
        ];
        if (option.parametric) {
            dims.push('u', 'v');
        } // PENDING getSource?
        var list = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$createList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dims, data);
        return list;
    },
    defaultOption: {
        coordinateSystem: 'cartesian3D',
        zlevel: -10,
        // Cartesian coordinate system
        grid3DIndex: 0,
        // Surface needs lambert shading to show the difference
        shading: 'lambert',
        // If parametric surface
        parametric: false,
        wireframe: {
            show: true,
            lineStyle: {
                color: 'rgba(0,0,0,0.5)',
                width: 1
            }
        },
        /**
     * Generate surface data from z = f(x, y) equation
     */ equation: {
            // [min, max, step]
            x: {
                min: -1,
                max: 1,
                step: 0.1
            },
            y: {
                min: -1,
                max: 1,
                step: 0.1
            },
            z: null
        },
        parametricEquation: {
            // [min, max, step]
            u: {
                min: -1,
                max: 1,
                step: 0.1
            },
            v: {
                min: -1,
                max: 1,
                step: 0.1
            },
            // [x, y, z] = f(x, y)
            x: null,
            y: null,
            z: null
        },
        // Shape of give data
        // It is an array to specify rows and columns.
        // For example [30, 30]
        dataShape: null,
        itemStyle: {},
        animationDurationUpdate: 500
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(SurfaceSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = SurfaceSeries;
}}),
"[project]/node_modules/echarts-gl/lib/chart/surface/SurfaceView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/trianglesSortMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
;
;
;
;
;
var vec3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec3;
function isPointsNaN(pt) {
    return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);
}
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'surface',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
    },
    render: function(seriesModel, ecModel, api) {
        // Swap surfaceMesh
        var tmp = this._prevSurfaceMesh;
        this._prevSurfaceMesh = this._surfaceMesh;
        this._surfaceMesh = tmp;
        if (!this._surfaceMesh) {
            this._surfaceMesh = this._createSurfaceMesh();
        }
        this.groupGL.remove(this._prevSurfaceMesh);
        this.groupGL.add(this._surfaceMesh);
        var coordSys = seriesModel.coordinateSystem;
        var shading = seriesModel.get('shading');
        var data = seriesModel.getData();
        var shadingPrefix = 'ecgl.' + shading;
        if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {
            this._surfaceMesh.material = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createMaterial(shadingPrefix, [
                'VERTEX_COLOR',
                'DOUBLE_SIDED'
            ]);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);
        if (coordSys && coordSys.viewGL) {
            coordSys.viewGL.add(this.groupGL);
            var methodName = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
            this._surfaceMesh.material[methodName]('fragment', 'SRGB_DECODE');
        }
        var isParametric = seriesModel.get('parametric');
        var dataShape = seriesModel.get('dataShape');
        if (!dataShape) {
            dataShape = this._getDataShape(data, isParametric);
            if ("TURBOPACK compile-time truthy", 1) {
                if (seriesModel.get('data')) {
                    console.warn('dataShape is not provided. Guess it is ', dataShape);
                }
            }
        }
        var wireframeModel = seriesModel.getModel('wireframe');
        var wireframeLineWidth = wireframeModel.get('lineStyle.width');
        var showWireframe = wireframeModel.get('show') && wireframeLineWidth > 0;
        this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);
        var material = this._surfaceMesh.material;
        if (showWireframe) {
            material.define('WIREFRAME_QUAD');
            material.set('wireframeLineWidth', wireframeLineWidth);
            material.set('wireframeLineColor', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(wireframeModel.get('lineStyle.color')));
        } else {
            material.undefine('WIREFRAME_QUAD');
        }
        this._initHandler(seriesModel, api);
        this._updateAnimation(seriesModel);
    },
    _updateAnimation: function(seriesModel) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].updateVertexAnimation([
            [
                'prevPosition',
                'position'
            ],
            [
                'prevNormal',
                'normal'
            ]
        ], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);
    },
    _createSurfaceMesh: function() {
        var mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
                dynamic: true,
                sortTriangles: true
            }),
            shadowDepthMaterial: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.sm.depth.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.sm.depth.fragment'))
            }),
            culling: false,
            // Render after axes
            renderOrder: 10,
            // Render normal in normal pass
            renderNormal: true
        });
        mesh.geometry.createAttribute('barycentric', 'float', 4);
        mesh.geometry.createAttribute('prevPosition', 'float', 3);
        mesh.geometry.createAttribute('prevNormal', 'float', 3);
        Object.assign(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$trianglesSortMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
        return mesh;
    },
    _initHandler: function(seriesModel, api) {
        var data = seriesModel.getData();
        var surfaceMesh = this._surfaceMesh;
        var coordSys = seriesModel.coordinateSystem;
        function getNearestPointIdx(triangle, point) {
            var nearestDist = Infinity;
            var nearestIdx = -1;
            var pos = [];
            for(var i = 0; i < triangle.length; i++){
                surfaceMesh.geometry.attributes.position.get(triangle[i], pos);
                var dist = vec3.dist(point.array, pos);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestIdx = triangle[i];
                }
            }
            return nearestIdx;
        }
        surfaceMesh.seriesIndex = seriesModel.seriesIndex;
        var lastDataIndex = -1;
        surfaceMesh.off('mousemove');
        surfaceMesh.off('mouseout');
        surfaceMesh.on('mousemove', function(e) {
            var idx = getNearestPointIdx(e.triangle, e.point);
            if (idx >= 0) {
                var point = [];
                surfaceMesh.geometry.attributes.position.get(idx, point);
                var value = coordSys.pointToData(point);
                var minDist = Infinity;
                var dataIndex = -1;
                var item = [];
                for(var i = 0; i < data.count(); i++){
                    item[0] = data.get('x', i);
                    item[1] = data.get('y', i);
                    item[2] = data.get('z', i);
                    var dist = vec3.squaredDistance(item, value);
                    if (dist < minDist) {
                        dataIndex = i;
                        minDist = dist;
                    }
                }
                if (dataIndex !== lastDataIndex) {
                    api.dispatchAction({
                        type: 'grid3DShowAxisPointer',
                        value: value
                    });
                }
                lastDataIndex = dataIndex;
                surfaceMesh.dataIndex = dataIndex;
            } else {
                surfaceMesh.dataIndex = -1;
            }
        }, this);
        surfaceMesh.on('mouseout', function(e) {
            lastDataIndex = -1;
            surfaceMesh.dataIndex = -1;
            api.dispatchAction({
                type: 'grid3DHideAxisPointer'
            });
        }, this);
    },
    _updateSurfaceMesh: function(surfaceMesh, seriesModel, dataShape, showWireframe) {
        var geometry = surfaceMesh.geometry;
        var data = seriesModel.getData();
        var pointsArr = data.getLayout('points');
        var invalidDataCount = 0;
        data.each(function(idx) {
            if (!data.hasValue(idx)) {
                invalidDataCount++;
            }
        });
        var needsSplitQuad = invalidDataCount || showWireframe;
        var positionAttr = geometry.attributes.position;
        var normalAttr = geometry.attributes.normal;
        var texcoordAttr = geometry.attributes.texcoord0;
        var barycentricAttr = geometry.attributes.barycentric;
        var colorAttr = geometry.attributes.color;
        var row = dataShape[0];
        var column = dataShape[1];
        var shading = seriesModel.get('shading');
        var needsNormal = shading !== 'color';
        if (needsSplitQuad) {
            // TODO, If needs remove the invalid points, or set color transparent.
            var vertexCount = (row - 1) * (column - 1) * 4;
            positionAttr.init(vertexCount);
            if (showWireframe) {
                barycentricAttr.init(vertexCount);
            }
        } else {
            positionAttr.value = new Float32Array(pointsArr);
        }
        colorAttr.init(geometry.vertexCount);
        texcoordAttr.init(geometry.vertexCount);
        var quadToTriangle = [
            0,
            3,
            1,
            1,
            3,
            2
        ]; // 3----2
        // 0----1
        // Make sure pixels on 1---3 edge will not have channel 0.
        // And pixels on four edges have at least one channel 0.
        var quadBarycentric = [
            [
                1,
                1,
                0,
                0
            ],
            [
                0,
                1,
                0,
                1
            ],
            [
                1,
                0,
                0,
                1
            ],
            [
                1,
                0,
                1,
                0
            ]
        ];
        var indices = geometry.indices = new (geometry.vertexCount > 0xffff ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);
        var getQuadIndices = function(i, j, out) {
            out[1] = i * column + j;
            out[0] = i * column + j + 1;
            out[3] = (i + 1) * column + j + 1;
            out[2] = (i + 1) * column + j;
        };
        var isTransparent = false;
        if (needsSplitQuad) {
            var quadIndices = [];
            var pos = [];
            var faceOffset = 0;
            if (needsNormal) {
                normalAttr.init(geometry.vertexCount);
            } else {
                normalAttr.value = null;
            }
            var pts = [
                [],
                [],
                []
            ];
            var v21 = [], v32 = [];
            var normal = vec3.create();
            var getFromArray = function(arr, idx, out) {
                var idx3 = idx * 3;
                out[0] = arr[idx3];
                out[1] = arr[idx3 + 1];
                out[2] = arr[idx3 + 2];
                return out;
            };
            var vertexNormals = new Float32Array(pointsArr.length);
            var vertexColors = new Float32Array(pointsArr.length / 3 * 4);
            for(var i = 0; i < data.count(); i++){
                if (data.hasValue(i)) {
                    var rgbaArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, i));
                    var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, i);
                    opacity != null && (rgbaArr[3] *= opacity);
                    if (rgbaArr[3] < 0.99) {
                        isTransparent = true;
                    }
                    for(var k = 0; k < 4; k++){
                        vertexColors[i * 4 + k] = rgbaArr[k];
                    }
                }
            }
            var farPoints = [
                1e7,
                1e7,
                1e7
            ];
            for(var i = 0; i < row - 1; i++){
                for(var j = 0; j < column - 1; j++){
                    var dataIndex = i * (column - 1) + j;
                    var vertexOffset = dataIndex * 4;
                    getQuadIndices(i, j, quadIndices);
                    var invisibleQuad = false;
                    for(var k = 0; k < 4; k++){
                        getFromArray(pointsArr, quadIndices[k], pos);
                        if (isPointsNaN(pos)) {
                            // Quad is invisible if any point is NaN
                            invisibleQuad = true;
                        }
                    }
                    for(var k = 0; k < 4; k++){
                        if (invisibleQuad) {
                            // Move point far away
                            positionAttr.set(vertexOffset + k, farPoints);
                        } else {
                            getFromArray(pointsArr, quadIndices[k], pos);
                            positionAttr.set(vertexOffset + k, pos);
                        }
                        if (showWireframe) {
                            barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);
                        }
                    }
                    for(var k = 0; k < 6; k++){
                        indices[faceOffset++] = quadToTriangle[k] + vertexOffset;
                    } // Vertex normals
                    if (needsNormal && !invisibleQuad) {
                        for(var k = 0; k < 2; k++){
                            var k3 = k * 3;
                            for(var m = 0; m < 3; m++){
                                var idx = quadIndices[quadToTriangle[k3] + m];
                                getFromArray(pointsArr, idx, pts[m]);
                            }
                            vec3.sub(v21, pts[0], pts[1]);
                            vec3.sub(v32, pts[1], pts[2]);
                            vec3.cross(normal, v21, v32); // Weighted by the triangle area
                            for(var m = 0; m < 3; m++){
                                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;
                                vertexNormals[idx3] = vertexNormals[idx3] + normal[0];
                                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal[1];
                                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal[2];
                            }
                        }
                    }
                }
            }
            if (needsNormal) {
                for(var i = 0; i < vertexNormals.length / 3; i++){
                    getFromArray(vertexNormals, i, normal);
                    vec3.normalize(normal, normal);
                    vertexNormals[i * 3] = normal[0];
                    vertexNormals[i * 3 + 1] = normal[1];
                    vertexNormals[i * 3 + 2] = normal[2];
                }
            } // Split normal and colors, write to the attributes.
            var rgbaArr = [];
            var uvArr = [];
            for(var i = 0; i < row - 1; i++){
                for(var j = 0; j < column - 1; j++){
                    var dataIndex = i * (column - 1) + j;
                    var vertexOffset = dataIndex * 4;
                    getQuadIndices(i, j, quadIndices);
                    for(var k = 0; k < 4; k++){
                        for(var m = 0; m < 4; m++){
                            rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];
                        }
                        colorAttr.set(vertexOffset + k, rgbaArr);
                        if (needsNormal) {
                            getFromArray(vertexNormals, quadIndices[k], normal);
                            normalAttr.set(vertexOffset + k, normal);
                        }
                        var idx = quadIndices[k];
                        uvArr[0] = idx % column / (column - 1);
                        uvArr[1] = Math.floor(idx / column) / (row - 1);
                        texcoordAttr.set(vertexOffset + k, uvArr);
                    }
                    dataIndex++;
                }
            }
        } else {
            var uvArr = [];
            for(var i = 0; i < data.count(); i++){
                uvArr[0] = i % column / (column - 1);
                uvArr[1] = Math.floor(i / column) / (row - 1);
                var rgbaArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, i));
                var opacity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, i);
                opacity != null && (rgbaArr[3] *= opacity);
                if (rgbaArr[3] < 0.99) {
                    isTransparent = true;
                }
                colorAttr.set(i, rgbaArr);
                texcoordAttr.set(i, uvArr);
            }
            var quadIndices = []; // Triangles
            var cursor = 0;
            for(var i = 0; i < row - 1; i++){
                for(var j = 0; j < column - 1; j++){
                    getQuadIndices(i, j, quadIndices);
                    for(var k = 0; k < 6; k++){
                        indices[cursor++] = quadIndices[quadToTriangle[k]];
                    }
                }
            }
            if (needsNormal) {
                geometry.generateVertexNormals();
            } else {
                normalAttr.value = null;
            }
        }
        if (surfaceMesh.material.get('normalMap')) {
            geometry.generateTangents();
        }
        geometry.updateBoundingBox();
        geometry.dirty();
        surfaceMesh.material.transparent = isTransparent;
        surfaceMesh.material.depthMask = !isTransparent;
    },
    _getDataShape: function(data, isParametric) {
        var prevX = -Infinity;
        var rowCount = 0;
        var columnCount = 0;
        var prevColumnCount = 0;
        var mayInvalid = false;
        var rowDim = isParametric ? 'u' : 'x';
        var dataCount = data.count(); // Check data format
        for(var i = 0; i < dataCount; i++){
            var x = data.get(rowDim, i);
            if (x < prevX) {
                if (prevColumnCount && prevColumnCount !== columnCount) {
                    if (("TURBOPACK compile-time value", "development") !== 'production') {
                        mayInvalid = true;
                    }
                } // A new row.
                prevColumnCount = columnCount;
                columnCount = 0;
                rowCount++;
            }
            prevX = x;
            columnCount++;
        }
        if (!rowCount || columnCount === 1) {
            mayInvalid = true;
        }
        if (!mayInvalid) {
            return [
                rowCount + 1,
                columnCount
            ];
        }
        var rows = Math.floor(Math.sqrt(dataCount));
        while(rows > 0){
            if (Math.floor(dataCount / rows) === dataCount / rows) {
                // Can be divided
                return [
                    rows,
                    dataCount / rows
                ];
            }
            rows--;
        } // Bailout
        rows = Math.floor(Math.sqrt(dataCount));
        return [
            rows,
            rows
        ];
    },
    dispose: function() {
        this.groupGL.removeAll();
    },
    remove: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/surface/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$SurfaceSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/surface/SurfaceSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$SurfaceView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/surface/SurfaceView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$SurfaceView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$SurfaceSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerLayout(function(ecModel, api) {
        ecModel.eachSeriesByType('surface', function(surfaceModel) {
            var cartesian = surfaceModel.coordinateSystem;
            if (!cartesian || cartesian.type !== 'cartesian3D') {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.error('Surface chart only support cartesian3D coordinateSystem');
                }
            }
            var data = surfaceModel.getData();
            var points = new Float32Array(3 * data.count());
            var nanPoint = [
                NaN,
                NaN,
                NaN
            ];
            if (cartesian && cartesian.type === 'cartesian3D') {
                var coordDims = cartesian.dimensions;
                var dims = coordDims.map(function(coordDim) {
                    return surfaceModel.coordDimToDataDim(coordDim)[0];
                });
                data.each(dims, function(x, y, z, idx) {
                    var pt;
                    if (!data.hasValue(idx)) {
                        pt = nanPoint;
                    } else {
                        pt = cartesian.dataToPoint([
                            x,
                            y,
                            z
                        ]);
                    }
                    points[idx * 3] = pt[0];
                    points[idx * 3 + 1] = pt[1];
                    points[idx * 3 + 2] = pt[2];
                });
            }
            data.setLayout('points', points);
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/surface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/surface/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/map3D/Map3DSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Model.js [app-client] (ecmascript) <export default as Model>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentViewControlMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentPostEffectMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentLightMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/componentShadingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$geo3DModelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/geo3D/geo3DModelMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/formatTooltip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/coord/geo3DCreator.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
function transformPolygon(mapbox3DCoordSys, poly) {
    var newPoly = [];
    for(var k = 0; k < poly.length; k++){
        newPoly.push(mapbox3DCoordSys.dataToPoint(poly[k]));
    }
    return newPoly;
}
var Map3DSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.map3D',
    layoutMode: 'box',
    coordinateSystem: null,
    visualStyleAccessPath: 'itemStyle',
    optionUpdated: function(newOpt) {
        newOpt = newOpt || {};
        var coordSysType = this.get('coordinateSystem');
        if (coordSysType == null || coordSysType === 'geo3D') {
            return;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            var propsNeedToCheck = [
                'left',
                'top',
                'width',
                'height',
                'boxWidth',
                'boxDepth',
                'boxHeight',
                'light',
                'viewControl',
                'postEffect',
                'temporalSuperSampling',
                'environment',
                'groundPlane'
            ];
            var ignoredProperties = [];
            propsNeedToCheck.forEach(function(propName) {
                if (newOpt[propName] != null) {
                    ignoredProperties.push(propName);
                }
            });
            if (ignoredProperties.length) {
                console.warn('Property %s in map3D series will be ignored if coordinate system is %s', ignoredProperties.join(', '), coordSysType);
            }
        }
        if (this.get('groundPlane.show')) {
            // Force disable groundPlane if map3D has other coordinate systems.
            this.option.groundPlane.show = false;
        } // Reset geo.
        this._geo = null;
    },
    getInitialData: function(option) {
        option.data = this.getFilledRegions(option.data, option.map);
        var dimensions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createDimensions(option.data, {
            coordDimensions: [
                'value'
            ]
        });
        var list = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"](dimensions, this);
        list.initData(option.data);
        var regionModelMap = {};
        list.each(function(idx) {
            var name = list.getName(idx);
            var itemModel = list.getItemModel(idx);
            regionModelMap[name] = itemModel;
        });
        this._regionModelMap = regionModelMap;
        return list;
    },
    formatTooltip: function(dataIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$formatTooltip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this, dataIndex);
    },
    getRegionModel: function(idx) {
        var name = this.getData().getName(idx);
        return this._regionModelMap[name] || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__Model$3e$__["Model"](null, this);
    },
    getRegionPolygonCoords: function(idx) {
        var coordSys = this.coordinateSystem;
        var name = this.getData().getName(idx);
        if (coordSys.transform) {
            var region = coordSys.getRegion(name);
            return region ? region.geometries : [];
        } else {
            if (!this._geo) {
                this._geo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3DCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createGeo3D(this);
            }
            var region = this._geo.getRegion(name);
            var ret = [];
            for(var k = 0; k < region.geometries.length; k++){
                var geo = region.geometries[k];
                var interiors = [];
                var exterior = transformPolygon(coordSys, geo.exterior);
                if (interiors && interiors.length) {
                    for(var m = 0; m < geo.interiors.length; m++){
                        interiors.push(transformPolygon(coordSys, interiors[m]));
                    }
                }
                ret.push({
                    interiors: interiors,
                    exterior: exterior
                });
            }
            return ret;
        }
    },
    /**
   * Format label
   * @param {string} name Region name
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @return {string}
   */ getFormattedLabel: function(dataIndex, status) {
        var text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getFormattedLabel(this, dataIndex, status);
        if (text == null) {
            text = this.getData().getName(dataIndex);
        }
        return text;
    },
    defaultOption: {
        // Support geo3D, mapbox, maptalks3D
        coordinateSystem: 'geo3D',
        // itemStyle: {},
        // height,
        // label: {}
        data: null
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Map3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$coord$2f$geo3D$2f$geo3DModelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Map3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentViewControlMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Map3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentPostEffectMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Map3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentLightMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].merge(Map3DSeries.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$componentShadingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = Map3DSeries;
}}),
"[project]/node_modules/echarts-gl/lib/chart/map3D/Map3DView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/OrbitControl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/SceneHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/common/Geo3DBuilder.js [app-client] (ecmascript)");
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'map3D',
    __ecgl__: true,
    init: function(ecModel, api) {
        this._geo3DBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$Geo3DBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](api);
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
    },
    render: function(map3DModel, ecModel, api) {
        var coordSys = map3DModel.coordinateSystem;
        if (!coordSys || !coordSys.viewGL) {
            return;
        }
        this.groupGL.add(this._geo3DBuilder.rootNode);
        coordSys.viewGL.add(this.groupGL);
        var geo3D;
        if (coordSys.type === 'geo3D') {
            geo3D = coordSys;
            if (!this._sceneHelper) {
                this._sceneHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$common$2f$SceneHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                this._sceneHelper.initLight(this.groupGL);
            }
            this._sceneHelper.setScene(coordSys.viewGL.scene);
            this._sceneHelper.updateLight(map3DModel); // Set post effect
            coordSys.viewGL.setPostEffect(map3DModel.getModel('postEffect'), api);
            coordSys.viewGL.setTemporalSuperSampling(map3DModel.getModel('temporalSuperSampling'));
            var control = this._control;
            if (!control) {
                control = this._control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$OrbitControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                    zr: api.getZr()
                });
                this._control.init();
            }
            var viewControlModel = map3DModel.getModel('viewControl');
            control.setViewGL(coordSys.viewGL);
            control.setFromViewControlModel(viewControlModel, 0);
            control.off('update');
            control.on('update', function() {
                api.dispatchAction({
                    type: 'map3DChangeCamera',
                    alpha: control.getAlpha(),
                    beta: control.getBeta(),
                    distance: control.getDistance(),
                    from: this.uid,
                    map3DId: map3DModel.id
                });
            });
            this._geo3DBuilder.extrudeY = true;
        } else {
            if (this._control) {
                this._control.dispose();
                this._control = null;
            }
            if (this._sceneHelper) {
                this._sceneHelper.dispose();
                this._sceneHelper = null;
            }
            geo3D = map3DModel.getData().getLayout('geo3D');
            this._geo3DBuilder.extrudeY = false;
        }
        this._geo3DBuilder.update(map3DModel, ecModel, api, 0, map3DModel.getData().count()); // Must update after geo3D.viewGL.setPostEffect to determine linear space
        var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? 'define' : 'undefine';
        this._geo3DBuilder.rootNode.traverse(function(mesh) {
            if (mesh.material) {
                mesh.material[srgbDefineMethod]('fragment', 'SRGB_DECODE');
            }
        });
    },
    afterRender: function(map3DModel, ecModel, api, layerGL) {
        var renderer = layerGL.renderer;
        var coordSys = map3DModel.coordinateSystem;
        if (coordSys && coordSys.type === 'geo3D') {
            this._sceneHelper.updateAmbientCubemap(renderer, map3DModel, api);
            this._sceneHelper.updateSkybox(renderer, map3DModel, api);
        }
    },
    dispose: function() {
        this.groupGL.removeAll();
        this._control.dispose();
        this._geo3DBuilder.dispose();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/map3D/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$Map3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/map3D/Map3DSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$Map3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/map3D/Map3DView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/geo3D/install.js [app-client] (ecmascript)");
;
;
;
;
function install(registers) {
    // Depends on geo3d
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"])(registers);
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$Map3DView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$Map3DSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerAction({
        type: 'map3DChangeCamera',
        event: 'map3dcamerachanged',
        update: 'series:updateCamera'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'series',
            subType: 'map3D',
            query: payload
        }, function(componentModel) {
            componentModel.setView(payload);
        });
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/map3D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/map3D/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.scatterGL',
    dependencies: [
        'grid',
        'polar',
        'geo',
        'singleAxis'
    ],
    visualStyleAccessPath: 'itemStyle',
    hasSymbolVisual: true,
    getInitialData: function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createList(this);
    },
    defaultOption: {
        coordinateSystem: 'cartesian2d',
        zlevel: 10,
        progressive: 1e5,
        progressiveThreshold: 1e5,
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        large: false,
        symbol: 'circle',
        symbolSize: 10,
        // symbolSize scale when zooming.
        zoomScale: 0,
        // Support source-over, lighter
        blendMode: 'source-over',
        itemStyle: {
            opacity: 0.8
        },
        postEffect: {
            enable: false,
            colorCorrection: {
                exposure: 0,
                brightness: 0,
                contrast: 1,
                saturation: 1,
                enable: true
            }
        }
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/common/GLViewHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/core/matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/core/vector.js [app-client] (ecmascript)");
;
;
function GLViewHelper(viewGL) {
    this.viewGL = viewGL;
}
GLViewHelper.prototype.reset = function(seriesModel, api) {
    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
    this._viewTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    this.updateTransform(seriesModel, api);
};
GLViewHelper.prototype.updateTransform = function(seriesModel, api) {
    var coordinateSystem = seriesModel.coordinateSystem;
    if (coordinateSystem.getRoamTransform) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invert"])(this._viewTransform, coordinateSystem.getRoamTransform());
        this._setCameraTransform(this._viewTransform);
        api.getZr().refresh();
    }
}; // Reimplement the dataToPoint of coordinate system.
// Remove the effect of pan/zoom transform
GLViewHelper.prototype.dataToPoint = function(coordSys, data, pt) {
    pt = coordSys.dataToPoint(data, null, pt);
    var viewTransform = this._viewTransform;
    if (viewTransform) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyTransform"])(pt, pt, viewTransform);
    }
};
/**
 * Remove transform info in point.
 */ GLViewHelper.prototype.removeTransformInPoint = function(pt) {
    if (this._viewTransform) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyTransform"])(pt, pt, this._viewTransform);
    }
    return pt;
};
/**
 * Return number
 */ GLViewHelper.prototype.getZoom = function() {
    if (this._viewTransform) {
        var m = this._viewTransform;
        return 1 / Math.max(Math.sqrt(m[0] * m[0] + m[1] * m[1]), Math.sqrt(m[2] * m[2] + m[3] * m[3]));
    }
    return 1;
};
GLViewHelper.prototype._setCameraTransform = function(m) {
    var camera = this.viewGL.camera;
    camera.position.set(m[4], m[5], 0);
    camera.scale.set(Math.sqrt(m[0] * m[0] + m[1] * m[1]), Math.sqrt(m[2] * m[2] + m[3] * m[3]), 1);
};
GLViewHelper.prototype._updateCamera = function(width, height, dpr) {
    // TODO, left, top, right, bottom
    this.viewGL.setViewport(0, 0, width, height, dpr);
    var camera = this.viewGL.camera;
    camera.left = camera.top = 0;
    camera.bottom = height;
    camera.right = width;
    camera.near = 0;
    camera.far = 100;
};
const __TURBOPACK__default__export__ = GLViewHelper;
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/PointsBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$GLViewHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/GLViewHelper.js [app-client] (ecmascript)");
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'scatterGL',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this.viewGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('orthographic');
        this.viewGL.add(this.groupGL);
        this._pointsBuilderList = [];
        this._currentStep = 0;
        this._sizeScale = 1;
        this._glViewHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$GLViewHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.viewGL);
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        this._glViewHelper.reset(seriesModel, api);
        if (!seriesModel.getData().count()) {
            return;
        }
        var pointsBuilder = this._pointsBuilderList[0];
        if (!pointsBuilder) {
            pointsBuilder = this._pointsBuilderList[0] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](true, api);
        }
        this._pointsBuilderList.length = 1;
        this.groupGL.add(pointsBuilder.rootNode);
        this._removeTransformInPoints(seriesModel.getData().getLayout('points'));
        pointsBuilder.update(seriesModel, ecModel, api);
        this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        this._glViewHelper.reset(seriesModel, api);
        this._currentStep = 0;
        this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
        if (params.end <= params.start) {
            return;
        }
        var pointsBuilder = this._pointsBuilderList[this._currentStep];
        if (!pointsBuilder) {
            pointsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](true, api);
            this._pointsBuilderList[this._currentStep] = pointsBuilder;
        }
        this.groupGL.add(pointsBuilder.rootNode);
        this._removeTransformInPoints(seriesModel.getData().getLayout('points'));
        pointsBuilder.setSizeScale(this._sizeScale);
        pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
        api.getZr().refresh();
        this._currentStep++;
    },
    updateTransform: function(seriesModel, ecModel, api) {
        if (seriesModel.coordinateSystem.getRoamTransform) {
            this._glViewHelper.updateTransform(seriesModel, api);
            var zoom = this._glViewHelper.getZoom();
            var sizeScale = Math.max((seriesModel.get('zoomScale') || 0) * (zoom - 1) + 1, 0);
            this._sizeScale = sizeScale;
            this._pointsBuilderList.forEach(function(pointsBuilder) {
                pointsBuilder.setSizeScale(sizeScale);
            });
        }
    },
    _removeTransformInPoints: function(points) {
        if (!points) {
            return;
        }
        var pt = [];
        for(var i = 0; i < points.length; i += 2){
            pt[0] = points[i];
            pt[1] = points[i + 1];
            this._glViewHelper.removeTransformInPoint(pt);
            points[i] = pt[0];
            points[i + 1] = pt[1];
        }
    },
    dispose: function() {
        this.groupGL.removeAll();
        this._pointsBuilderList.forEach(function(pointsBuilder) {
            pointsBuilder.dispose();
        });
    },
    remove: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatterGL/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$ScatterGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$ScatterGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$ScatterGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$ScatterGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerLayout({
        seriesType: 'scatterGL',
        reset: function(seriesModel) {
            var coordSys = seriesModel.coordinateSystem;
            var data = seriesModel.getData();
            var progress;
            if (coordSys) {
                var dims = coordSys.dimensions.map(function(dim) {
                    return data.mapDimension(dim);
                }).slice(0, 2);
                var pt = [];
                if (dims.length === 1) {
                    progress = function(params) {
                        var points = new Float32Array((params.end - params.start) * 2);
                        for(var idx = params.start; idx < params.end; idx++){
                            var offset = (idx - params.start) * 2;
                            var x = data.get(dims[0], idx);
                            var pt = coordSys.dataToPoint(x);
                            points[offset] = pt[0];
                            points[offset + 1] = pt[1];
                        }
                        data.setLayout('points', points);
                    };
                } else if (dims.length === 2) {
                    progress = function(params) {
                        var points = new Float32Array((params.end - params.start) * 2);
                        for(var idx = params.start; idx < params.end; idx++){
                            var offset = (idx - params.start) * 2;
                            var x = data.get(dims[0], idx);
                            var y = data.get(dims[1], idx);
                            pt[0] = x;
                            pt[1] = y;
                            pt = coordSys.dataToPoint(pt);
                            points[offset] = pt[0];
                            points[offset + 1] = pt[1];
                        }
                        data.setLayout('points', points);
                    };
                }
            }
            return {
                progress: progress
            };
        }
    });
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/scatterGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatterGL/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/createGraphFromNodeEdge.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$Graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/Graph.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$helper$2f$linkList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/helper/linkList.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
;
;
;
;
function __TURBOPACK__default__export__(nodes, edges, hostModel, directed, beforeLink) {
    var graph = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$Graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](directed);
    for(var i = 0; i < nodes.length; i++){
        graph.addNode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(nodes[i].id, nodes[i].name, i), i);
    }
    var linkNameList = [];
    var validEdges = [];
    var linkCount = 0;
    for(var i = 0; i < edges.length; i++){
        var link = edges[i];
        var source = link.source;
        var target = link.target; // addEdge may fail when source or target not exists
        if (graph.addEdge(source, target, linkCount)) {
            validEdges.push(link);
            linkNameList.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(link.id, source + ' > ' + target));
            linkCount++;
        }
    }
    var nodeData; // FIXME, support more coordinate systems.
    var dimensionNames = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createDimensions(nodes, {
        coordDimensions: [
            'value'
        ]
    });
    nodeData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"](dimensionNames, hostModel);
    nodeData.initData(nodes);
    var edgeData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"]([
        'value'
    ], hostModel);
    edgeData.initData(validEdges, linkNameList);
    beforeLink && beforeLink(nodeData, edgeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$helper$2f$linkList$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
        mainData: nodeData,
        struct: graph,
        structAttr: 'graph',
        datas: {
            node: nodeData,
            edge: edgeData
        },
        datasAttr: {
            node: 'data',
            edge: 'edgeData'
        }
    }); // Update dataIndex of nodes and edges because invalid edge may be removed
    graph.update();
    return graph;
}
;
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/GraphGLSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/format.js [app-client] (ecmascript) <export * as format>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$createGraphFromNodeEdge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/createGraphFromNodeEdge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/format.js [app-client] (ecmascript)");
;
;
;
var GraphSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.graphGL',
    visualStyleAccessPath: 'itemStyle',
    hasSymbolVisual: true,
    init: function(option) {
        GraphSeries.superApply(this, 'init', arguments); // Provide data for legend select
        this.legendDataProvider = function() {
            return this._categoriesData;
        };
        this._updateCategoriesData();
    },
    mergeOption: function(option) {
        GraphSeries.superApply(this, 'mergeOption', arguments);
        this._updateCategoriesData();
    },
    getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
        var text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
        if (text == null) {
            var data = this.getData();
            var lastDim = data.dimensions[data.dimensions.length - 1];
            text = data.get(lastDim, dataIndex);
        }
        return text;
    },
    getInitialData: function(option, ecModel) {
        var edges = option.edges || option.links || [];
        var nodes = option.data || option.nodes || [];
        var self = this;
        if ("TURBOPACK compile-time truthy", 1) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$createGraphFromNodeEdge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nodes, edges, this, true, beforeLink).data;
        }
        "TURBOPACK unreachable";
        function beforeLink(nodeData, edgeData) {
            // Overwrite nodeData.getItemModel to
            nodeData.wrapMethod('getItemModel', function(model) {
                const categoriesModels = self._categoriesModels;
                const categoryIdx = model.getShallow('category');
                const categoryModel = categoriesModels[categoryIdx];
                if (categoryModel) {
                    categoryModel.parentModel = model.parentModel;
                    model.parentModel = categoryModel;
                }
                return model;
            }); // TODO Inherit resolveParentPath by default in Model#getModel?
            const oldGetModel = ecModel.getModel([]).getModel;
            function newGetModel(path, parentModel) {
                const model = oldGetModel.call(this, path, parentModel);
                model.resolveParentPath = resolveParentPath;
                return model;
            }
            edgeData.wrapMethod('getItemModel', function(model) {
                model.resolveParentPath = resolveParentPath;
                model.getModel = newGetModel;
                return model;
            });
            function resolveParentPath(pathArr) {
                if (pathArr && (pathArr[0] === 'label' || pathArr[1] === 'label')) {
                    const newPathArr = pathArr.slice();
                    if (pathArr[0] === 'label') {
                        newPathArr[0] = 'edgeLabel';
                    } else if (pathArr[1] === 'label') {
                        newPathArr[1] = 'edgeLabel';
                    }
                    return newPathArr;
                }
                return pathArr;
            }
        }
    },
    /**
   * @return {module:echarts/data/Graph}
   */ getGraph: function() {
        return this.getData().graph;
    },
    /**
   * @return {module:echarts/data/List}
   */ getEdgeData: function() {
        return this.getGraph().edgeData;
    },
    /**
   * @return {module:echarts/data/List}
   */ getCategoriesData: function() {
        return this._categoriesData;
    },
    /**
   * @override
   */ formatTooltip: function(dataIndex, multipleSeries, dataType) {
        if (dataType === 'edge') {
            var nodeData = this.getData();
            var params = this.getDataParams(dataIndex, dataType);
            var edge = nodeData.graph.getEdgeByIndex(dataIndex);
            var sourceName = nodeData.getName(edge.node1.dataIndex);
            var targetName = nodeData.getName(edge.node2.dataIndex);
            var html = [];
            sourceName != null && html.push(sourceName);
            targetName != null && html.push(targetName);
            html = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(html.join(' > '));
            if (params.value) {
                html += ' : ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__format$3e$__["format"].encodeHTML(params.value);
            }
            return html;
        } else {
            // dataType === 'node' or empty
            return GraphSeries.superApply(this, 'formatTooltip', arguments);
        }
    },
    _updateCategoriesData: function() {
        var categories = (this.option.categories || []).map(function(category) {
            // Data must has value
            return category.value != null ? category : Object.assign({
                value: 0
            }, category);
        });
        var categoriesData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"]([
            'value'
        ], this);
        categoriesData.initData(categories);
        this._categoriesData = categoriesData;
        this._categoriesModels = categoriesData.mapArray(function(idx) {
            return categoriesData.getItemModel(idx, true);
        });
    },
    setView: function(payload) {
        if (payload.zoom != null) {
            this.option.zoom = payload.zoom;
        }
        if (payload.offset != null) {
            this.option.offset = payload.offset;
        }
    },
    setNodePosition: function(points) {
        for(var i = 0; i < points.length / 2; i++){
            var x = points[i * 2];
            var y = points[i * 2 + 1];
            var opt = this.getData().getRawDataItem(i);
            opt.x = x;
            opt.y = y;
        }
    },
    isAnimationEnabled: function() {
        return GraphSeries.superCall(this, 'isAnimationEnabled') // Not enable animation when do force layout
         && !(this.get('layout') === 'force' && this.get('force.layoutAnimation'));
    },
    defaultOption: {
        zlevel: 10,
        z: 2,
        legendHoverLink: true,
        // Only support forceAtlas2
        layout: 'forceAtlas2',
        // Configuration of force directed layout
        forceAtlas2: {
            initLayout: null,
            GPU: true,
            steps: 1,
            // barnesHutOptimize
            // Maxp layout steps.
            maxSteps: 1000,
            repulsionByDegree: true,
            linLogMode: false,
            strongGravityMode: false,
            gravity: 1.0,
            // scaling: 1.0,
            edgeWeightInfluence: 1.0,
            // Edge weight range.
            edgeWeight: [
                1,
                4
            ],
            // Node weight range.
            nodeWeight: [
                1,
                4
            ],
            // jitterTolerence: 0.1,
            preventOverlap: false,
            gravityCenter: null
        },
        focusNodeAdjacency: true,
        focusNodeAdjacencyOn: 'mouseover',
        left: 'center',
        top: 'center',
        // right: null,
        // bottom: null,
        // width: '80%',
        // height: '80%',
        symbol: 'circle',
        symbolSize: 5,
        roam: false,
        // Default on center of graph
        center: null,
        zoom: 1,
        // categories: [],
        // data: []
        // Or
        // nodes: []
        //
        // links: []
        // Or
        // edges: []
        label: {
            show: false,
            formatter: '{b}',
            position: 'right',
            distance: 5,
            textStyle: {
                fontSize: 14
            }
        },
        itemStyle: {},
        lineStyle: {
            color: '#aaa',
            width: 1,
            opacity: 0.5
        },
        emphasis: {
            label: {
                show: true
            }
        },
        animation: false
    }
});
const __TURBOPACK__default__export__ = GraphSeries;
}}),
"[project]/node_modules/echarts-gl/lib/util/geometry/Lines2D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Lines geometry
 * Use screen space projected lines lineWidth > MAX_LINE_WIDTH
 * https://mattdesl.svbtle.com/drawing-lines-is-hard
 * @module echarts-gl/util/geometry/LinesGeometry
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/dynamicConvertMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
;
;
;
;
var vec2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec2; // var CURVE_RECURSION_LIMIT = 8;
// var CURVE_COLLINEAR_EPSILON = 40;
var sampleLinePoints = [
    [
        0,
        0
    ],
    [
        1,
        1
    ]
];
/**
 * @constructor
 * @alias module:echarts-gl/util/geometry/LinesGeometry
 * @extends clay.Geometry
 */ var LinesGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        segmentScale: 4,
        dynamic: true,
        /**
     * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH
     */ useNativeLine: true,
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 2, 'POSITION'),
            normal: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('normal', 'float', 2),
            offset: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('offset', 'float', 1),
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('color', 'float', 4, 'COLOR')
        }
    };
}, /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */ {
    /**
   * Reset offset
   */ resetOffset: function() {
        this._vertexOffset = 0;
        this._faceOffset = 0;
        this._itemVertexOffsets = [];
    },
    /**
   * @param {number} nVertex
   */ setVertexCount: function(nVertex) {
        var attributes = this.attributes;
        if (this.vertexCount !== nVertex) {
            attributes.position.init(nVertex);
            attributes.color.init(nVertex);
            if (!this.useNativeLine) {
                attributes.offset.init(nVertex);
                attributes.normal.init(nVertex);
            }
            if (nVertex > 0xffff) {
                if (this.indices instanceof Uint16Array) {
                    this.indices = new Uint32Array(this.indices);
                }
            } else {
                if (this.indices instanceof Uint32Array) {
                    this.indices = new Uint16Array(this.indices);
                }
            }
        }
    },
    /**
   * @param {number} nTriangle
   */ setTriangleCount: function(nTriangle) {
        if (this.triangleCount !== nTriangle) {
            if (nTriangle === 0) {
                this.indices = null;
            } else {
                this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
            }
        }
    },
    _getCubicCurveApproxStep: function(p0, p1, p2, p3) {
        var len = vec2.dist(p0, p1) + vec2.dist(p2, p1) + vec2.dist(p3, p2);
        var step = 1 / (len + 1) * this.segmentScale;
        return step;
    },
    /**
   * Get vertex count of cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @return number
   */ getCubicCurveVertexCount: function(p0, p1, p2, p3) {
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var segCount = Math.ceil(1 / step);
        if (!this.useNativeLine) {
            return segCount * 2 + 2;
        } else {
            return segCount * 2;
        }
    },
    /**
   * Get face count of cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @return number
   */ getCubicCurveTriangleCount: function(p0, p1, p2, p3) {
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var segCount = Math.ceil(1 / step);
        if (!this.useNativeLine) {
            return segCount * 2;
        } else {
            return 0;
        }
    },
    /**
   * Get vertex count of line
   * @return {number}
   */ getLineVertexCount: function() {
        return this.getPolylineVertexCount(sampleLinePoints);
    },
    /**
   * Get face count of line
   * @return {number}
   */ getLineTriangleCount: function() {
        return this.getPolylineTriangleCount(sampleLinePoints);
    },
    /**
   * Get how many vertices will polyline take.
   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
   * @return {number}
   */ getPolylineVertexCount: function(points) {
        var pointsLen;
        if (typeof points === 'number') {
            pointsLen = points;
        } else {
            var is2DArray = typeof points[0] !== 'number';
            pointsLen = is2DArray ? points.length : points.length / 2;
        }
        return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;
    },
    /**
   * Get how many triangles will polyline take.
   * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
   * @return {number}
   */ getPolylineTriangleCount: function(points) {
        var pointsLen;
        if (typeof points === 'number') {
            pointsLen = points;
        } else {
            var is2DArray = typeof points[0] !== 'number';
            pointsLen = is2DArray ? points.length : points.length / 2;
        }
        return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;
    },
    /**
   * Add a cubic curve
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {Array.<number>} p3
   * @param {Array.<number>} color
   * @param {number} [lineWidth=1]
   */ addCubicCurve: function(p0, p1, p2, p3, color, lineWidth) {
        if (lineWidth == null) {
            lineWidth = 1;
        } // incremental interpolation
        // http://antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION
        var x0 = p0[0], y0 = p0[1];
        var x1 = p1[0], y1 = p1[1];
        var x2 = p2[0], y2 = p2[1];
        var x3 = p3[0], y3 = p3[1];
        var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
        var step2 = step * step;
        var step3 = step2 * step;
        var pre1 = 3.0 * step;
        var pre2 = 3.0 * step2;
        var pre4 = 6.0 * step2;
        var pre5 = 6.0 * step3;
        var tmp1x = x0 - x1 * 2.0 + x2;
        var tmp1y = y0 - y1 * 2.0 + y2;
        var tmp2x = (x1 - x2) * 3.0 - x0 + x3;
        var tmp2y = (y1 - y2) * 3.0 - y0 + y3;
        var fx = x0;
        var fy = y0;
        var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;
        var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;
        var ddfx = tmp1x * pre4 + tmp2x * pre5;
        var ddfy = tmp1y * pre4 + tmp2y * pre5;
        var dddfx = tmp2x * pre5;
        var dddfy = tmp2y * pre5;
        var t = 0;
        var k = 0;
        var segCount = Math.ceil(1 / step);
        var points = new Float32Array((segCount + 1) * 3);
        var points = [];
        var offset = 0;
        for(var k = 0; k < segCount + 1; k++){
            points[offset++] = fx;
            points[offset++] = fy;
            fx += dfx;
            fy += dfy;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            t += step;
            if (t > 1) {
                fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);
                fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);
            }
        }
        this.addPolyline(points, color, lineWidth);
    },
    /**
   * Add a straight line
   * @param {Array.<number>} p0
   * @param {Array.<number>} p1
   * @param {Array.<number>} color
   * @param {number} [lineWidth=1]
   */ addLine: function(p0, p1, color, lineWidth) {
        this.addPolyline([
            p0,
            p1
        ], color, lineWidth);
    },
    /**
   * Add a straight line
   * @param {Array.<Array> | Array.<number>} points
   * @param {Array.<number> | Array.<Array>} color
   * @param {number} [lineWidth=1]
   * @param {number} [arrayOffset=0]
   * @param {number} [pointsCount] Default to be amount of points in the first argument
   */ addPolyline: function() {
        var dirA = vec2.create();
        var dirB = vec2.create();
        var normal = vec2.create();
        var tangent = vec2.create();
        var point = [], nextPoint = [], prevPoint = [];
        return function(points, color, lineWidth, arrayOffset, pointsCount) {
            if (!points.length) {
                return;
            }
            var is2DArray = typeof points[0] !== 'number';
            if (pointsCount == null) {
                pointsCount = is2DArray ? points.length : points.length / 2;
            }
            if (pointsCount < 2) {
                return;
            }
            if (arrayOffset == null) {
                arrayOffset = 0;
            }
            if (lineWidth == null) {
                lineWidth = 1;
            }
            this._itemVertexOffsets.push(this._vertexOffset);
            var notSharingColor = is2DArray ? typeof color[0] !== 'number' : color.length / 4 === pointsCount;
            var positionAttr = this.attributes.position;
            var colorAttr = this.attributes.color;
            var offsetAttr = this.attributes.offset;
            var normalAttr = this.attributes.normal;
            var indices = this.indices;
            var vertexOffset = this._vertexOffset;
            var pointColor;
            for(var k = 0; k < pointsCount; k++){
                if (is2DArray) {
                    point = points[k + arrayOffset];
                    if (notSharingColor) {
                        pointColor = color[k + arrayOffset];
                    } else {
                        pointColor = color;
                    }
                } else {
                    var k2 = k * 2 + arrayOffset;
                    point = point || [];
                    point[0] = points[k2];
                    point[1] = points[k2 + 1];
                    if (notSharingColor) {
                        var k4 = k * 4 + arrayOffset;
                        pointColor = pointColor || [];
                        pointColor[0] = color[k4];
                        pointColor[1] = color[k4 + 1];
                        pointColor[2] = color[k4 + 2];
                        pointColor[3] = color[k4 + 3];
                    } else {
                        pointColor = color;
                    }
                }
                if (!this.useNativeLine) {
                    var offset;
                    if (k < pointsCount - 1) {
                        if (is2DArray) {
                            vec2.copy(nextPoint, points[k + 1]);
                        } else {
                            var k2 = (k + 1) * 2 + arrayOffset;
                            nextPoint = nextPoint || [];
                            nextPoint[0] = points[k2];
                            nextPoint[1] = points[k2 + 1];
                        } // TODO In case dir is (0, 0)
                        // TODO miterLimit
                        if (k > 0) {
                            vec2.sub(dirA, point, prevPoint);
                            vec2.sub(dirB, nextPoint, point);
                            vec2.normalize(dirA, dirA);
                            vec2.normalize(dirB, dirB);
                            vec2.add(tangent, dirA, dirB);
                            vec2.normalize(tangent, tangent);
                            var miter = lineWidth / 2 * Math.min(1 / vec2.dot(dirA, tangent), 2);
                            normal[0] = -tangent[1];
                            normal[1] = tangent[0];
                            offset = miter;
                        } else {
                            vec2.sub(dirA, nextPoint, point);
                            vec2.normalize(dirA, dirA);
                            normal[0] = -dirA[1];
                            normal[1] = dirA[0];
                            offset = lineWidth / 2;
                        }
                    } else {
                        vec2.sub(dirA, point, prevPoint);
                        vec2.normalize(dirA, dirA);
                        normal[0] = -dirA[1];
                        normal[1] = dirA[0];
                        offset = lineWidth / 2;
                    }
                    normalAttr.set(vertexOffset, normal);
                    normalAttr.set(vertexOffset + 1, normal);
                    offsetAttr.set(vertexOffset, offset);
                    offsetAttr.set(vertexOffset + 1, -offset);
                    vec2.copy(prevPoint, point);
                    positionAttr.set(vertexOffset, point);
                    positionAttr.set(vertexOffset + 1, point);
                    colorAttr.set(vertexOffset, pointColor);
                    colorAttr.set(vertexOffset + 1, pointColor);
                    vertexOffset += 2;
                } else {
                    if (k > 1) {
                        positionAttr.copy(vertexOffset, vertexOffset - 1);
                        colorAttr.copy(vertexOffset, vertexOffset - 1);
                        vertexOffset++;
                    }
                }
                if (!this.useNativeLine) {
                    if (k > 0) {
                        var idx3 = this._faceOffset * 3;
                        var indices = this.indices; // 0-----2
                        // 1-----3
                        // 0->1->2, 1->3->2
                        indices[idx3] = vertexOffset - 4;
                        indices[idx3 + 1] = vertexOffset - 3;
                        indices[idx3 + 2] = vertexOffset - 2;
                        indices[idx3 + 3] = vertexOffset - 3;
                        indices[idx3 + 4] = vertexOffset - 1;
                        indices[idx3 + 5] = vertexOffset - 2;
                        this._faceOffset += 2;
                    }
                } else {
                    colorAttr.set(vertexOffset, pointColor);
                    positionAttr.set(vertexOffset, point);
                    vertexOffset++;
                }
            }
            this._vertexOffset = vertexOffset;
        };
    }(),
    /**
   * Set color of single line.
   */ setItemColor: function(idx, color) {
        var startOffset = this._itemVertexOffsets[idx];
        var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;
        for(var i = startOffset; i < endOffset; i++){
            this.attributes.color.set(i, color);
        }
        this.dirty('color');
    }
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].defaults(LinesGeometry.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$dynamicConvertMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = LinesGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.forceAtlas2.updateNodeRepulsion\n\n#define NODE_COUNT 0\n\nuniform sampler2D positionTex;\n\nuniform vec2 textureSize;\nuniform float gravity;\nuniform float scaling;\nuniform vec2 gravityCenter;\n\nuniform bool strongGravityMode;\nuniform bool preventOverlap;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, v_Texcoord);\n\n vec2 force = vec2(0.0);\n for (int i = 0; i < NODE_COUNT; i++) {\n vec2 uv = vec2(\n mod(float(i), textureSize.x) / (textureSize.x - 1.0),\n floor(float(i) / textureSize.x) / (textureSize.y - 1.0)\n );\n vec4 n1 = texture2D(positionTex, uv);\n\n vec2 dir = n0.xy - n1.xy;\n float d2 = dot(dir, dir);\n\n if (d2 > 0.0) {\n float factor = 0.0;\n if (preventOverlap) {\n float d = sqrt(d2);\n d = d - n0.w - n1.w;\n if (d > 0.0) {\n factor = scaling * n0.z * n1.z / (d * d);\n }\n else if (d < 0.0) {\n factor = scaling * 100.0 * n0.z * n1.z;\n }\n }\n else {\n factor = scaling * n0.z * n1.z / d2;\n }\n force += dir * factor;\n }\n }\n\n vec2 dir = gravityCenter - n0.xy;\n float d = 1.0;\n if (!strongGravityMode) {\n d = length(dir);\n }\n\n force += dir * n0.z * gravity / (d + 1.0);\n\n gl_FragColor = vec4(force, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.vertex\n\nattribute vec2 node1;\nattribute vec2 node2;\nattribute float weight;\n\nuniform sampler2D positionTex;\nuniform float edgeWeightInfluence;\nuniform bool preventOverlap;\nuniform bool linLogMode;\n\nuniform vec2 windowSize: WINDOW_SIZE;\n\nvarying vec2 v_Force;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, node1);\n vec4 n1 = texture2D(positionTex, node2);\n\n vec2 dir = n1.xy - n0.xy;\n float d = length(dir);\n float w;\n if (edgeWeightInfluence == 0.0) {\n w = 1.0;\n }\n else if (edgeWeightInfluence == 1.0) {\n w = weight;\n }\n else {\n w = pow(weight, edgeWeightInfluence);\n }\n vec2 offset = vec2(1.0 / windowSize.x, 1.0 / windowSize.y);\n vec2 scale = vec2((windowSize.x - 1.0) / windowSize.x, (windowSize.y - 1.0) / windowSize.y);\n vec2 pos = node1 * scale * 2.0 - 1.0;\n gl_Position = vec4(pos + offset, 0.0, 1.0);\n gl_PointSize = 1.0;\n\n float factor;\n if (preventOverlap) {\n d = d - n1.w - n0.w;\n }\n if (d <= 0.0) {\n v_Force = vec2(0.0);\n return;\n }\n\n if (linLogMode) {\n factor = w * log(d) / d;\n }\n else {\n factor = w;\n }\n v_Force = dir * factor;\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.fragment\n\nvarying vec2 v_Force;\n\nvoid main() {\n gl_FragColor = vec4(v_Force, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.vertex\n\nattribute vec2 node;\n\nvarying vec2 v_NodeUv;\n\nvoid main() {\n\n v_NodeUv = node;\n gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n gl_PointSize = 1.0;\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.fragment\n\nvarying vec2 v_NodeUv;\n\nuniform sampler2D positionTex;\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_NodeUv).rg;\n vec2 forcePrev = texture2D(forcePrevTex, v_NodeUv).rg;\n\n float mass = texture2D(positionTex, v_NodeUv).z;\n float swing = length(force - forcePrev) * mass;\n float traction = length(force + forcePrev) * 0.5 * mass;\n\n gl_FragColor = vec4(swing, traction, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcGlobalSpeed\n\nuniform sampler2D globalSpeedPrevTex;\nuniform sampler2D weightedSumTex;\nuniform float jitterTolerence;\n\nvoid main() {\n vec2 weightedSum = texture2D(weightedSumTex, vec2(0.5)).xy;\n float prevGlobalSpeed = texture2D(globalSpeedPrevTex, vec2(0.5)).x;\n float globalSpeed = jitterTolerence * jitterTolerence\n * weightedSum.y / weightedSum.x;\n if (prevGlobalSpeed > 0.0) {\n globalSpeed = min(globalSpeed / prevGlobalSpeed, 1.5) * prevGlobalSpeed;\n }\n gl_FragColor = vec4(globalSpeed, 0.0, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updatePosition\n\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\nuniform sampler2D positionTex;\nuniform sampler2D globalSpeedTex;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_Texcoord).xy;\n vec2 forcePrev = texture2D(forcePrevTex, v_Texcoord).xy;\n vec4 node = texture2D(positionTex, v_Texcoord);\n\n float globalSpeed = texture2D(globalSpeedTex, vec2(0.5)).r;\n float swing = length(force - forcePrev);\n float speed = 0.1 * globalSpeed / (0.1 + globalSpeed * sqrt(swing));\n\n float df = length(force);\n if (df > 0.0) {\n speed = min(df * speed, 10.0) / df;\n\n gl_FragColor = vec4(node.xy + speed * force, node.zw);\n }\n else {\n gl_FragColor = node;\n }\n}\n@end\n\n@export ecgl.forceAtlas2.edges.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 node;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\nuniform sampler2D positionTex;\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(\n texture2D(positionTex, node).xy, -10.0, 1.0\n );\n v_Color = a_Color;\n}\n@end\n\n@export ecgl.forceAtlas2.edges.fragment\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nvarying vec4 v_Color;\nvoid main() {\n gl_FragColor = color * v_Color;\n}\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2GPU.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$forceAtlas2$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2.glsl.js [app-client] (ecmascript)");
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$forceAtlas2$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var defaultConfigs = {
    repulsionByDegree: true,
    linLogMode: false,
    strongGravityMode: false,
    gravity: 1.0,
    scaling: 1.0,
    edgeWeightInfluence: 1.0,
    jitterTolerence: 0.1,
    preventOverlap: false,
    dissuadeHubs: false,
    gravityCenter: null
};
function ForceAtlas2GPU(options) {
    var textureOpt = {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture.FLOAT,
        minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture.NEAREST,
        magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture.NEAREST
    };
    this._positionSourceTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._positionSourceTex.flipY = false;
    this._positionTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._positionPrevTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._forceTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._forcePrevTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._weightedSumTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._weightedSumTex.width = this._weightedSumTex.height = 1;
    this._globalSpeedTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._globalSpeedPrevTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D(textureOpt);
    this._globalSpeedTex.width = this._globalSpeedTex.height = 1;
    this._globalSpeedPrevTex.width = this._globalSpeedPrevTex.height = 1;
    this._nodeRepulsionPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.forceAtlas2.updateNodeRepulsion')
    });
    this._positionPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.forceAtlas2.updatePosition')
    });
    this._globalSpeedPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.forceAtlas2.calcGlobalSpeed')
    });
    this._copyPass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('clay.compositor.output')
    });
    var additiveBlend = function(gl) {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE);
    };
    this._edgeForceMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
            attributes: {
                node1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('node1', 'float', 2),
                node2: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('node2', 'float', 2),
                weight: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('weight', 'float', 1)
            },
            dynamic: true,
            mainAttribute: 'node1'
        }),
        material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            transparent: true,
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.forceAtlas2.updateEdgeAttraction'),
            blend: additiveBlend,
            depthMask: false,
            depthText: false
        }),
        mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.POINTS
    });
    this._weightedSumMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
        geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
            attributes: {
                node: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('node', 'float', 2)
            },
            dynamic: true,
            mainAttribute: 'node'
        }),
        material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
            transparent: true,
            shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.forceAtlas2.calcWeightedSum'),
            blend: additiveBlend,
            depthMask: false,
            depthText: false
        }),
        mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.POINTS
    });
    this._framebuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        depthBuffer: false
    });
    this._dummyCamera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OrthographicCamera({
        left: -1,
        right: 1,
        top: 1,
        bottom: -1,
        near: 0,
        far: 100
    });
    this._globalSpeed = 0;
}
ForceAtlas2GPU.prototype.updateOption = function(options) {
    // Default config
    for(var name in defaultConfigs){
        this[name] = defaultConfigs[name];
    } // Config according to data scale
    var nNodes = this._nodes.length;
    if (nNodes > 50000) {
        this.jitterTolerence = 10;
    } else if (nNodes > 5000) {
        this.jitterTolerence = 1;
    } else {
        this.jitterTolerence = 0.1;
    }
    if (nNodes > 100) {
        this.scaling = 2.0;
    } else {
        this.scaling = 10.0;
    } // this.edgeWeightInfluence = 1;
    // this.gravity = 1;
    // this.strongGravityMode = false;
    if (options) {
        for(var name in defaultConfigs){
            if (options[name] != null) {
                this[name] = options[name];
            }
        }
    }
    if (this.repulsionByDegree) {
        var positionBuffer = this._positionSourceTex.pixels;
        for(var i = 0; i < this._nodes.length; i++){
            positionBuffer[i * 4 + 2] = (this._nodes[i].degree || 0) + 1;
        }
    }
};
ForceAtlas2GPU.prototype._updateGravityCenter = function(options) {
    var nodes = this._nodes;
    var edges = this._edges;
    if (!this.gravityCenter) {
        var min = [
            Infinity,
            Infinity
        ];
        var max = [
            -Infinity,
            -Infinity
        ];
        for(var i = 0; i < nodes.length; i++){
            min[0] = Math.min(nodes[i].x, min[0]);
            min[1] = Math.min(nodes[i].y, min[1]);
            max[0] = Math.max(nodes[i].x, max[0]);
            max[1] = Math.max(nodes[i].y, max[1]);
        }
        this._gravityCenter = [
            (min[0] + max[0]) * 0.5,
            (min[1] + max[1]) * 0.5
        ];
    } else {
        this._gravityCenter = this.gravityCenter;
    } // Update inDegree, outDegree
    for(var i = 0; i < edges.length; i++){
        var node1 = edges[i].node1;
        var node2 = edges[i].node2;
        nodes[node1].degree = (nodes[node1].degree || 0) + 1;
        nodes[node2].degree = (nodes[node2].degree || 0) + 1;
    }
};
/**
 * @param {Array.<Object>} [{ x, y, mass }] nodes
 * @param {Array.<Object>} [{ node1, node2, weight }] edges
 */ ForceAtlas2GPU.prototype.initData = function(nodes, edges) {
    this._nodes = nodes;
    this._edges = edges;
    this._updateGravityCenter();
    var textureWidth = Math.ceil(Math.sqrt(nodes.length));
    var textureHeight = textureWidth;
    var positionBuffer = new Float32Array(textureWidth * textureHeight * 4);
    this._resize(textureWidth, textureHeight);
    var offset = 0;
    for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        positionBuffer[offset++] = node.x || 0;
        positionBuffer[offset++] = node.y || 0;
        positionBuffer[offset++] = node.mass || 1;
        positionBuffer[offset++] = node.size || 1;
    }
    this._positionSourceTex.pixels = positionBuffer;
    var edgeGeometry = this._edgeForceMesh.geometry;
    var edgeLen = edges.length;
    edgeGeometry.attributes.node1.init(edgeLen * 2);
    edgeGeometry.attributes.node2.init(edgeLen * 2);
    edgeGeometry.attributes.weight.init(edgeLen * 2);
    var uv = [];
    for(var i = 0; i < edges.length; i++){
        var attributes = edgeGeometry.attributes;
        var weight = edges[i].weight;
        if (weight == null) {
            weight = 1;
        } // Two way.
        attributes.node1.set(i, this.getNodeUV(edges[i].node1, uv));
        attributes.node2.set(i, this.getNodeUV(edges[i].node2, uv));
        attributes.weight.set(i, weight);
        attributes.node1.set(i + edgeLen, this.getNodeUV(edges[i].node2, uv));
        attributes.node2.set(i + edgeLen, this.getNodeUV(edges[i].node1, uv));
        attributes.weight.set(i + edgeLen, weight);
    }
    var weigtedSumGeo = this._weightedSumMesh.geometry;
    weigtedSumGeo.attributes.node.init(nodes.length);
    for(var i = 0; i < nodes.length; i++){
        weigtedSumGeo.attributes.node.set(i, this.getNodeUV(i, uv));
    }
    edgeGeometry.dirty();
    weigtedSumGeo.dirty();
    this._nodeRepulsionPass.material.define('fragment', 'NODE_COUNT', nodes.length);
    this._nodeRepulsionPass.material.setUniform('textureSize', [
        textureWidth,
        textureHeight
    ]);
    this._inited = false;
    this._frame = 0;
};
ForceAtlas2GPU.prototype.getNodes = function() {
    return this._nodes;
};
ForceAtlas2GPU.prototype.getEdges = function() {
    return this._edges;
};
ForceAtlas2GPU.prototype.step = function(renderer) {
    if (!this._inited) {
        this._initFromSource(renderer);
        this._inited = true;
    }
    this._frame++;
    this._framebuffer.attach(this._forceTex);
    this._framebuffer.bind(renderer);
    var nodeRepulsionPass = this._nodeRepulsionPass; // Calc node repulsion, gravity
    nodeRepulsionPass.setUniform('strongGravityMode', this.strongGravityMode);
    nodeRepulsionPass.setUniform('gravity', this.gravity);
    nodeRepulsionPass.setUniform('gravityCenter', this._gravityCenter);
    nodeRepulsionPass.setUniform('scaling', this.scaling);
    nodeRepulsionPass.setUniform('preventOverlap', this.preventOverlap);
    nodeRepulsionPass.setUniform('positionTex', this._positionPrevTex);
    nodeRepulsionPass.render(renderer); // Calc edge attraction force
    var edgeForceMesh = this._edgeForceMesh;
    edgeForceMesh.material.set('linLogMode', this.linLogMode);
    edgeForceMesh.material.set('edgeWeightInfluence', this.edgeWeightInfluence);
    edgeForceMesh.material.set('preventOverlap', this.preventOverlap);
    edgeForceMesh.material.set('positionTex', this._positionPrevTex);
    renderer.gl.enable(renderer.gl.BLEND);
    renderer.renderPass([
        edgeForceMesh
    ], this._dummyCamera); // Calc weighted sum.
    this._framebuffer.attach(this._weightedSumTex);
    renderer.gl.clearColor(0, 0, 0, 0);
    renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
    renderer.gl.enable(renderer.gl.BLEND);
    var weightedSumMesh = this._weightedSumMesh;
    weightedSumMesh.material.set('positionTex', this._positionPrevTex);
    weightedSumMesh.material.set('forceTex', this._forceTex);
    weightedSumMesh.material.set('forcePrevTex', this._forcePrevTex);
    renderer.renderPass([
        weightedSumMesh
    ], this._dummyCamera); // Calc global speed.
    this._framebuffer.attach(this._globalSpeedTex);
    var globalSpeedPass = this._globalSpeedPass;
    globalSpeedPass.setUniform('globalSpeedPrevTex', this._globalSpeedPrevTex);
    globalSpeedPass.setUniform('weightedSumTex', this._weightedSumTex);
    globalSpeedPass.setUniform('jitterTolerence', this.jitterTolerence);
    renderer.gl.disable(renderer.gl.BLEND);
    globalSpeedPass.render(renderer); // Update position.
    var positionPass = this._positionPass;
    this._framebuffer.attach(this._positionTex);
    positionPass.setUniform('globalSpeedTex', this._globalSpeedTex);
    positionPass.setUniform('positionTex', this._positionPrevTex);
    positionPass.setUniform('forceTex', this._forceTex);
    positionPass.setUniform('forcePrevTex', this._forcePrevTex);
    positionPass.render(renderer);
    this._framebuffer.unbind(renderer);
    this._swapTexture();
};
ForceAtlas2GPU.prototype.update = function(renderer, steps, cb) {
    if (steps == null) {
        steps = 1;
    }
    steps = Math.max(steps, 1);
    for(var i = 0; i < steps; i++){
        this.step(renderer);
    }
    cb && cb();
};
ForceAtlas2GPU.prototype.getNodePositionTexture = function() {
    return this._inited // Texture already been swapped.
     ? this._positionPrevTex : this._positionSourceTex;
};
ForceAtlas2GPU.prototype.getNodeUV = function(nodeIndex, uv) {
    uv = uv || [];
    var textureWidth = this._positionTex.width;
    var textureHeight = this._positionTex.height;
    uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
    uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1) || 0;
    return uv;
};
ForceAtlas2GPU.prototype.getNodePosition = function(renderer, out) {
    var positionArr = this._positionArr;
    var width = this._positionTex.width;
    var height = this._positionTex.height;
    var size = width * height;
    if (!positionArr || positionArr.length !== size * 4) {
        positionArr = this._positionArr = new Float32Array(size * 4);
    }
    this._framebuffer.bind(renderer);
    this._framebuffer.attach(this._positionPrevTex);
    renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, positionArr);
    this._framebuffer.unbind(renderer);
    if (!out) {
        out = new Float32Array(this._nodes.length * 2);
    }
    for(var i = 0; i < this._nodes.length; i++){
        out[i * 2] = positionArr[i * 4];
        out[i * 2 + 1] = positionArr[i * 4 + 1];
    }
    return out;
};
ForceAtlas2GPU.prototype.getTextureData = function(renderer, textureName) {
    var tex = this['_' + textureName + 'Tex'];
    var width = tex.width;
    var height = tex.height;
    this._framebuffer.bind(renderer);
    this._framebuffer.attach(tex);
    var arr = new Float32Array(width * height * 4);
    renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, arr);
    this._framebuffer.unbind(renderer);
    return arr;
};
ForceAtlas2GPU.prototype.getTextureSize = function() {
    return {
        width: this._positionTex.width,
        height: this._positionTex.height
    };
};
ForceAtlas2GPU.prototype.isFinished = function(maxSteps) {
    return this._frame > maxSteps;
};
ForceAtlas2GPU.prototype._swapTexture = function() {
    var tmp = this._positionPrevTex;
    this._positionPrevTex = this._positionTex;
    this._positionTex = tmp;
    var tmp = this._forcePrevTex;
    this._forcePrevTex = this._forceTex;
    this._forceTex = tmp;
    var tmp = this._globalSpeedPrevTex;
    this._globalSpeedPrevTex = this._globalSpeedTex;
    this._globalSpeedTex = tmp;
};
ForceAtlas2GPU.prototype._initFromSource = function(renderer) {
    this._framebuffer.attach(this._positionPrevTex);
    this._framebuffer.bind(renderer);
    this._copyPass.setUniform('texture', this._positionSourceTex);
    this._copyPass.render(renderer);
    renderer.gl.clearColor(0, 0, 0, 0);
    this._framebuffer.attach(this._forcePrevTex);
    renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
    this._framebuffer.attach(this._globalSpeedPrevTex);
    renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
    this._framebuffer.unbind(renderer);
};
ForceAtlas2GPU.prototype._resize = function(width, height) {
    [
        '_positionSourceTex',
        '_positionTex',
        '_positionPrevTex',
        '_forceTex',
        '_forcePrevTex'
    ].forEach(function(texName) {
        this[texName].width = width;
        this[texName].height = height;
        this[texName].dirty();
    }, this);
};
ForceAtlas2GPU.prototype.dispose = function(renderer) {
    this._framebuffer.dispose(renderer);
    this._copyPass.dispose(renderer);
    this._nodeRepulsionPass.dispose(renderer);
    this._positionPass.dispose(renderer);
    this._globalSpeedPass.dispose(renderer);
    this._edgeForceMesh.geometry.dispose(renderer);
    this._weightedSumMesh.geometry.dispose(renderer);
    this._positionSourceTex.dispose(renderer);
    this._positionTex.dispose(renderer);
    this._positionPrevTex.dispose(renderer);
    this._forceTex.dispose(renderer);
    this._forcePrevTex.dispose(renderer);
    this._weightedSumTex.dispose(renderer);
    this._globalSpeedTex.dispose(renderer);
    this._globalSpeedPrevTex.dispose(renderer);
};
const __TURBOPACK__default__export__ = ForceAtlas2GPU;
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2Worker.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/****************************
 * Vector2 math functions
 ***************************/ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function forceAtlas2Worker() {
    var vec2 = {
        create: function() {
            return new Float32Array(2);
        },
        dist: function(a, b) {
            var x = b[0] - a[0];
            var y = b[1] - a[1];
            return Math.sqrt(x * x + y * y);
        },
        len: function(a) {
            var x = a[0];
            var y = a[1];
            return Math.sqrt(x * x + y * y);
        },
        scaleAndAdd: function(out, a, b, scale) {
            out[0] = a[0] + b[0] * scale;
            out[1] = a[1] + b[1] * scale;
            return out;
        },
        scale: function(out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            return out;
        },
        add: function(out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            return out;
        },
        sub: function(out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            return out;
        },
        normalize: function(out, a) {
            var x = a[0];
            var y = a[1];
            var len = x * x + y * y;
            if (len > 0) {
                //TODO: evaluate use of glm_invsqrt here?
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
            }
            return out;
        },
        negate: function(out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            return out;
        },
        copy: function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
        },
        set: function(out, x, y) {
            out[0] = x;
            out[1] = y;
            return out;
        }
    };
    /****************************
   * Class: Region
   ***************************/ function Region() {
        this.subRegions = [];
        this.nSubRegions = 0;
        this.node = null;
        this.mass = 0;
        this.centerOfMass = null;
        this.bbox = new Float32Array(4);
        this.size = 0;
    }
    var regionProto = Region.prototype; // Reset before update
    regionProto.beforeUpdate = function() {
        for(var i = 0; i < this.nSubRegions; i++){
            this.subRegions[i].beforeUpdate();
        }
        this.mass = 0;
        if (this.centerOfMass) {
            this.centerOfMass[0] = 0;
            this.centerOfMass[1] = 0;
        }
        this.nSubRegions = 0;
        this.node = null;
    }; // Clear after update
    regionProto.afterUpdate = function() {
        this.subRegions.length = this.nSubRegions;
        for(var i = 0; i < this.nSubRegions; i++){
            this.subRegions[i].afterUpdate();
        }
    };
    regionProto.addNode = function(node) {
        if (this.nSubRegions === 0) {
            if (this.node == null) {
                this.node = node;
                return;
            } else {
                this._addNodeToSubRegion(this.node);
                this.node = null;
            }
        }
        this._addNodeToSubRegion(node);
        this._updateCenterOfMass(node);
    };
    regionProto.findSubRegion = function(x, y) {
        for(var i = 0; i < this.nSubRegions; i++){
            var region = this.subRegions[i];
            if (region.contain(x, y)) {
                return region;
            }
        }
    };
    regionProto.contain = function(x, y) {
        return this.bbox[0] <= x && this.bbox[2] >= x && this.bbox[1] <= y && this.bbox[3] >= y;
    };
    regionProto.setBBox = function(minX, minY, maxX, maxY) {
        // Min
        this.bbox[0] = minX;
        this.bbox[1] = minY; // Max
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;
        this.size = (maxX - minX + maxY - minY) / 2;
    };
    regionProto._newSubRegion = function() {
        var subRegion = this.subRegions[this.nSubRegions];
        if (!subRegion) {
            subRegion = new Region();
            this.subRegions[this.nSubRegions] = subRegion;
        }
        this.nSubRegions++;
        return subRegion;
    };
    regionProto._addNodeToSubRegion = function(node) {
        var subRegion = this.findSubRegion(node.position[0], node.position[1]);
        var bbox = this.bbox;
        if (!subRegion) {
            var cx = (bbox[0] + bbox[2]) / 2;
            var cy = (bbox[1] + bbox[3]) / 2;
            var w = (bbox[2] - bbox[0]) / 2;
            var h = (bbox[3] - bbox[1]) / 2;
            var xi = node.position[0] >= cx ? 1 : 0;
            var yi = node.position[1] >= cy ? 1 : 0;
            var subRegion = this._newSubRegion(); // Min
            subRegion.setBBox(xi * w + bbox[0], yi * h + bbox[1], (xi + 1) * w + bbox[0], (yi + 1) * h + bbox[1]);
        }
        subRegion.addNode(node);
    };
    regionProto._updateCenterOfMass = function(node) {
        // Incrementally update
        if (this.centerOfMass == null) {
            this.centerOfMass = new Float32Array(2);
        }
        var x = this.centerOfMass[0] * this.mass;
        var y = this.centerOfMass[1] * this.mass;
        x += node.position[0] * node.mass;
        y += node.position[1] * node.mass;
        this.mass += node.mass;
        this.centerOfMass[0] = x / this.mass;
        this.centerOfMass[1] = y / this.mass;
    };
    /****************************
   * Class: Graph Node
   ***************************/ function GraphNode() {
        this.position = new Float32Array(2);
        this.force = vec2.create();
        this.forcePrev = vec2.create(); // If repulsionByDegree is true
        //  mass = inDegree + outDegree + 1
        // Else
        //  mass is manually set
        this.mass = 1;
        this.inDegree = 0;
        this.outDegree = 0; // Optional
    // this.size = 1;
    }
    /****************************
   * Class: Graph Edge
   ***************************/ function GraphEdge(source, target) {
        this.source = source;
        this.target = target;
        this.weight = 1;
    }
    /****************************
   * Class: ForceStlas2
   ***************************/ function ForceAtlas2() {
        //-------------
        // Configs
        // If auto settings is true
        //  barnesHutOptimize,
        //  barnesHutTheta,
        //  scaling,
        //  jitterTolerence
        // Will be set by the system automatically
        //  preventOverlap will be set false
        //  if node size is not given
        this.autoSettings = true; // Barnes Hut
        // http://arborjs.org/docs/barnes-hut
        this.barnesHutOptimize = true;
        this.barnesHutTheta = 1.5; // Force Atlas2 Configs
        this.repulsionByDegree = true;
        this.linLogMode = false;
        this.strongGravityMode = false;
        this.gravity = 1.0;
        this.scaling = 1.0;
        this.edgeWeightInfluence = 1.0;
        this.jitterTolerence = 0.1; // TODO
        this.preventOverlap = false;
        this.dissuadeHubs = false; //
        this.rootRegion = new Region();
        this.rootRegion.centerOfMass = vec2.create();
        this.nodes = [];
        this.edges = [];
        this.bbox = new Float32Array(4);
        this.gravityCenter = null;
        this._massArr = null;
        this._swingingArr = null;
        this._sizeArr = null;
        this._globalSpeed = 0;
    }
    var forceAtlas2Proto = ForceAtlas2.prototype;
    forceAtlas2Proto.initNodes = function(positionArr, massArr, sizeArr) {
        var nNodes = massArr.length;
        this.nodes.length = 0;
        var haveSize = typeof sizeArr != 'undefined';
        for(var i = 0; i < nNodes; i++){
            var node = new GraphNode();
            node.position[0] = positionArr[i * 2];
            node.position[1] = positionArr[i * 2 + 1];
            node.mass = massArr[i];
            if (haveSize) {
                node.size = sizeArr[i];
            }
            this.nodes.push(node);
        }
        this._massArr = massArr;
        this._swingingArr = new Float32Array(nNodes);
        if (haveSize) {
            this._sizeArr = sizeArr;
        }
    };
    forceAtlas2Proto.initEdges = function(edgeArr, edgeWeightArr) {
        var nEdges = edgeArr.length / 2;
        this.edges.length = 0;
        for(var i = 0; i < nEdges; i++){
            var sIdx = edgeArr[i * 2];
            var tIdx = edgeArr[i * 2 + 1];
            var sNode = this.nodes[sIdx];
            var tNode = this.nodes[tIdx];
            if (!sNode || !tNode) {
                console.error('Node not exists, try initNodes before initEdges');
                return;
            }
            sNode.outDegree++;
            tNode.inDegree++;
            var edge = new GraphEdge(sNode, tNode);
            if (edgeWeightArr) {
                edge.weight = edgeWeightArr[i];
            }
            this.edges.push(edge);
        }
    };
    forceAtlas2Proto.updateSettings = function() {
        if (this.repulsionByDegree) {
            for(var i = 0; i < this.nodes.length; i++){
                var node = this.nodes[i];
                node.mass = node.inDegree + node.outDegree + 1;
            }
        } else {
            for(var i = 0; i < this.nodes.length; i++){
                var node = this.nodes[i];
                node.mass = this._massArr[i];
            }
        }
    };
    forceAtlas2Proto.update = function() {
        var nNodes = this.nodes.length;
        this.updateSettings();
        this.updateBBox(); // Update region
        if (this.barnesHutOptimize) {
            this.rootRegion.setBBox(this.bbox[0], this.bbox[1], this.bbox[2], this.bbox[3]);
            this.rootRegion.beforeUpdate();
            for(var i = 0; i < nNodes; i++){
                this.rootRegion.addNode(this.nodes[i]);
            }
            this.rootRegion.afterUpdate();
        } // Reset forces
        for(var i = 0; i < nNodes; i++){
            var node = this.nodes[i];
            vec2.copy(node.forcePrev, node.force);
            vec2.set(node.force, 0, 0);
        } // Compute forces
        // Repulsion
        for(var i = 0; i < nNodes; i++){
            var na = this.nodes[i];
            if (this.barnesHutOptimize) {
                this.applyRegionToNodeRepulsion(this.rootRegion, na);
            } else {
                for(var j = i + 1; j < nNodes; j++){
                    var nb = this.nodes[j];
                    this.applyNodeToNodeRepulsion(na, nb, false);
                }
            } // Gravity
            if (this.gravity > 0) {
                if (this.strongGravityMode) {
                    this.applyNodeStrongGravity(na);
                } else {
                    this.applyNodeGravity(na);
                }
            }
        } // Attraction
        for(var i = 0; i < this.edges.length; i++){
            this.applyEdgeAttraction(this.edges[i]);
        } // Handle swinging
        var swingWeightedSum = 0;
        var tractionWeightedSum = 0;
        var tmp = vec2.create();
        for(var i = 0; i < nNodes; i++){
            var node = this.nodes[i];
            var swing = vec2.dist(node.force, node.forcePrev);
            swingWeightedSum += swing * node.mass;
            vec2.add(tmp, node.force, node.forcePrev);
            var traction = vec2.len(tmp) * 0.5;
            tractionWeightedSum += traction * node.mass; // Save the value for using later
            this._swingingArr[i] = swing;
        }
        var globalSpeed = this.jitterTolerence * this.jitterTolerence * tractionWeightedSum / swingWeightedSum; // NB: During our tests we observed that an excessive rise of the global speed could have a negative impact.
        // That’s why we limited the increase of global speed s(t)(G) to 50% of the previous step s(t−1)(G).
        if (this._globalSpeed > 0) {
            globalSpeed = Math.min(globalSpeed / this._globalSpeed, 1.5) * this._globalSpeed;
        }
        this._globalSpeed = globalSpeed; // Apply forces
        for(var i = 0; i < nNodes; i++){
            var node = this.nodes[i];
            var swing = this._swingingArr[i];
            var speed = 0.1 * globalSpeed / (1 + globalSpeed * Math.sqrt(swing)); // Additional constraint to prevent local speed gets too high
            var df = vec2.len(node.force);
            if (df > 0) {
                speed = Math.min(df * speed, 10) / df;
                vec2.scaleAndAdd(node.position, node.position, node.force, speed);
            }
        }
    };
    forceAtlas2Proto.applyRegionToNodeRepulsion = function() {
        var v = vec2.create();
        return function applyRegionToNodeRepulsion(region, node) {
            if (region.node) {
                // Region is a leaf
                this.applyNodeToNodeRepulsion(region.node, node, true);
            } else {
                vec2.sub(v, node.position, region.centerOfMass);
                var d2 = v[0] * v[0] + v[1] * v[1];
                if (d2 > this.barnesHutTheta * region.size * region.size) {
                    var factor = this.scaling * node.mass * region.mass / d2;
                    vec2.scaleAndAdd(node.force, node.force, v, factor);
                } else {
                    for(var i = 0; i < region.nSubRegions; i++){
                        this.applyRegionToNodeRepulsion(region.subRegions[i], node);
                    }
                }
            }
        };
    }();
    forceAtlas2Proto.applyNodeToNodeRepulsion = function() {
        var v = vec2.create();
        return function applyNodeToNodeRepulsion(na, nb, oneWay) {
            if (na == nb) {
                return;
            }
            vec2.sub(v, na.position, nb.position);
            var d2 = v[0] * v[0] + v[1] * v[1]; // PENDING
            if (d2 === 0) {
                return;
            }
            var factor;
            if (this.preventOverlap) {
                var d = Math.sqrt(d2);
                d = d - na.size - nb.size;
                if (d > 0) {
                    factor = this.scaling * na.mass * nb.mass / (d * d);
                } else if (d < 0) {
                    // A stronger repulsion if overlap
                    factor = this.scaling * 100 * na.mass * nb.mass;
                } else {
                    // No repulsion
                    return;
                }
            } else {
                // Divide factor by an extra `d` to normalize the `v`
                factor = this.scaling * na.mass * nb.mass / d2;
            }
            vec2.scaleAndAdd(na.force, na.force, v, factor);
            vec2.scaleAndAdd(nb.force, nb.force, v, -factor);
        };
    }();
    forceAtlas2Proto.applyEdgeAttraction = function() {
        var v = vec2.create();
        return function applyEdgeAttraction(edge) {
            var na = edge.source;
            var nb = edge.target;
            vec2.sub(v, na.position, nb.position);
            var d = vec2.len(v);
            var w;
            if (this.edgeWeightInfluence === 0) {
                w = 1;
            } else if (this.edgeWeightInfluence === 1) {
                w = edge.weight;
            } else {
                w = Math.pow(edge.weight, this.edgeWeightInfluence);
            }
            var factor;
            if (this.preventOverlap) {
                d = d - na.size - nb.size;
                if (d <= 0) {
                    // No attraction
                    return;
                }
            }
            if (this.linLogMode) {
                // Divide factor by an extra `d` to normalize the `v`
                factor = -w * Math.log(d + 1) / (d + 1);
            } else {
                factor = -w;
            }
            vec2.scaleAndAdd(na.force, na.force, v, factor);
            vec2.scaleAndAdd(nb.force, nb.force, v, -factor);
        };
    }();
    forceAtlas2Proto.applyNodeGravity = function() {
        var v = vec2.create();
        return function(node) {
            vec2.sub(v, this.gravityCenter, node.position);
            var d = vec2.len(v);
            vec2.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass / (d + 1));
        };
    }();
    forceAtlas2Proto.applyNodeStrongGravity = function() {
        var v = vec2.create();
        return function(node) {
            vec2.sub(v, this.gravityCenter, node.position);
            vec2.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass);
        };
    }();
    forceAtlas2Proto.updateBBox = function() {
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for(var i = 0; i < this.nodes.length; i++){
            var pos = this.nodes[i].position;
            minX = Math.min(minX, pos[0]);
            minY = Math.min(minY, pos[1]);
            maxX = Math.max(maxX, pos[0]);
            maxY = Math.max(maxY, pos[1]);
        }
        this.bbox[0] = minX;
        this.bbox[1] = minY;
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;
    };
    forceAtlas2Proto.getGlobalSpeed = function() {
        return this._globalSpeed;
    };
    /****************************
   * Main process
   ***************************/ var forceAtlas2 = null;
    self.onmessage = function(e) {
        switch(e.data.cmd){
            case 'init':
                forceAtlas2 = new ForceAtlas2();
                forceAtlas2.initNodes(e.data.nodesPosition, e.data.nodesMass, e.data.nodesSize);
                forceAtlas2.initEdges(e.data.edges, e.data.edgesWeight);
                break;
            case 'updateConfig':
                if (forceAtlas2) {
                    for(var name in e.data.config){
                        forceAtlas2[name] = e.data.config[name];
                    }
                }
                break;
            case 'update':
                var steps = e.data.steps;
                if (forceAtlas2) {
                    for(var i = 0; i < steps; i++){
                        forceAtlas2.update();
                    }
                    var nNodes = forceAtlas2.nodes.length;
                    var positionArr = new Float32Array(nNodes * 2); // Callback
                    for(var i = 0; i < nNodes; i++){
                        var node = forceAtlas2.nodes[i];
                        positionArr[i * 2] = node.position[0];
                        positionArr[i * 2 + 1] = node.position[1];
                    }
                    self.postMessage({
                        buffer: positionArr.buffer,
                        globalSpeed: forceAtlas2.getGlobalSpeed()
                    }, [
                        positionArr.buffer
                    ]);
                } else {
                    // Not initialzied yet
                    var emptyArr = new Float32Array(); // Post transfer object
                    self.postMessage({
                        buffer: emptyArr.buffer,
                        globalSpeed: forceAtlas2.getGlobalSpeed()
                    }, [
                        emptyArr.buffer
                    ]);
                }
                break;
        }
    };
}
const __TURBOPACK__default__export__ = forceAtlas2Worker;
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$forceAtlas2Worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2Worker.js [app-client] (ecmascript)");
;
;
;
var workerUrl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$forceAtlas2Worker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toString();
workerUrl = workerUrl.slice(workerUrl.indexOf('{') + 1, workerUrl.lastIndexOf('}'));
var defaultConfigs = {
    barnesHutOptimize: true,
    barnesHutTheta: 1.5,
    repulsionByDegree: true,
    linLogMode: false,
    strongGravityMode: false,
    gravity: 1.0,
    scaling: 1.0,
    edgeWeightInfluence: 1.0,
    jitterTolerence: 0.1,
    preventOverlap: false,
    dissuadeHubs: false,
    gravityCenter: null
};
var ForceAtlas2 = function(options) {
    for(var name in defaultConfigs){
        this[name] = defaultConfigs[name];
    }
    if (options) {
        for(var name in options){
            this[name] = options[name];
        }
    }
    this._nodes = [];
    this._edges = [];
    this._disposed = false;
    this._positionTex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        flipY: false,
        minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
        magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST
    });
};
ForceAtlas2.prototype.initData = function(nodes, edges) {
    var bb = new Blob([
        workerUrl
    ]);
    var blobURL = window.URL.createObjectURL(bb);
    this._worker = new Worker(blobURL);
    this._worker.onmessage = this._$onupdate.bind(this);
    this._nodes = nodes;
    this._edges = edges;
    this._frame = 0;
    var nNodes = nodes.length;
    var nEdges = edges.length;
    var positionArr = new Float32Array(nNodes * 2);
    var massArr = new Float32Array(nNodes);
    var sizeArr = new Float32Array(nNodes);
    var edgeArr = new Float32Array(nEdges * 2);
    var edgeWeightArr = new Float32Array(nEdges);
    for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        positionArr[i * 2] = node.x;
        positionArr[i * 2 + 1] = node.y;
        massArr[i] = node.mass == null ? 1 : node.mass;
        sizeArr[i] = node.size == null ? 1 : node.size;
    }
    for(var i = 0; i < edges.length; i++){
        var edge = edges[i];
        var source = edge.node1;
        var target = edge.node2;
        edgeArr[i * 2] = source;
        edgeArr[i * 2 + 1] = target;
        edgeWeightArr[i] = edge.weight == null ? 1 : edge.weight;
    }
    var textureWidth = Math.ceil(Math.sqrt(nodes.length));
    var textureHeight = textureWidth;
    var pixels = new Float32Array(textureWidth * textureHeight * 4);
    var positionTex = this._positionTex;
    positionTex.width = textureWidth;
    positionTex.height = textureHeight;
    positionTex.pixels = pixels;
    this._worker.postMessage({
        cmd: 'init',
        nodesPosition: positionArr,
        nodesMass: massArr,
        nodesSize: sizeArr,
        edges: edgeArr,
        edgesWeight: edgeWeightArr
    });
    this._globalSpeed = Infinity;
};
ForceAtlas2.prototype.updateOption = function(options) {
    var config = {}; // Default config
    for(var name in defaultConfigs){
        config[name] = defaultConfigs[name];
    }
    var nodes = this._nodes;
    var edges = this._edges; // Config according to data scale
    var nNodes = nodes.length;
    if (nNodes > 50000) {
        config.jitterTolerence = 10;
    } else if (nNodes > 5000) {
        config.jitterTolerence = 1;
    } else {
        config.jitterTolerence = 0.1;
    }
    if (nNodes > 100) {
        config.scaling = 2.0;
    } else {
        config.scaling = 10.0;
    }
    if (nNodes > 1000) {
        config.barnesHutOptimize = true;
    } else {
        config.barnesHutOptimize = false;
    }
    if (options) {
        for(var name in defaultConfigs){
            if (options[name] != null) {
                config[name] = options[name];
            }
        }
    }
    if (!config.gravityCenter) {
        var min = [
            Infinity,
            Infinity
        ];
        var max = [
            -Infinity,
            -Infinity
        ];
        for(var i = 0; i < nodes.length; i++){
            min[0] = Math.min(nodes[i].x, min[0]);
            min[1] = Math.min(nodes[i].y, min[1]);
            max[0] = Math.max(nodes[i].x, max[0]);
            max[1] = Math.max(nodes[i].y, max[1]);
        }
        config.gravityCenter = [
            (min[0] + max[0]) * 0.5,
            (min[1] + max[1]) * 0.5
        ];
    } // Update inDegree, outDegree
    for(var i = 0; i < edges.length; i++){
        var node1 = edges[i].node1;
        var node2 = edges[i].node2;
        nodes[node1].degree = (nodes[node1].degree || 0) + 1;
        nodes[node2].degree = (nodes[node2].degree || 0) + 1;
    }
    if (this._worker) {
        this._worker.postMessage({
            cmd: 'updateConfig',
            config: config
        });
    }
}; // Steps per call, to keep sync with rendering
ForceAtlas2.prototype.update = function(renderer, steps, cb) {
    if (steps == null) {
        steps = 1;
    }
    steps = Math.max(steps, 1);
    this._frame += steps;
    this._onupdate = cb;
    if (this._worker) {
        this._worker.postMessage({
            cmd: 'update',
            steps: Math.round(steps)
        });
    }
};
ForceAtlas2.prototype._$onupdate = function(e) {
    // Incase the worker keep postMessage of last frame after it is disposed
    if (this._disposed) {
        return;
    }
    var positionArr = new Float32Array(e.data.buffer);
    this._globalSpeed = e.data.globalSpeed;
    this._positionArr = positionArr;
    this._updateTexture(positionArr);
    this._onupdate && this._onupdate();
};
ForceAtlas2.prototype.getNodePositionTexture = function() {
    return this._positionTex;
};
ForceAtlas2.prototype.getNodeUV = function(nodeIndex, uv) {
    uv = uv || [];
    var textureWidth = this._positionTex.width;
    var textureHeight = this._positionTex.height;
    uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
    uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1);
    return uv;
};
ForceAtlas2.prototype.getNodes = function() {
    return this._nodes;
};
ForceAtlas2.prototype.getEdges = function() {
    return this._edges;
};
ForceAtlas2.prototype.isFinished = function(maxSteps) {
    return this._frame > maxSteps;
};
ForceAtlas2.prototype.getNodePosition = function(renderer, out) {
    if (!out) {
        out = new Float32Array(this._nodes.length * 2);
    }
    if (this._positionArr) {
        for(var i = 0; i < this._positionArr.length; i++){
            out[i] = this._positionArr[i];
        }
    }
    return out;
};
ForceAtlas2.prototype._updateTexture = function(positionArr) {
    var pixels = this._positionTex.pixels;
    var offset = 0;
    for(var i = 0; i < positionArr.length;){
        pixels[offset++] = positionArr[i++];
        pixels[offset++] = positionArr[i++];
        pixels[offset++] = 1;
        pixels[offset++] = 1;
    }
    this._positionTex.dirty();
};
ForceAtlas2.prototype.dispose = function(renderer) {
    this._disposed = true;
    this._worker = null;
};
const __TURBOPACK__default__export__ = ForceAtlas2;
}}),
"[project]/node_modules/echarts-gl/lib/util/Roam2DControl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$Base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/core/Base.js [app-client] (ecmascript)");
;
;
/**
 * @alias module:echarts-gl/util/Roam2DControl
 */ var Roam2DControl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$core$2f$Base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        /**
     * @type {module:zrender~ZRender}
     */ zr: null,
        /**
     * @type {module:echarts-gl/core/ViewGL}
     */ viewGL: null,
        minZoom: 0.2,
        maxZoom: 5,
        _needsUpdate: false,
        _dx: 0,
        _dy: 0,
        _zoom: 1
    };
}, function() {
    // Each Roam2DControl has it's own handler
    this._mouseDownHandler = this._mouseDownHandler.bind(this);
    this._mouseWheelHandler = this._mouseWheelHandler.bind(this);
    this._mouseMoveHandler = this._mouseMoveHandler.bind(this);
    this._mouseUpHandler = this._mouseUpHandler.bind(this);
    this._update = this._update.bind(this);
}, {
    init: function() {
        var zr = this.zr;
        zr.on('mousedown', this._mouseDownHandler);
        zr.on('mousewheel', this._mouseWheelHandler);
        zr.on('globalout', this._mouseUpHandler);
        zr.animation.on('frame', this._update);
    },
    setTarget: function(target) {
        this._target = target;
    },
    setZoom: function(zoom) {
        this._zoom = Math.max(Math.min(zoom, this.maxZoom), this.minZoom);
        this._needsUpdate = true;
    },
    setOffset: function(offset) {
        this._dx = offset[0];
        this._dy = offset[1];
        this._needsUpdate = true;
    },
    getZoom: function() {
        return this._zoom;
    },
    getOffset: function() {
        return [
            this._dx,
            this._dy
        ];
    },
    _update: function() {
        if (!this._target) {
            return;
        }
        if (!this._needsUpdate) {
            return;
        }
        var target = this._target;
        var scale = this._zoom;
        target.position.x = this._dx;
        target.position.y = this._dy;
        target.scale.set(scale, scale, scale);
        this.zr.refresh();
        this._needsUpdate = false;
        this.trigger('update');
    },
    _mouseDownHandler: function(e) {
        if (e.target) {
            return;
        }
        var x = e.offsetX;
        var y = e.offsetY;
        if (this.viewGL && !this.viewGL.containPoint(x, y)) {
            return;
        }
        this.zr.on('mousemove', this._mouseMoveHandler);
        this.zr.on('mouseup', this._mouseUpHandler);
        var pos = this._convertPos(x, y);
        this._x = pos.x;
        this._y = pos.y;
    },
    // Convert pos from screen space to viewspace.
    _convertPos: function(x, y) {
        var camera = this.viewGL.camera;
        var viewport = this.viewGL.viewport; // PENDING
        return {
            x: (x - viewport.x) / viewport.width * (camera.right - camera.left) + camera.left,
            y: (y - viewport.y) / viewport.height * (camera.bottom - camera.top) + camera.top
        };
    },
    _mouseMoveHandler: function(e) {
        var pos = this._convertPos(e.offsetX, e.offsetY);
        this._dx += pos.x - this._x;
        this._dy += pos.y - this._y;
        this._x = pos.x;
        this._y = pos.y;
        this._needsUpdate = true;
    },
    _mouseUpHandler: function(e) {
        this.zr.off('mousemove', this._mouseMoveHandler);
        this.zr.off('mouseup', this._mouseUpHandler);
    },
    _mouseWheelHandler: function(e) {
        e = e.event;
        var delta = e.wheelDelta // Webkit
         || -e.detail; // Firefox
        if (delta === 0) {
            return;
        }
        var x = e.offsetX;
        var y = e.offsetY;
        if (this.viewGL && !this.viewGL.containPoint(x, y)) {
            return;
        }
        var zoomScale = delta > 0 ? 1.1 : 0.9;
        var newZoom = Math.max(Math.min(this._zoom * zoomScale, this.maxZoom), this.minZoom);
        zoomScale = newZoom / this._zoom;
        var pos = this._convertPos(x, y);
        var fixX = (pos.x - this._dx) * (zoomScale - 1);
        var fixY = (pos.y - this._dy) * (zoomScale - 1);
        this._dx -= fixX;
        this._dy -= fixY;
        this._zoom = newZoom;
        this._needsUpdate = true;
    },
    dispose: function() {
        var zr = this.zr;
        zr.off('mousedown', this._mouseDownHandler);
        zr.off('mousemove', this._mouseMoveHandler);
        zr.off('mouseup', this._mouseUpHandler);
        zr.off('mousewheel', this._mouseWheelHandler);
        zr.off('globalout', this._mouseUpHandler);
        zr.animation.off('frame', this._update);
    }
});
const __TURBOPACK__default__export__ = Roam2DControl;
}}),
"[project]/node_modules/echarts-gl/lib/util/shader/lines2D.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.lines2D.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 position: POSITION;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n v_Color = a_Color;\n}\n\n@end\n\n@export ecgl.lines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.vertex\n\nattribute vec2 position: POSITION;\nattribute vec2 normal;\nattribute float offset;\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n vec4 p2 = worldViewProjection * vec4(position + normal, -10.0, 1.0);\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n p2.xy /= p2.w;\n gl_Position.xy /= gl_Position.w;\n\n vec2 N = normalize(p2.xy - gl_Position.xy);\n gl_Position.xy += N * offset / viewport.zw * 2.0;\n\n gl_Position.xy *= gl_Position.w;\n\n v_Color = a_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n\n@end";
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/GraphGLView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/number.js [app-client] (ecmascript) <export * as number>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/util/layout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2GPU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2GPU.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$requestAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/animation/requestAnimationFrame.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/dep/glmatrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$Roam2DControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/Roam2DControl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/PointsBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines2D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/shader/lines2D.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var vec2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$dep$2f$glmatrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].vec2;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.import(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$shader$2f$lines2D$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var globalLayoutId = 1;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'graphGL',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this.viewGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('orthographic');
        this.viewGL.camera.left = this.viewGL.camera.right = 0;
        this.viewGL.add(this.groupGL);
        this._pointsBuilder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$PointsBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](true, api); // Mesh used during force directed layout.
        this._forceEdgesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.forceAtlas2.edges'),
                transparent: true,
                depthMask: false,
                depthTest: false
            }),
            $ignorePicking: true,
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry({
                attributes: {
                    node: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('node', 'float', 2),
                    color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Geometry.Attribute('color', 'float', 4, 'COLOR')
                },
                dynamic: true,
                mainAttribute: 'node'
            }),
            renderOrder: -1,
            mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.LINES
        }); // Mesh used after force directed layout.
        this._edgesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines2D'),
                transparent: true,
                depthMask: false,
                depthTest: false
            }),
            $ignorePicking: true,
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                useNativeLine: false,
                dynamic: true
            }),
            renderOrder: -1,
            culling: false
        });
        this._layoutId = 0;
        this._control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$Roam2DControl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            zr: api.getZr(),
            viewGL: this.viewGL
        });
        this._control.setTarget(this.groupGL);
        this._control.init();
        this._clickHandler = this._clickHandler.bind(this);
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.add(this._pointsBuilder.rootNode);
        this._model = seriesModel;
        this._api = api;
        this._initLayout(seriesModel, ecModel, api);
        this._pointsBuilder.update(seriesModel, ecModel, api);
        if (!(this._forceLayoutInstance instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2GPU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
            this.groupGL.remove(this._forceEdgesMesh);
        }
        this._updateCamera(seriesModel, api);
        this._control.off('update');
        this._control.on('update', function() {
            api.dispatchAction({
                type: 'graphGLRoam',
                seriesId: seriesModel.id,
                zoom: this._control.getZoom(),
                offset: this._control.getOffset()
            });
            this._pointsBuilder.updateView(this.viewGL.camera);
        }, this);
        this._control.setZoom(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('zoom'), 1));
        this._control.setOffset(seriesModel.get('offset') || [
            0,
            0
        ]);
        var mesh = this._pointsBuilder.getPointsMesh();
        mesh.off('mousemove', this._mousemoveHandler);
        mesh.off('mouseout', this._mouseOutHandler, this);
        api.getZr().off('click', this._clickHandler);
        this._pointsBuilder.highlightOnMouseover = true;
        if (seriesModel.get('focusNodeAdjacency')) {
            var focusNodeAdjacencyOn = seriesModel.get('focusNodeAdjacencyOn');
            if (focusNodeAdjacencyOn === 'click') {
                // Remove default emphasis effect
                api.getZr().on('click', this._clickHandler);
            } else if (focusNodeAdjacencyOn === 'mouseover') {
                mesh.on('mousemove', this._mousemoveHandler, this);
                mesh.on('mouseout', this._mouseOutHandler, this);
                this._pointsBuilder.highlightOnMouseover = false;
            } else {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn('Unkown focusNodeAdjacencyOn value \s' + focusNodeAdjacencyOn);
                }
            }
        } // Reset
        this._lastMouseOverDataIndex = -1;
    },
    _clickHandler: function(e) {
        if (this._layouting) {
            return;
        }
        var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
        if (dataIndex >= 0) {
            this._api.dispatchAction({
                type: 'graphGLFocusNodeAdjacency',
                seriesId: this._model.id,
                dataIndex: dataIndex
            });
        } else {
            this._api.dispatchAction({
                type: 'graphGLUnfocusNodeAdjacency',
                seriesId: this._model.id
            });
        }
    },
    _mousemoveHandler: function(e) {
        if (this._layouting) {
            return;
        }
        var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
        if (dataIndex >= 0) {
            if (dataIndex !== this._lastMouseOverDataIndex) {
                this._api.dispatchAction({
                    type: 'graphGLFocusNodeAdjacency',
                    seriesId: this._model.id,
                    dataIndex: dataIndex
                });
            }
        } else {
            this._mouseOutHandler(e);
        }
        this._lastMouseOverDataIndex = dataIndex;
    },
    _mouseOutHandler: function(e) {
        if (this._layouting) {
            return;
        }
        this._api.dispatchAction({
            type: 'graphGLUnfocusNodeAdjacency',
            seriesId: this._model.id
        });
        this._lastMouseOverDataIndex = -1;
    },
    _updateForceEdgesGeometry: function(edges, seriesModel) {
        var geometry = this._forceEdgesMesh.geometry;
        var edgeData = seriesModel.getEdgeData();
        var offset = 0;
        var layoutInstance = this._forceLayoutInstance;
        var vertexCount = edgeData.count() * 2;
        geometry.attributes.node.init(vertexCount);
        geometry.attributes.color.init(vertexCount);
        edgeData.each(function(idx) {
            var edge = edges[idx];
            geometry.attributes.node.set(offset, layoutInstance.getNodeUV(edge.node1));
            geometry.attributes.node.set(offset + 1, layoutInstance.getNodeUV(edge.node2));
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(edgeData, edge.dataIndex);
            var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
            colorArr[3] *= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(edgeData, edge.dataIndex), 1);
            geometry.attributes.color.set(offset, colorArr);
            geometry.attributes.color.set(offset + 1, colorArr);
            offset += 2;
        });
        geometry.dirty();
    },
    _updateMeshLinesGeometry: function() {
        var edgeData = this._model.getEdgeData();
        var geometry = this._edgesMesh.geometry;
        var edgeData = this._model.getEdgeData();
        var points = this._model.getData().getLayout('points');
        geometry.resetOffset();
        geometry.setVertexCount(edgeData.count() * geometry.getLineVertexCount());
        geometry.setTriangleCount(edgeData.count() * geometry.getLineTriangleCount());
        var p0 = [];
        var p1 = [];
        var lineWidthQuery = [
            'lineStyle',
            'width'
        ];
        this._originalEdgeColors = new Float32Array(edgeData.count() * 4);
        this._edgeIndicesMap = new Float32Array(edgeData.count());
        edgeData.each(function(idx) {
            var edge = edgeData.graph.getEdgeByIndex(idx);
            var idx1 = edge.node1.dataIndex * 2;
            var idx2 = edge.node2.dataIndex * 2;
            p0[0] = points[idx1];
            p0[1] = points[idx1 + 1];
            p1[0] = points[idx2];
            p1[1] = points[idx2 + 1];
            var color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(edgeData, edge.dataIndex);
            var colorArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(color);
            colorArr[3] *= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(edgeData, edge.dataIndex), 1);
            var itemModel = edgeData.getItemModel(edge.dataIndex);
            var lineWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(itemModel.get(lineWidthQuery), 1) * this._api.getDevicePixelRatio();
            geometry.addLine(p0, p1, colorArr, lineWidth);
            for(var k = 0; k < 4; k++){
                this._originalEdgeColors[edge.dataIndex * 4 + k] = colorArr[k];
            }
            this._edgeIndicesMap[edge.dataIndex] = idx;
        }, this);
        geometry.dirty();
    },
    _updateForceNodesGeometry: function(nodeData) {
        var pointsMesh = this._pointsBuilder.getPointsMesh();
        var pos = [];
        for(var i = 0; i < nodeData.count(); i++){
            this._forceLayoutInstance.getNodeUV(i, pos);
            pointsMesh.geometry.attributes.position.set(i, pos);
        }
        pointsMesh.geometry.dirty('position');
    },
    _initLayout: function(seriesModel, ecModel, api) {
        var layout = seriesModel.get('layout');
        var graph = seriesModel.getGraph();
        var boxLayoutOption = seriesModel.getBoxLayoutParams();
        var viewport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$util$2f$layout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutRect"])(boxLayoutOption, {
            width: api.getWidth(),
            height: api.getHeight()
        });
        if (layout === 'force') {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn('Currently only forceAtlas2 layout supported.');
            }
            layout = 'forceAtlas2';
        } // Stop previous layout
        this.stopLayout(seriesModel, ecModel, api, {
            beforeLayout: true
        });
        var nodeData = seriesModel.getData();
        var edgeData = seriesModel.getData();
        if (layout === 'forceAtlas2') {
            var layoutModel = seriesModel.getModel('forceAtlas2');
            var layoutInstance = this._forceLayoutInstance;
            var nodes = [];
            var edges = [];
            var nodeDataExtent = nodeData.getDataExtent('value');
            var edgeDataExtent = edgeData.getDataExtent('value');
            var edgeWeightRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(layoutModel.get('edgeWeight'), 1.0);
            var nodeWeightRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(layoutModel.get('nodeWeight'), 1.0);
            if (typeof edgeWeightRange === 'number') {
                edgeWeightRange = [
                    edgeWeightRange,
                    edgeWeightRange
                ];
            }
            if (typeof nodeWeightRange === 'number') {
                nodeWeightRange = [
                    nodeWeightRange,
                    nodeWeightRange
                ];
            }
            var offset = 0;
            var nodesIndicesMap = {};
            var layoutPoints = new Float32Array(nodeData.count() * 2);
            graph.eachNode(function(node) {
                var dataIndex = node.dataIndex;
                var value = nodeData.get('value', dataIndex);
                var x;
                var y;
                if (nodeData.hasItemOption) {
                    var itemModel = nodeData.getItemModel(dataIndex);
                    x = itemModel.get('x');
                    y = itemModel.get('y');
                }
                if (x == null) {
                    // Random in rectangle
                    x = viewport.x + Math.random() * viewport.width;
                    y = viewport.y + Math.random() * viewport.height;
                }
                layoutPoints[offset * 2] = x;
                layoutPoints[offset * 2 + 1] = y;
                nodesIndicesMap[node.id] = offset++;
                var mass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].linearMap(value, nodeDataExtent, nodeWeightRange);
                if (isNaN(mass)) {
                    if (!isNaN(nodeWeightRange[0])) {
                        mass = nodeWeightRange[0];
                    } else {
                        mass = 1;
                    }
                }
                nodes.push({
                    x: x,
                    y: y,
                    mass: mass,
                    size: nodeData.getItemVisual(dataIndex, 'symbolSize')
                });
            });
            nodeData.setLayout('points', layoutPoints);
            graph.eachEdge(function(edge) {
                var dataIndex = edge.dataIndex;
                var value = nodeData.get('value', dataIndex);
                var weight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__number$3e$__["number"].linearMap(value, edgeDataExtent, edgeWeightRange);
                if (isNaN(weight)) {
                    if (!isNaN(edgeWeightRange[0])) {
                        weight = edgeWeightRange[0];
                    } else {
                        weight = 1;
                    }
                }
                edges.push({
                    node1: nodesIndicesMap[edge.node1.id],
                    node2: nodesIndicesMap[edge.node2.id],
                    weight: weight,
                    dataIndex: dataIndex
                });
            });
            if (!layoutInstance) {
                var isGPU = layoutModel.get('GPU');
                if (this._forceLayoutInstance) {
                    if (isGPU && !(this._forceLayoutInstance instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2GPU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) || !isGPU && !(this._forceLayoutInstance instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
                        // Mark to dispose
                        this._forceLayoutInstanceToDispose = this._forceLayoutInstance;
                    }
                }
                layoutInstance = this._forceLayoutInstance = isGPU ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2GPU$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$ForceAtlas2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            }
            layoutInstance.initData(nodes, edges);
            layoutInstance.updateOption(layoutModel.option); // Update lines geometry after first layout;
            this._updateForceEdgesGeometry(layoutInstance.getEdges(), seriesModel);
            this._updatePositionTexture();
            api.dispatchAction({
                type: 'graphGLStartLayout',
                from: this.uid
            });
        } else {
            var layoutPoints = new Float32Array(nodeData.count() * 2);
            var offset = 0;
            graph.eachNode(function(node) {
                var dataIndex = node.dataIndex;
                var x;
                var y;
                if (nodeData.hasItemOption) {
                    var itemModel = nodeData.getItemModel(dataIndex);
                    x = itemModel.get('x');
                    y = itemModel.get('y');
                }
                layoutPoints[offset++] = x;
                layoutPoints[offset++] = y;
            });
            nodeData.setLayout('points', layoutPoints);
            this._updateAfterLayout(seriesModel, ecModel, api);
        }
    },
    _updatePositionTexture: function() {
        var positionTex = this._forceLayoutInstance.getNodePositionTexture();
        this._pointsBuilder.setPositionTexture(positionTex);
        this._forceEdgesMesh.material.set('positionTex', positionTex);
    },
    startLayout: function(seriesModel, ecModel, api, payload) {
        if (payload && payload.from != null && payload.from !== this.uid) {
            return;
        }
        var viewGL = this.viewGL;
        var api = this._api;
        var layoutInstance = this._forceLayoutInstance;
        var data = this._model.getData();
        var layoutModel = this._model.getModel('forceAtlas2');
        if (!layoutInstance) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.error('None layout don\'t have startLayout action');
            }
            return;
        }
        this.groupGL.remove(this._edgesMesh);
        this.groupGL.add(this._forceEdgesMesh);
        if (!this._forceLayoutInstance) {
            return;
        }
        this._updateForceNodesGeometry(seriesModel.getData());
        this._pointsBuilder.hideLabels();
        var self = this;
        var layoutId = this._layoutId = globalLayoutId++;
        var maxSteps = layoutModel.getShallow('maxSteps');
        var steps = layoutModel.getShallow('steps');
        var stepsCount = 0;
        var syncStepCount = Math.max(steps * 2, 20);
        var doLayout = function(layoutId) {
            if (layoutId !== self._layoutId) {
                return;
            }
            if (layoutInstance.isFinished(maxSteps)) {
                api.dispatchAction({
                    type: 'graphGLStopLayout',
                    from: self.uid
                });
                api.dispatchAction({
                    type: 'graphGLFinishLayout',
                    points: data.getLayout('points'),
                    from: self.uid
                });
                return;
            }
            layoutInstance.update(viewGL.layer.renderer, steps, function() {
                self._updatePositionTexture(); // PENDING Performance.
                stepsCount += steps; // Sync posiiton every 20 steps.
                if (stepsCount >= syncStepCount) {
                    self._syncNodePosition(seriesModel);
                    stepsCount = 0;
                } // Position texture will been swapped. set every time.
                api.getZr().refresh();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$requestAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(function() {
                    doLayout(layoutId);
                });
            });
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$animation$2f$requestAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(function() {
            if (self._forceLayoutInstanceToDispose) {
                self._forceLayoutInstanceToDispose.dispose(viewGL.layer.renderer);
                self._forceLayoutInstanceToDispose = null;
            }
            doLayout(layoutId);
        });
        this._layouting = true;
    },
    stopLayout: function(seriesModel, ecModel, api, payload) {
        if (payload && payload.from != null && payload.from !== this.uid) {
            return;
        }
        this._layoutId = 0;
        this.groupGL.remove(this._forceEdgesMesh);
        this.groupGL.add(this._edgesMesh);
        if (!this._forceLayoutInstance) {
            return;
        }
        if (!this.viewGL.layer) {
            return;
        }
        if (!(payload && payload.beforeLayout)) {
            this._syncNodePosition(seriesModel);
            this._updateAfterLayout(seriesModel, ecModel, api);
        }
        this._api.getZr().refresh();
        this._layouting = false;
    },
    _syncNodePosition: function(seriesModel) {
        var points = this._forceLayoutInstance.getNodePosition(this.viewGL.layer.renderer);
        seriesModel.getData().setLayout('points', points);
        seriesModel.setNodePosition(points);
    },
    _updateAfterLayout: function(seriesModel, ecModel, api) {
        this._updateMeshLinesGeometry();
        this._pointsBuilder.removePositionTexture();
        this._pointsBuilder.updateLayout(seriesModel, ecModel, api);
        this._pointsBuilder.updateView(this.viewGL.camera);
        this._pointsBuilder.updateLabels();
        this._pointsBuilder.showLabels();
    },
    focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var data = this._model.getData();
        this._downplayAll();
        var dataIndex = payload.dataIndex;
        var graph = data.graph;
        var focusNodes = [];
        var node = graph.getNodeByIndex(dataIndex);
        focusNodes.push(node);
        node.edges.forEach(function(edge) {
            if (edge.dataIndex < 0) {
                return;
            }
            edge.node1 !== node && focusNodes.push(edge.node1);
            edge.node2 !== node && focusNodes.push(edge.node2);
        }, this);
        this._pointsBuilder.fadeOutAll(0.05);
        this._fadeOutEdgesAll(0.05);
        focusNodes.forEach(function(node) {
            this._pointsBuilder.highlight(data, node.dataIndex);
        }, this);
        this._pointsBuilder.updateLabels(focusNodes.map(function(node) {
            return node.dataIndex;
        }));
        var focusEdges = [];
        node.edges.forEach(function(edge) {
            if (edge.dataIndex >= 0) {
                this._highlightEdge(edge.dataIndex);
                focusEdges.push(edge);
            }
        }, this);
        this._focusNodes = focusNodes;
        this._focusEdges = focusEdges;
    },
    unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        this._downplayAll();
        this._pointsBuilder.fadeInAll();
        this._fadeInEdgesAll();
        this._pointsBuilder.updateLabels();
    },
    _highlightEdge: function(dataIndex) {
        var itemModel = this._model.getEdgeData().getItemModel(dataIndex);
        var emphasisColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(itemModel.get('emphasis.lineStyle.color') || itemModel.get('lineStyle.color'));
        var emphasisOpacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(itemModel.get('emphasis.lineStyle.opacity'), itemModel.get('lineStyle.opacity'), 1);
        emphasisColor[3] *= emphasisOpacity;
        this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], emphasisColor);
    },
    _downplayAll: function() {
        if (this._focusNodes) {
            this._focusNodes.forEach(function(node) {
                this._pointsBuilder.downplay(this._model.getData(), node.dataIndex);
            }, this);
        }
        if (this._focusEdges) {
            this._focusEdges.forEach(function(edge) {
                this._downplayEdge(edge.dataIndex);
            }, this);
        }
    },
    _downplayEdge: function(dataIndex) {
        var color = this._getColor(dataIndex, []);
        this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
    },
    _setEdgeFade: function() {
        var color = [];
        return function(dataIndex, percent) {
            this._getColor(dataIndex, color);
            color[3] *= percent;
            this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
        };
    }(),
    _getColor: function(dataIndex, out) {
        for(var i = 0; i < 4; i++){
            out[i] = this._originalEdgeColors[dataIndex * 4 + i];
        }
        return out;
    },
    _fadeOutEdgesAll: function(percent) {
        var graph = this._model.getData().graph;
        graph.eachEdge(function(edge) {
            this._setEdgeFade(edge.dataIndex, percent);
        }, this);
    },
    _fadeInEdgesAll: function() {
        this._fadeOutEdgesAll(1);
    },
    _updateCamera: function(seriesModel, api) {
        this.viewGL.setViewport(0, 0, api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
        var camera = this.viewGL.camera;
        var nodeData = seriesModel.getData();
        var points = nodeData.getLayout('points');
        var min = vec2.create(Infinity, Infinity);
        var max = vec2.create(-Infinity, -Infinity);
        var pt = [];
        for(var i = 0; i < points.length;){
            pt[0] = points[i++];
            pt[1] = points[i++];
            vec2.min(min, min, pt);
            vec2.max(max, max, pt);
        }
        var cy = (max[1] + min[1]) / 2;
        var cx = (max[0] + min[0]) / 2; // Only fit the camera when graph is not in the center.
        // PENDING
        if (cx > camera.left && cx < camera.right && cy < camera.bottom && cy > camera.top) {
            return;
        } // Scale a bit
        var width = Math.max(max[0] - min[0], 10); // Keep aspect
        var height = width / api.getWidth() * api.getHeight();
        width *= 1.4;
        height *= 1.4;
        min[0] -= width * 0.2;
        camera.left = min[0];
        camera.top = cy - height / 2;
        camera.bottom = cy + height / 2;
        camera.right = width + min[0];
        camera.near = 0;
        camera.far = 100;
    },
    dispose: function() {
        var renderer = this.viewGL.layer.renderer;
        if (this._forceLayoutInstance) {
            this._forceLayoutInstance.dispose(renderer);
        }
        this.groupGL.removeAll(); // Stop layout.
        this._layoutId = -1;
        this._pointsBuilder.dispose();
    },
    remove: function() {
        this.groupGL.removeAll();
        this._control.dispose();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/util.js [app-client] (ecmascript) <export * as util>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$GraphGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/GraphGLSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$GraphGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/GraphGLView.js [app-client] (ecmascript)");
;
;
;
;
function normalize(a) {
    if (!(a instanceof Array)) {
        a = [
            a,
            a
        ];
    }
    return a;
}
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$GraphGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$GraphGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerVisual(function(ecModel) {
        const paletteScope = {};
        ecModel.eachSeriesByType('graphGL', function(seriesModel) {
            var categoriesData = seriesModel.getCategoriesData();
            var data = seriesModel.getData();
            var categoryNameIdxMap = {};
            categoriesData.each(function(idx) {
                var name = categoriesData.getName(idx); // Add prefix to avoid conflict with Object.prototype.
                categoryNameIdxMap['ec-' + name] = idx;
                var itemModel = categoriesData.getItemModel(idx);
                var style = itemModel.getModel('itemStyle').getItemStyle();
                if (!style.fill) {
                    // Get color from palette.
                    style.fill = seriesModel.getColorFromPalette(name, paletteScope);
                }
                categoriesData.setItemVisual(idx, 'style', style);
                var symbolVisualList = [
                    'symbol',
                    'symbolSize',
                    'symbolKeepAspect'
                ];
                for(let i = 0; i < symbolVisualList.length; i++){
                    var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
                    if (symbolVisual != null) {
                        categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
                    }
                }
            }); // Assign category color to visual
            if (categoriesData.count()) {
                data.each(function(idx) {
                    var model = data.getItemModel(idx);
                    let categoryIdx = model.getShallow('category');
                    if (categoryIdx != null) {
                        if (typeof categoryIdx === 'string') {
                            categoryIdx = categoryNameIdxMap['ec-' + categoryIdx];
                        }
                        var categoryStyle = categoriesData.getItemVisual(categoryIdx, 'style');
                        var style = data.ensureUniqueItemVisual(idx, 'style');
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].extend(style, categoryStyle);
                        var visualList = [
                            'symbol',
                            'symbolSize',
                            'symbolKeepAspect'
                        ];
                        for(let i = 0; i < visualList.length; i++){
                            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
                        }
                    }
                });
            }
        });
    });
    registers.registerVisual(function(ecModel) {
        ecModel.eachSeriesByType('graphGL', function(seriesModel) {
            var graph = seriesModel.getGraph();
            var edgeData = seriesModel.getEdgeData();
            var symbolType = normalize(seriesModel.get('edgeSymbol'));
            var symbolSize = normalize(seriesModel.get('edgeSymbolSize'));
            edgeData.setVisual('drawType', 'stroke'); // var colorQuery = ['lineStyle', 'color'];
            // var opacityQuery = ['lineStyle', 'opacity'];
            edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);
            edgeData.setVisual('toSymbol', symbolType && symbolType[1]);
            edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
            edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
            edgeData.setVisual('style', seriesModel.getModel('lineStyle').getLineStyle());
            edgeData.each(function(idx) {
                var itemModel = edgeData.getItemModel(idx);
                var edge = graph.getEdgeByIndex(idx);
                var symbolType = normalize(itemModel.getShallow('symbol', true));
                var symbolSize = normalize(itemModel.getShallow('symbolSize', true)); // Edge visual must after node visual
                var style = itemModel.getModel('lineStyle').getLineStyle();
                var existsStyle = edgeData.ensureUniqueItemVisual(idx, 'style');
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__util$3e$__["util"].extend(existsStyle, style);
                switch(existsStyle.stroke){
                    case 'source':
                        {
                            var nodeStyle = edge.node1.getVisual('style');
                            existsStyle.stroke = nodeStyle && nodeStyle.fill;
                            break;
                        }
                    case 'target':
                        {
                            var nodeStyle = edge.node2.getVisual('style');
                            existsStyle.stroke = nodeStyle && nodeStyle.fill;
                            break;
                        }
                }
                symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);
                symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);
                symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);
                symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);
            });
        });
    });
    registers.registerAction({
        type: 'graphGLRoam',
        event: 'graphglroam',
        update: 'series.graphGL:roam'
    }, function(payload, ecModel) {
        ecModel.eachComponent({
            mainType: 'series',
            query: payload
        }, function(componentModel) {
            componentModel.setView(payload);
        });
    });
    function noop() {}
    registers.registerAction({
        type: 'graphGLStartLayout',
        event: 'graphgllayoutstarted',
        update: 'series.graphGL:startLayout'
    }, noop);
    registers.registerAction({
        type: 'graphGLStopLayout',
        event: 'graphgllayoutstopped',
        update: 'series.graphGL:stopLayout'
    }, noop);
    registers.registerAction({
        type: 'graphGLFocusNodeAdjacency',
        event: 'graphGLFocusNodeAdjacency',
        update: 'series.graphGL:focusNodeAdjacency'
    }, noop);
    registers.registerAction({
        type: 'graphGLUnfocusNodeAdjacency',
        event: 'graphGLUnfocusNodeAdjacency',
        update: 'series.graphGL:unfocusNodeAdjacency'
    }, noop);
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/graphGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/FlowGLSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/core/echarts.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/export/api/helper.js [app-client] (ecmascript) <export * as helper>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.flowGL',
    dependencies: [
        'geo',
        'grid',
        'bmap'
    ],
    visualStyleAccessPath: 'itemStyle',
    getInitialData: function(option, ecModel) {
        var coordType = this.get('coordinateSystem'); // TODO hotfix for the bug in echarts that get coord dimensions is undefined.
        var coordSysDimensions = coordType === 'geo' ? [
            'lng',
            'lat'
        ] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$core$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCoordinateSystemDimensions"])(coordType) || [
            'x',
            'y'
        ];
        if ("TURBOPACK compile-time truthy", 1) {
            if (coordSysDimensions.length > 2) {
                throw new Error('flowGL can only be used on 2d coordinate systems.');
            }
        }
        coordSysDimensions.push('vx', 'vy');
        var dimensions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$export$2f$api$2f$helper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__helper$3e$__["helper"].createDimensions(this.getSource(), {
            coordDimensions: coordSysDimensions,
            encodeDefine: this.get('encode'),
            dimensionsDefine: this.get('dimensions')
        });
        var data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"](dimensions, this);
        data.initData(this.getSource());
        return data;
    },
    defaultOption: {
        coordinateSystem: 'cartesian2d',
        zlevel: 10,
        supersampling: 1,
        // 128x128 particles
        particleType: 'point',
        particleDensity: 128,
        particleSize: 1,
        particleSpeed: 1,
        particleTrail: 2,
        colorTexture: null,
        gridWidth: 'auto',
        gridHeight: 'auto',
        itemStyle: {
            color: '#fff',
            opacity: 0.8
        }
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/Line2D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Lines geometry
 * Use screen space projected lines lineWidth > MAX_LINE_WIDTH
 * https://mattdesl.svbtle.com/drawing-lines-is-hard
 * @module echarts-gl/util/geometry/LinesGeometry
 * @author Yi Shen(http://github.com/pissang)
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
;
;
/**
 * @constructor
 * @alias module:echarts-gl/chart/flowGL/Line2D
 * @extends clay.Geometry
 */ var LinesGeometry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].extend(function() {
    return {
        dynamic: true,
        attributes: {
            position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Attribute('position', 'float', 3, 'POSITION')
        }
    };
}, /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */ {
    /**
   * Reset offset
   */ resetOffset: function() {
        this._vertexOffset = 0;
        this._faceOffset = 0;
    },
    /**
   * @param {number} nVertex
   */ setLineCount: function(nLine) {
        var attributes = this.attributes;
        var nVertex = 4 * nLine;
        var nTriangle = 2 * nLine;
        if (this.vertexCount !== nVertex) {
            attributes.position.init(nVertex);
        }
        if (this.triangleCount !== nTriangle) {
            if (nTriangle === 0) {
                this.indices = null;
            } else {
                this.indices = this.vertexCount > 0xffff ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
            }
        }
    },
    addLine: function(p) {
        var vertexOffset = this._vertexOffset;
        this.attributes.position.set(vertexOffset, [
            p[0],
            p[1],
            1
        ]);
        this.attributes.position.set(vertexOffset + 1, [
            p[0],
            p[1],
            -1
        ]);
        this.attributes.position.set(vertexOffset + 2, [
            p[0],
            p[1],
            2
        ]);
        this.attributes.position.set(vertexOffset + 3, [
            p[0],
            p[1],
            -2
        ]);
        this.setTriangleIndices(this._faceOffset++, [
            vertexOffset,
            vertexOffset + 1,
            vertexOffset + 2
        ]);
        this.setTriangleIndices(this._faceOffset++, [
            vertexOffset + 1,
            vertexOffset + 2,
            vertexOffset + 3
        ]);
        this._vertexOffset += 4;
    }
});
const __TURBOPACK__default__export__ = LinesGeometry;
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/vectorFieldParticle.glsl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = "@export ecgl.vfParticle.particle.fragment\n\nuniform sampler2D particleTexture;\nuniform sampler2D spawnTexture;\nuniform sampler2D velocityTexture;\n\nuniform float deltaTime;\nuniform float elapsedTime;\n\nuniform float speedScaling : 1.0;\n\nuniform vec2 textureSize;\nuniform vec4 region : [0, 0, 1, 1];\nuniform float firstFrameTime;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, v_Texcoord);\n bool spawn = false;\n if (p.w <= 0.0) {\n p = texture2D(spawnTexture, fract(v_Texcoord + elapsedTime / 10.0));\n p.w -= firstFrameTime;\n spawn = true;\n }\n vec2 v = texture2D(velocityTexture, fract(p.xy * region.zw + region.xy)).xy;\n v = (v - 0.5) * 2.0;\n p.z = length(v);\n p.xy += v * deltaTime / 10.0 * speedScaling;\n p.w -= deltaTime;\n\n if (spawn || p.xy != fract(p.xy)) {\n p.z = 0.0;\n }\n p.xy = fract(p.xy);\n\n gl_FragColor = p;\n}\n@end\n\n@export ecgl.vfParticle.renderPoints.vertex\n\n#define PI 3.1415926\n\nattribute vec2 texcoord : TEXCOORD_0;\n\nuniform sampler2D particleTexture;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nuniform float size : 1.0;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, texcoord);\n\n if (p.w > 0.0 && p.z > 1e-5) {\n gl_Position = worldViewProjection * vec4(p.xy * 2.0 - 1.0, 0.0, 1.0);\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n\n v_Mag = p.z;\n v_Uv = p.xy;\n\n gl_PointSize = size;\n}\n\n@end\n\n@export ecgl.vfParticle.renderPoints.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\nuniform sampler2D spriteTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n#ifdef SPRITETEXTURE_ENABLED\n gl_FragColor *= texture2D(spriteTexture, gl_PointCoord);\n if (color.a == 0.0) {\n discard;\n }\n#endif\n#ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.vertex\n\n#define PI 3.1415926\n\nattribute vec3 position : POSITION;\n\nuniform sampler2D particleTexture;\nuniform sampler2D prevParticleTexture;\n\nuniform float size : 1.0;\nuniform vec4 vp: VIEWPORT;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\n@import clay.util.rand\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, position.xy);\n vec4 p2 = texture2D(prevParticleTexture, position.xy);\n\n p.xy = p.xy * 2.0 - 1.0;\n p2.xy = p2.xy * 2.0 - 1.0;\n\n if (p.w > 0.0 && p.z > 1e-5) {\n vec2 dir = normalize(p.xy - p2.xy);\n vec2 norm = vec2(dir.y / vp.z, -dir.x / vp.w) * sign(position.z) * size;\n if (abs(position.z) == 2.0) {\n gl_Position = vec4(p.xy + norm, 0.0, 1.0);\n v_Uv = p.xy;\n v_Mag = p.z;\n }\n else {\n gl_Position = vec4(p2.xy + norm, 0.0, 1.0);\n v_Mag = p2.z;\n v_Uv = p2.xy;\n }\n gl_Position = worldViewProjection * gl_Position;\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n #ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n";
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/VectorFieldParticleSurface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/compositor/Pass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Shader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/Texture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/camera/Orthographic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/geometry/Plane.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/claygl/src/FrameBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$Line2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/Line2D.js [app-client] (ecmascript)"); // import TemporalSS from '../../effect/TemporalSuperSampling';
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$vectorFieldParticle$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/vectorFieldParticle.glsl.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['import'](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$vectorFieldParticle$2e$glsl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
function createSpriteCanvas(size) {
    var canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
    ctx.fill();
    return canvas;
} // import spriteUtil from '../../util/sprite';
var VectorFieldParticleSurface = function() {
    /**
   * @type {number}
   */ this.motionBlurFactor = 0.99;
    /**
   * Vector field lookup image
   * @type {clay.Texture2D}
   */ this.vectorFieldTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
        // minFilter: Texture.NEAREST,
        // magFilter: Texture.NEAREST,
        flipY: false
    });
    /**
   * Particle life range
   * @type {Array.<number>}
   */ this.particleLife = [
        5,
        20
    ];
    this._particleType = 'point';
    /**
   * @type {number}
   */ this._particleSize = 1;
    /**
   * @type {Array.<number>}
   */ this.particleColor = [
        1,
        1,
        1,
        1
    ];
    /**
   * @type {number}
   */ this.particleSpeedScaling = 1.0;
    /**
   * @type {clay.Texture2D}
   */ this._thisFrameTexture = null;
    this._particlePass = null;
    this._spawnTexture = null;
    this._particleTexture0 = null;
    this._particleTexture1 = null;
    this._particlePointsMesh = null;
    this._surfaceFrameBuffer = null;
    this._elapsedTime = 0.0;
    this._scene = null;
    this._camera = null;
    this._lastFrameTexture = null; // this._temporalSS = new TemporalSS(50);
    // this._antialising = false;
    this._supersampling = 1;
    this._downsampleTextures = [];
    this._width = 512;
    this._height = 512;
    this.init();
};
VectorFieldParticleSurface.prototype = {
    constructor: VectorFieldParticleSurface,
    init: function() {
        var parameters = {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLOAT,
            minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
            magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NEAREST,
            useMipmap: false
        };
        this._spawnTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](parameters);
        this._particleTexture0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](parameters);
        this._particleTexture1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](parameters);
        this._frameBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$FrameBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            depthBuffer: false
        });
        this._particlePass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.vfParticle.particle.fragment')
        });
        this._particlePass.setUniform('velocityTexture', this.vectorFieldTexture);
        this._particlePass.setUniform('spawnTexture', this._spawnTexture);
        this._downsamplePass = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$compositor$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('clay.compositor.downsample')
        });
        var particlePointsMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            // Render after last frame full quad
            renderOrder: 10,
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.vfParticle.renderPoints.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.vfParticle.renderPoints.fragment'))
            }),
            mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].POINTS,
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                dynamic: true,
                mainAttribute: 'texcoord0'
            })
        });
        var particleLinesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            // Render after last frame full quad
            renderOrder: 10,
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.vfParticle.renderLines.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.vfParticle.renderLines.fragment'))
            }),
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$Line2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](),
            culling: false
        });
        var lastFrameFullQuad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.color.vertex'), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Shader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].source('ecgl.color.fragment')) // DO NOT BLEND Blend will multiply alpha
            }),
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$geometry$2f$Plane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]()
        });
        lastFrameFullQuad.material.enableTexture('diffuseMap');
        this._particlePointsMesh = particlePointsMesh;
        this._particleLinesMesh = particleLinesMesh;
        this._lastFrameFullQuadMesh = lastFrameFullQuad;
        this._camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$camera$2f$Orthographic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._thisFrameTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this._lastFrameTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    },
    setParticleDensity: function(width, height) {
        var nVertex = width * height;
        var spawnTextureData = new Float32Array(nVertex * 4);
        var off = 0;
        var lifeRange = this.particleLife;
        for(var i = 0; i < width; i++){
            for(var j = 0; j < height; j++, off++){
                // x position, range [0 - 1]
                spawnTextureData[off * 4] = Math.random(); // y position, range [0 - 1]
                spawnTextureData[off * 4 + 1] = Math.random(); // Some property
                spawnTextureData[off * 4 + 2] = Math.random();
                var life = (lifeRange[1] - lifeRange[0]) * Math.random() + lifeRange[0]; // Particle life
                spawnTextureData[off * 4 + 3] = life;
            }
        }
        if (this._particleType === 'line') {
            this._setLineGeometry(width, height);
        } else {
            this._setPointsGeometry(width, height);
        }
        this._spawnTexture.width = width;
        this._spawnTexture.height = height;
        this._spawnTexture.pixels = spawnTextureData;
        this._particleTexture0.width = this._particleTexture1.width = width;
        this._particleTexture0.height = this._particleTexture1.height = height;
        this._particlePass.setUniform('textureSize', [
            width,
            height
        ]);
    },
    _setPointsGeometry: function(width, height) {
        var nVertex = width * height;
        var geometry = this._particlePointsMesh.geometry;
        var attributes = geometry.attributes;
        attributes.texcoord0.init(nVertex);
        var off = 0;
        for(var i = 0; i < width; i++){
            for(var j = 0; j < height; j++, off++){
                attributes.texcoord0.value[off * 2] = i / width;
                attributes.texcoord0.value[off * 2 + 1] = j / height;
            }
        }
        geometry.dirty();
    },
    _setLineGeometry: function(width, height) {
        var nLine = width * height;
        var geometry = this._getParticleMesh().geometry;
        geometry.setLineCount(nLine);
        geometry.resetOffset();
        for(var i = 0; i < width; i++){
            for(var j = 0; j < height; j++){
                geometry.addLine([
                    i / width,
                    j / height
                ]);
            }
        }
        geometry.dirty();
    },
    _getParticleMesh: function() {
        return this._particleType === 'line' ? this._particleLinesMesh : this._particlePointsMesh;
    },
    update: function(renderer, api, deltaTime, firstFrame) {
        var particleMesh = this._getParticleMesh();
        var frameBuffer = this._frameBuffer;
        var particlePass = this._particlePass;
        if (firstFrame) {
            this._updateDownsampleTextures(renderer, api);
        }
        particleMesh.material.set('size', this._particleSize * this._supersampling);
        particleMesh.material.set('color', this.particleColor);
        particlePass.setUniform('speedScaling', this.particleSpeedScaling);
        frameBuffer.attach(this._particleTexture1);
        particlePass.setUniform('firstFrameTime', firstFrame ? (this.particleLife[1] + this.particleLife[0]) / 2 : 0);
        particlePass.setUniform('particleTexture', this._particleTexture0);
        particlePass.setUniform('deltaTime', deltaTime);
        particlePass.setUniform('elapsedTime', this._elapsedTime);
        particlePass.render(renderer, frameBuffer);
        particleMesh.material.set('particleTexture', this._particleTexture1);
        particleMesh.material.set('prevParticleTexture', this._particleTexture0);
        frameBuffer.attach(this._thisFrameTexture);
        frameBuffer.bind(renderer);
        renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
        var lastFrameFullQuad = this._lastFrameFullQuadMesh;
        lastFrameFullQuad.material.set('diffuseMap', this._lastFrameTexture);
        lastFrameFullQuad.material.set('color', [
            1,
            1,
            1,
            this.motionBlurFactor
        ]);
        this._camera.update(true);
        renderer.renderPass([
            lastFrameFullQuad,
            particleMesh
        ], this._camera);
        frameBuffer.unbind(renderer);
        this._downsample(renderer);
        this._swapTexture();
        this._elapsedTime += deltaTime;
    },
    _downsample: function(renderer) {
        var downsampleTextures = this._downsampleTextures;
        if (downsampleTextures.length === 0) {
            return;
        }
        var current = 0;
        var sourceTexture = this._thisFrameTexture;
        var targetTexture = downsampleTextures[current];
        while(targetTexture){
            this._frameBuffer.attach(targetTexture);
            this._downsamplePass.setUniform('texture', sourceTexture);
            this._downsamplePass.setUniform('textureSize', [
                sourceTexture.width,
                sourceTexture.height
            ]);
            this._downsamplePass.render(renderer, this._frameBuffer);
            sourceTexture = targetTexture;
            targetTexture = downsampleTextures[++current];
        }
    },
    getSurfaceTexture: function() {
        var downsampleTextures = this._downsampleTextures;
        return downsampleTextures.length > 0 ? downsampleTextures[downsampleTextures.length - 1] : this._lastFrameTexture;
    },
    setRegion: function(region) {
        this._particlePass.setUniform('region', region);
    },
    resize: function(width, height) {
        this._lastFrameTexture.width = width * this._supersampling;
        this._lastFrameTexture.height = height * this._supersampling;
        this._thisFrameTexture.width = width * this._supersampling;
        this._thisFrameTexture.height = height * this._supersampling;
        this._width = width;
        this._height = height;
    },
    setParticleSize: function(size) {
        var particleMesh = this._getParticleMesh();
        if (size <= 2) {
            particleMesh.material.disableTexture('spriteTexture');
            particleMesh.material.transparent = false;
            return;
        }
        if (!this._spriteTexture) {
            this._spriteTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        }
        if (!this._spriteTexture.image || this._spriteTexture.image.width !== size) {
            this._spriteTexture.image = createSpriteCanvas(size);
            this._spriteTexture.dirty();
        }
        particleMesh.material.transparent = true;
        particleMesh.material.enableTexture('spriteTexture');
        particleMesh.material.set('spriteTexture', this._spriteTexture);
        this._particleSize = size;
    },
    setGradientTexture: function(gradientTexture) {
        var material = this._getParticleMesh().material;
        material[gradientTexture ? 'enableTexture' : 'disableTexture']('gradientTexture');
        material.setUniform('gradientTexture', gradientTexture);
    },
    setColorTextureImage: function(colorTextureImg, api) {
        var material = this._getParticleMesh().material;
        material.setTextureImage('colorTexture', colorTextureImg, api, {
            flipY: true
        });
    },
    setParticleType: function(type) {
        this._particleType = type;
    },
    clearFrame: function(renderer) {
        var frameBuffer = this._frameBuffer;
        frameBuffer.attach(this._lastFrameTexture);
        frameBuffer.bind(renderer);
        renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
        frameBuffer.unbind(renderer);
    },
    setSupersampling: function(supersampling) {
        this._supersampling = supersampling;
        this.resize(this._width, this._height);
    },
    _updateDownsampleTextures: function(renderer, api) {
        var downsampleTextures = this._downsampleTextures;
        var upScale = Math.max(Math.floor(Math.log(this._supersampling / api.getDevicePixelRatio()) / Math.log(2)), 0);
        var scale = 2;
        var width = this._width * this._supersampling;
        var height = this._height * this._supersampling;
        for(var i = 0; i < upScale; i++){
            downsampleTextures[i] = downsampleTextures[i] || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$claygl$2f$src$2f$Texture2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            downsampleTextures[i].width = width / scale;
            downsampleTextures[i].height = height / scale;
            scale *= 2;
        }
        for(; i < downsampleTextures.length; i++){
            downsampleTextures[i].dispose(renderer);
        }
        downsampleTextures.length = upScale;
    },
    _swapTexture: function() {
        var tmp = this._particleTexture0;
        this._particleTexture0 = this._particleTexture1;
        this._particleTexture1 = tmp;
        var tmp = this._thisFrameTexture;
        this._thisFrameTexture = this._lastFrameTexture;
        this._lastFrameTexture = tmp;
    },
    dispose: function(renderer) {
        renderer.disposeFrameBuffer(this._frameBuffer); // Dispose textures
        renderer.disposeTexture(this.vectorFieldTexture);
        renderer.disposeTexture(this._spawnTexture);
        renderer.disposeTexture(this._particleTexture0);
        renderer.disposeTexture(this._particleTexture1);
        renderer.disposeTexture(this._thisFrameTexture);
        renderer.disposeTexture(this._lastFrameTexture);
        renderer.disposeGeometry(this._particleLinesMesh.geometry);
        renderer.disposeGeometry(this._particlePointsMesh.geometry);
        renderer.disposeGeometry(this._lastFrameFullQuadMesh.geometry);
        if (this._spriteTexture) {
            renderer.disposeTexture(this._spriteTexture);
        }
        this._particlePass.dispose(renderer);
        this._downsamplePass.dispose(renderer);
        this._downsampleTextures.forEach(function(texture) {
            texture.dispose(renderer);
        });
    }
};
const __TURBOPACK__default__export__ = VectorFieldParticleSurface;
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/FlowGLView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$VectorFieldParticleSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/VectorFieldParticleSurface.js [app-client] (ecmascript)"); // TODO 百度地图不是 linear 的
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'flowGL',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.viewGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('orthographic');
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this.viewGL.add(this.groupGL);
        this._particleSurface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$VectorFieldParticleSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        var planeMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PlaneGeometry(),
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader({
                    vertex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.color.vertex'),
                    fragment: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Shader.source('ecgl.color.fragment')
                }),
                // Must enable blending and multiply alpha.
                // Or premultipliedAlpha will let the alpha useless.
                transparent: true
            })
        });
        planeMesh.material.enableTexture('diffuseMap');
        this.groupGL.add(planeMesh);
        this._planeMesh = planeMesh;
    },
    render: function(seriesModel, ecModel, api) {
        var particleSurface = this._particleSurface; // Set particleType before set others.
        particleSurface.setParticleType(seriesModel.get('particleType'));
        particleSurface.setSupersampling(seriesModel.get('supersampling'));
        this._updateData(seriesModel, api);
        this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
        var particleDensity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('particleDensity'), 128);
        particleSurface.setParticleDensity(particleDensity, particleDensity);
        var planeMesh = this._planeMesh;
        var time = +new Date();
        var self = this;
        var firstFrame = true;
        planeMesh.__percent = 0;
        planeMesh.stopAnimation();
        planeMesh.animate('', {
            loop: true
        }).when(100000, {
            __percent: 1
        }).during(function() {
            var timeNow = +new Date();
            var dTime = Math.min(timeNow - time, 20);
            time = time + dTime;
            if (self._renderer) {
                particleSurface.update(self._renderer, api, dTime / 1000, firstFrame);
                planeMesh.material.set('diffuseMap', particleSurface.getSurfaceTexture()); // planeMesh.material.set('diffuseMap', self._particleSurface.vectorFieldTexture);
            }
            firstFrame = false;
        }).start();
        var itemStyleModel = seriesModel.getModel('itemStyle');
        var color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor(itemStyleModel.get('color'));
        color[3] *= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(itemStyleModel.get('opacity'), 1);
        planeMesh.material.set('color', color);
        particleSurface.setColorTextureImage(seriesModel.get('colorTexture'), api);
        particleSurface.setParticleSize(seriesModel.get('particleSize'));
        particleSurface.particleSpeedScaling = seriesModel.get('particleSpeed');
        particleSurface.motionBlurFactor = 1.0 - Math.pow(0.1, seriesModel.get('particleTrail'));
    },
    updateTransform: function(seriesModel, ecModel, api) {
        this._updateData(seriesModel, api);
    },
    afterRender: function(globeModel, ecModel, api, layerGL) {
        var renderer = layerGL.renderer;
        this._renderer = renderer;
    },
    _updateData: function(seriesModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var dims = coordSys.dimensions.map(function(coordDim) {
            return seriesModel.coordDimToDataDim(coordDim)[0];
        });
        var data = seriesModel.getData();
        var xExtent = data.getDataExtent(dims[0]);
        var yExtent = data.getDataExtent(dims[1]);
        var gridWidth = seriesModel.get('gridWidth');
        var gridHeight = seriesModel.get('gridHeight');
        if (gridWidth == null || gridWidth === 'auto') {
            // TODO not accurate.
            var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);
            gridWidth = Math.round(Math.sqrt(aspect * data.count()));
        }
        if (gridHeight == null || gridHeight === 'auto') {
            gridHeight = Math.ceil(data.count() / gridWidth);
        }
        var vectorFieldTexture = this._particleSurface.vectorFieldTexture; // Half Float needs Uint16Array
        var pixels = vectorFieldTexture.pixels;
        if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {
            pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);
        } else {
            for(var i = 0; i < pixels.length; i++){
                pixels[i] = 0;
            }
        }
        var maxMag = 0;
        var minMag = Infinity;
        var points = new Float32Array(data.count() * 2);
        var offset = 0;
        var bbox = [
            [
                Infinity,
                Infinity
            ],
            [
                -Infinity,
                -Infinity
            ]
        ];
        data.each([
            dims[0],
            dims[1],
            'vx',
            'vy'
        ], function(x, y, vx, vy) {
            var pt = coordSys.dataToPoint([
                x,
                y
            ]);
            points[offset++] = pt[0];
            points[offset++] = pt[1];
            bbox[0][0] = Math.min(pt[0], bbox[0][0]);
            bbox[0][1] = Math.min(pt[1], bbox[0][1]);
            bbox[1][0] = Math.max(pt[0], bbox[1][0]);
            bbox[1][1] = Math.max(pt[1], bbox[1][1]);
            var mag = Math.sqrt(vx * vx + vy * vy);
            maxMag = Math.max(maxMag, mag);
            minMag = Math.min(minMag, mag);
        });
        data.each([
            'vx',
            'vy'
        ], function(vx, vy, i) {
            var xPix = Math.round((points[i * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));
            var yPix = gridHeight - 1 - Math.round((points[i * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));
            var idx = (yPix * gridWidth + xPix) * 4;
            pixels[idx] = vx / maxMag * 0.5 + 0.5;
            pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;
            pixels[idx + 3] = 1;
        });
        vectorFieldTexture.width = gridWidth;
        vectorFieldTexture.height = gridHeight;
        if (seriesModel.get('coordinateSystem') === 'bmap') {
            this._fillEmptyPixels(vectorFieldTexture);
        }
        vectorFieldTexture.dirty();
        this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);
        this._updateGradientTexture(data.getVisual('visualMeta'), [
            minMag,
            maxMag
        ]);
    },
    // PENDING Use grid mesh ? or delaunay triangulation?
    _fillEmptyPixels: function(texture) {
        var pixels = texture.pixels;
        var width = texture.width;
        var height = texture.height;
        function fetchPixel(x, y, rg) {
            x = Math.max(Math.min(x, width - 1), 0);
            y = Math.max(Math.min(y, height - 1), 0);
            var idx = (y * (width - 1) + x) * 4;
            if (pixels[idx + 3] === 0) {
                return false;
            }
            rg[0] = pixels[idx];
            rg[1] = pixels[idx + 1];
            return true;
        }
        function addPixel(a, b, out) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
        }
        var center = [], left = [], right = [], top = [], bottom = [];
        var weight = 0;
        for(var y = 0; y < height; y++){
            for(var x = 0; x < width; x++){
                var idx = (y * (width - 1) + x) * 4;
                if (pixels[idx + 3] === 0) {
                    weight = center[0] = center[1] = 0;
                    if (fetchPixel(x - 1, y, left)) {
                        weight++;
                        addPixel(left, center, center);
                    }
                    if (fetchPixel(x + 1, y, right)) {
                        weight++;
                        addPixel(right, center, center);
                    }
                    if (fetchPixel(x, y - 1, top)) {
                        weight++;
                        addPixel(top, center, center);
                    }
                    if (fetchPixel(x, y + 1, bottom)) {
                        weight++;
                        addPixel(bottom, center, center);
                    }
                    center[0] /= weight;
                    center[1] /= weight; // PENDING If overwrite. bilinear interpolation.
                    pixels[idx] = center[0];
                    pixels[idx + 1] = center[1];
                }
                pixels[idx + 3] = 1;
            }
        }
    },
    _updateGradientTexture: function(visualMeta, magExtent) {
        if (!visualMeta || !visualMeta.length) {
            this._particleSurface.setGradientTexture(null);
            return;
        } // TODO Different dimensions
        this._gradientTexture = this._gradientTexture || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Texture2D({
            image: document.createElement('canvas')
        });
        var gradientTexture = this._gradientTexture;
        var canvas = gradientTexture.image;
        canvas.width = 200;
        canvas.height = 1;
        var ctx = canvas.getContext('2d');
        var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);
        visualMeta[0].stops.forEach(function(stop) {
            var offset;
            if (magExtent[1] === magExtent[0]) {
                offset = 0;
            } else {
                offset = stop.value / magExtent[1];
                offset = Math.min(Math.max(offset, 0), 1);
            }
            gradient.addColorStop(offset, stop.color);
        });
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        gradientTexture.dirty();
        this._particleSurface.setGradientTexture(this._gradientTexture);
    },
    _updatePlanePosition: function(leftTop, rightBottom, seriesModel, api) {
        var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);
        leftTop = limitedResult.leftTop;
        rightBottom = limitedResult.rightBottom;
        this._particleSurface.setRegion(limitedResult.region);
        this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);
        var width = rightBottom[0] - leftTop[0];
        var height = rightBottom[1] - leftTop[1];
        this._planeMesh.scale.set(width / 2, height / 2, 1);
        this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));
        if (this._renderer) {
            this._particleSurface.clearFrame(this._renderer);
        }
    },
    _limitInViewportAndFullFill: function(leftTop, rightBottom, seriesModel, api) {
        var newLeftTop = [
            Math.max(leftTop[0], 0),
            Math.max(leftTop[1], 0)
        ];
        var newRightBottom = [
            Math.min(rightBottom[0], api.getWidth()),
            Math.min(rightBottom[1], api.getHeight())
        ]; // Tiliing in lng orientation.
        if (seriesModel.get('coordinateSystem') === 'bmap') {
            var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim('lng')[0]); // PENDING, consider grid density
            var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;
            if (isContinuous) {
                if (newLeftTop[0] > 0) {
                    newLeftTop[0] = 0;
                }
                if (newRightBottom[0] < api.getWidth()) {
                    newRightBottom[0] = api.getWidth();
                }
            }
        }
        var width = rightBottom[0] - leftTop[0];
        var height = rightBottom[1] - leftTop[1];
        var newWidth = newRightBottom[0] - newLeftTop[0];
        var newHeight = newRightBottom[1] - newLeftTop[1];
        var region = [
            (newLeftTop[0] - leftTop[0]) / width,
            1.0 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height,
            newWidth / width,
            newHeight / height
        ];
        return {
            leftTop: newLeftTop,
            rightBottom: newRightBottom,
            region: region
        };
    },
    _updateCamera: function(width, height, dpr) {
        this.viewGL.setViewport(0, 0, width, height, dpr);
        var camera = this.viewGL.camera; // FIXME  bottom can't be larger than top
        camera.left = camera.bottom = 0;
        camera.top = height;
        camera.right = width;
        camera.near = 0;
        camera.far = 100;
        camera.position.z = 10;
    },
    remove: function() {
        this._planeMesh.stopAnimation();
        this.groupGL.removeAll();
    },
    dispose: function() {
        if (this._renderer) {
            this._particleSurface.dispose(this._renderer);
        }
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$FlowGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/FlowGLSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$FlowGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/FlowGLView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$FlowGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$FlowGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/flowGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/chart/linesGL/LinesGLSeries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/model/Series.js [app-client] (ecmascript) <export default as SeriesModel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/data/SeriesData.js [app-client] (ecmascript) <export default as List>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zrender/lib/core/util.js [app-client] (ecmascript)");
;
;
var LinesGLSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$model$2f$Series$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__SeriesModel$3e$__["SeriesModel"].extend({
    type: 'series.linesGL',
    dependencies: [
        'grid',
        'geo'
    ],
    visualStyleAccessPath: 'lineStyle',
    visualDrawType: 'stroke',
    streamEnabled: true,
    init: function(option) {
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
            option.data = new Float32Array(result.count);
        }
        LinesGLSeries.superApply(this, 'init', arguments);
    },
    mergeOption: function(option) {
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
            option.data = new Float32Array(result.count);
        }
        LinesGLSeries.superApply(this, 'mergeOption', arguments);
    },
    appendData: function(params) {
        var result = this._processFlatCoordsArray(params.data);
        if (result.flatCoords) {
            if (!this._flatCoords) {
                this._flatCoords = result.flatCoords;
                this._flatCoordsOffset = result.flatCoordsOffset;
            } else {
                this._flatCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatArray"])(this._flatCoords, result.flatCoords);
                this._flatCoordsOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zrender$2f$lib$2f$core$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatArray"])(this._flatCoordsOffset, result.flatCoordsOffset);
            }
            params.data = new Float32Array(result.count);
        }
        this.getRawData().appendData(params.data);
    },
    _getCoordsFromItemModel: function(idx) {
        var itemModel = this.getData().getItemModel(idx);
        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');
        if ("TURBOPACK compile-time truthy", 1) {
            if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
                throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');
            }
        }
        return coords;
    },
    getLineCoordsCount: function(idx) {
        if (this._flatCoordsOffset) {
            return this._flatCoordsOffset[idx * 2 + 1];
        } else {
            return this._getCoordsFromItemModel(idx).length;
        }
    },
    getLineCoords: function(idx, out) {
        if (this._flatCoordsOffset) {
            var offset = this._flatCoordsOffset[idx * 2];
            var len = this._flatCoordsOffset[idx * 2 + 1];
            for(var i = 0; i < len; i++){
                out[i] = out[i] || [];
                out[i][0] = this._flatCoords[offset + i * 2];
                out[i][1] = this._flatCoords[offset + i * 2 + 1];
            }
            return len;
        } else {
            var coords = this._getCoordsFromItemModel(idx);
            for(var i = 0; i < coords.length; i++){
                out[i] = out[i] || [];
                out[i][0] = coords[i][0];
                out[i][1] = coords[i][1];
            }
            return coords.length;
        }
    },
    _processFlatCoordsArray: function(data) {
        var startOffset = 0;
        if (this._flatCoords) {
            startOffset = this._flatCoords.length;
        } // Stored as a typed array. In format
        // Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |
        if (typeof data[0] === 'number') {
            var len = data.length; // Store offset and len of each segment
            var coordsOffsetAndLenStorage = new Uint32Array(len);
            var coordsStorage = new Float64Array(len);
            var coordsCursor = 0;
            var offsetCursor = 0;
            var dataCount = 0;
            for(var i = 0; i < len;){
                dataCount++;
                var count = data[i++]; // Offset
                coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset; // Len
                coordsOffsetAndLenStorage[offsetCursor++] = count;
                for(var k = 0; k < count; k++){
                    var x = data[i++];
                    var y = data[i++];
                    coordsStorage[coordsCursor++] = x;
                    coordsStorage[coordsCursor++] = y;
                    if (i > len) {
                        if ("TURBOPACK compile-time truthy", 1) {
                            throw new Error('Invalid data format.');
                        }
                    }
                }
            }
            return {
                flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
                flatCoords: coordsStorage,
                count: dataCount
            };
        }
        return {
            flatCoordsOffset: null,
            flatCoords: null,
            count: data.length
        };
    },
    getInitialData: function(option, ecModel) {
        var lineData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$data$2f$SeriesData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__List$3e$__["List"]([
            'value'
        ], this);
        lineData.hasItemOption = false;
        lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
            // dataItem is simply coords
            if (dataItem instanceof Array) {
                return NaN;
            } else {
                lineData.hasItemOption = true;
                var value = dataItem.value;
                if (value != null) {
                    return value instanceof Array ? value[dimIndex] : value;
                }
            }
        });
        return lineData;
    },
    defaultOption: {
        coordinateSystem: 'geo',
        zlevel: 10,
        progressive: 1e4,
        progressiveThreshold: 5e4,
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        // Support source-over, lighter
        blendMode: 'source-over',
        lineStyle: {
            opacity: 0.8
        },
        postEffect: {
            enable: false,
            colorCorrection: {
                exposure: 0,
                brightness: 0,
                contrast: 1,
                saturation: 1,
                enable: true
            }
        }
    }
});
const __TURBOPACK__default__export__ = LinesGLSeries;
}}),
"[project]/node_modules/echarts-gl/lib/chart/linesGL/LinesGLView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/view/Chart.js [app-client] (ecmascript) <export default as ChartView>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/graphicGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/core/ViewGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/geometry/Lines2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$GLViewHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/common/GLViewHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/visual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/util/retrieve.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$view$2f$Chart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__ChartView$3e$__["ChartView"].extend({
    type: 'linesGL',
    __ecgl__: true,
    init: function(ecModel, api) {
        this.groupGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Node();
        this.viewGL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$core$2f$ViewGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('orthographic');
        this.viewGL.add(this.groupGL);
        this._glViewHelper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$common$2f$GLViewHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.viewGL);
        this._nativeLinesShader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.lines3D');
        this._meshLinesShader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.meshLines3D');
        this._linesMeshes = [];
        this._currentStep = 0;
    },
    render: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        this._glViewHelper.reset(seriesModel, api);
        var linesMesh = this._linesMeshes[0];
        if (!linesMesh) {
            linesMesh = this._linesMeshes[0] = this._createLinesMesh(seriesModel);
        }
        this._linesMeshes.length = 1;
        this.groupGL.add(linesMesh);
        this._updateLinesMesh(seriesModel, linesMesh, 0, seriesModel.getData().count());
        this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this.groupGL.removeAll();
        this._glViewHelper.reset(seriesModel, api);
        this._currentStep = 0;
        this.viewGL.setPostEffect(seriesModel.getModel('postEffect'), api);
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
        var linesMesh = this._linesMeshes[this._currentStep];
        if (!linesMesh) {
            linesMesh = this._createLinesMesh(seriesModel);
            this._linesMeshes[this._currentStep] = linesMesh;
        }
        this._updateLinesMesh(seriesModel, linesMesh, params.start, params.end);
        this.groupGL.add(linesMesh);
        api.getZr().refresh();
        this._currentStep++;
    },
    updateTransform: function(seriesModel, ecModel, api) {
        if (seriesModel.coordinateSystem.getRoamTransform) {
            this._glViewHelper.updateTransform(seriesModel, api);
        }
    },
    _createLinesMesh: function(seriesModel) {
        var linesMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh({
            $ignorePicking: true,
            material: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Material({
                shader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createShader('ecgl.lines3D'),
                transparent: true,
                depthMask: false,
                depthTest: false
            }),
            geometry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$geometry$2f$Lines2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
                segmentScale: 10,
                useNativeLine: true,
                dynamic: false
            }),
            mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.LINES,
            culling: false
        });
        return linesMesh;
    },
    _updateLinesMesh: function(seriesModel, linesMesh, start, end) {
        var data = seriesModel.getData();
        linesMesh.material.blend = seriesModel.get('blendMode') === 'lighter' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].additiveBlend : null;
        var curveness = seriesModel.get('lineStyle.curveness') || 0;
        var isPolyline = seriesModel.get('polyline');
        var geometry = linesMesh.geometry;
        var coordSys = seriesModel.coordinateSystem;
        var lineWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull(seriesModel.get('lineStyle.width'), 1);
        if (lineWidth > 1) {
            if (linesMesh.material.shader !== this._meshLinesShader) {
                linesMesh.material.attachShader(this._meshLinesShader);
            }
            linesMesh.mode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.TRIANGLES;
        } else {
            if (linesMesh.material.shader !== this._nativeLinesShader) {
                linesMesh.material.attachShader(this._nativeLinesShader);
            }
            linesMesh.mode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Mesh.LINES;
        }
        start = start || 0;
        end = end || data.count();
        geometry.resetOffset();
        var vertexCount = 0;
        var triangleCount = 0;
        var p0 = [];
        var p1 = [];
        var p2 = [];
        var p3 = [];
        var lineCoords = [];
        var t = 0.3;
        var t2 = 0.7;
        function updateBezierControlPoints() {
            p1[0] = p0[0] * t2 + p3[0] * t - (p0[1] - p3[1]) * curveness;
            p1[1] = p0[1] * t2 + p3[1] * t - (p3[0] - p0[0]) * curveness;
            p2[0] = p0[0] * t + p3[0] * t2 - (p0[1] - p3[1]) * curveness;
            p2[1] = p0[1] * t + p3[1] * t2 - (p3[0] - p0[0]) * curveness;
        }
        if (isPolyline || curveness !== 0) {
            for(var idx = start; idx < end; idx++){
                if (isPolyline) {
                    var count = seriesModel.getLineCoordsCount(idx);
                    vertexCount += geometry.getPolylineVertexCount(count);
                    triangleCount += geometry.getPolylineTriangleCount(count);
                } else {
                    seriesModel.getLineCoords(idx, lineCoords);
                    this._glViewHelper.dataToPoint(coordSys, lineCoords[0], p0);
                    this._glViewHelper.dataToPoint(coordSys, lineCoords[1], p3);
                    updateBezierControlPoints();
                    vertexCount += geometry.getCubicCurveVertexCount(p0, p1, p2, p3);
                    triangleCount += geometry.getCubicCurveTriangleCount(p0, p1, p2, p3);
                }
            }
        } else {
            var lineCount = end - start;
            vertexCount += lineCount * geometry.getLineVertexCount();
            triangleCount += lineCount * geometry.getLineVertexCount();
        }
        geometry.setVertexCount(vertexCount);
        geometry.setTriangleCount(triangleCount);
        var dataIndex = start;
        var colorArr = [];
        for(var idx = start; idx < end; idx++){
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$graphicGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].parseColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualColor"])(data, dataIndex), colorArr);
            var opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$retrieve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].firstNotNull((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$util$2f$visual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getItemVisualOpacity"])(data, dataIndex), 1);
            colorArr[3] *= opacity;
            var count = seriesModel.getLineCoords(idx, lineCoords);
            for(var k = 0; k < count; k++){
                this._glViewHelper.dataToPoint(coordSys, lineCoords[k], lineCoords[k]);
            }
            if (isPolyline) {
                geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, count);
            } else if (curveness !== 0) {
                p0 = lineCoords[0];
                p3 = lineCoords[1];
                updateBezierControlPoints();
                geometry.addCubicCurve(p0, p1, p2, p3, colorArr, lineWidth);
            } else {
                geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, 2);
            }
            dataIndex++;
        }
    },
    dispose: function() {
        this.groupGL.removeAll();
    },
    remove: function() {
        this.groupGL.removeAll();
    }
});
}}),
"[project]/node_modules/echarts-gl/lib/chart/linesGL/install.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TODO ECharts GL must be imported whatever component,charts is imported.
__turbopack_context__.s({
    "install": (()=>install)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$LinesGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/linesGL/LinesGLSeries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$LinesGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/linesGL/LinesGLView.js [app-client] (ecmascript)");
;
;
;
function install(registers) {
    registers.registerChartView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$LinesGLView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    registers.registerSeriesModel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$LinesGLSeries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
}
}}),
"[project]/node_modules/echarts-gl/lib/chart/linesGL.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$echarts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/echarts.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts/lib/extension.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/linesGL/install.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2f$lib$2f$extension$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2f$install$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["install"]);
}}),
"[project]/node_modules/echarts-gl/lib/export/all.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$echarts$2d$gl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/echarts-gl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$grid3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/grid3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$geo3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/geo3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$globe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/globe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$mapbox3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/mapbox3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$component$2f$maptalks3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/component/maptalks3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$bar3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/bar3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$line3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/line3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatter3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatter3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$lines3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/lines3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$polygons3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/polygons3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$surface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/surface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$map3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/map3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$scatterGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/scatterGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$graphGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/graphGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$flowGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/flowGL.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$chart$2f$linesGL$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/chart/linesGL.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}}),
"[project]/node_modules/echarts-gl/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$echarts$2d$gl$2f$lib$2f$export$2f$all$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/echarts-gl/lib/export/all.js [app-client] (ecmascript)");
;
}}),
}]);

//# sourceMappingURL=node_modules_echarts-gl_127fd0bc._.js.map